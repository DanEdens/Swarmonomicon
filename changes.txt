diff --git a/.cursorrules b/.cursorrules
index cb0ac36..ea5fd30 100644
--- a/.cursorrules
+++ b/.cursorrules
@@ -2,7 +2,7 @@ env is MacOS with zsh. Perfer Rust or Python3_11
 You can check for the availability of the commands in the environment at will
 0. Use trunk-based development with feature branches. use gh cli as needed. Before adding a feature, make a branch.
 1. STEP 1. Work on the problem as asked here. Update tests if they need it
-2. Run available tests (e.g. 'CARGO_TERM_COLOR=never cargo (build or test) --quiet') and iterate until successful build
+2. Run available tests (e.g. 'CARGO_TERM_COLOR=never cargo (build or test) -- --nocapture') and iterate until successful build
 3. Maintain a "Lessons Learned" section in lessons.md
 4. Update TODO.md with progress after completing features

diff --git a/.gitmodules b/.gitmodules
index b9a0726..82cae47 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,6 @@
 [submodule "browser-agent"]
 	path = browser-agent
 	url = https://github.com/m1guelpf/browser-agent.git
+[submodule "examples_to_delete/balena-cl-interactive"]
+	path = examples_to_delete/balena-cl-interactive
+	url = https://github.com/DanEdens/balena-cl-interactive.git
diff --git a/Architecture.md b/Architecture.md
new file mode 100644
index 0000000..11d88fa
--- /dev/null
+++ b/Architecture.md
@@ -0,0 +1,69 @@
+# Swarmonomicon Architecture
+
+## Overview
+Swarmonomicon is a multi-agent system that coordinates different specialized agents to handle various tasks like git operations, project initialization, and creative content generation. The system uses a transfer service to manage communication between agents and maintains a global registry of available agents.
+
+## Core Components
+
+### 1. Agent System
+- **Base Agent Trait**: Defines core functionality all agents must implement
+  - Message processing
+  - Tool handling
+  - State management
+  - Configuration
+
+### 2. Registry System
+- **Global Registry**: Maintains references to all available agents
+  - Thread-safe access via `Arc<RwLock<AgentRegistry>>`
+  - Dynamic agent registration
+  - Agent lookup by name
+
+### 3. Transfer Service
+- **State Machine**: Manages transitions between agents
+- **Message Routing**: Directs messages to appropriate agents
+- **Context Preservation**: Maintains context across agent transfers
+
+### 4. Specialized Agents
+1. **Git Assistant Agent**
+   - Handles git operations
+   - Generates commit messages
+   - Manages branches and merges
+
+2. **Project Init Agent**
+   - Creates new project structures
+   - Sets up configuration files
+   - Initializes git repositories
+
+3. **Haiku Agent**
+   - Generates creative content
+   - Integrates with git for committing haikus
+
+4. **Greeter Agent**
+   - Entry point for user interaction
+   - Command routing
+   - Help system
+
+## Current Implementation Issues
+
+### Agent Registration
+1. Type Mismatch: The registry expects agents implementing the `Agent` trait, but we're wrapping them in multiple layers:
+   ```rust
+   Arc<RwLock<AgentImpl>> // Current structure
+   ```
+
+### Concurrency Model
+1. Thread Safety: Using `Arc<RwLock>` for shared access
+2. Async Operations: Using Tokio for async runtime
+3. Need to ensure proper locking patterns
+
+### Message Flow
+1. Command Line Interface → Greeter → Specialized Agents
+2. Inter-agent communication through Transfer Service
+3. State preservation during transfers
+
+## Design Principles
+1. Thread-safe agent access
+2. Async-first architecture
+3. Modular agent system
+4. Clear ownership boundaries
+5. Type-safe message passing

 [lib]
 name = "swarmonomicon"
diff --git a/TODO.md b/TODO.md
new file mode 100644
index 0000000..a119c58
--- /dev/null
+++ b/TODO.md
@@ -0,0 +1,132 @@
+# TODO List
+
+## High Priority
+
+### Fix Agent Registration System
+1. [x] Update `AgentRegistry` implementation
+   - [x] Review internal storage type (`Arc<Box<dyn Agent + Send + Sync>>`)
+   - [x] Consider if we need both `Arc` and `Box`
+   - [x] Document the wrapping pattern decisions
+
+2. [ ] Fix `TransferService` implementation
+   - [x] Review how it interacts with `AgentRegistry`
+   - [ ] Consider if we need `Arc<RwLock<AgentRegistry>>` or if `Arc<AgentRegistry>` is sufficient
+   - [ ] Update methods to handle concurrent access correctly
+
+3. [x] Update agent registration in `swarm.rs`
+   - [x] Remove direct `Arc<RwLock>` wrapping of agents
+   - [x] Let `AgentRegistry::register` handle the wrapping
+   - [x] Update the test cases to match this pattern
+
+4. [ ] Fix type mismatches
+   - [x] Update `get_agent` to return correct type
+   - [ ] Fix `registry.read()` vs `registry.write()` usage
+   - [ ] Ensure consistent agent access patterns
+
+### Current Issues to Fix
+1. [ ] Fix lifetime issue in `AgentWrapper::get_mut`
+   ```rust
+   // Current issue:
+   pub fn get_mut(&mut self) -> Option<&mut (dyn Agent + Send + Sync + '_)>
+   ```
+
+2. [ ] Fix trait method access in `routes.rs`
+   - [ ] Import `Agent` trait where needed
+   - [ ] Ensure proper trait bounds on generic parameters
+
+3. [ ] Review locking patterns in `TransferService`
+   - [ ] Consider if we need write locks for read-only operations
+   - [ ] Add timeouts to prevent deadlocks
+   - [ ] Handle lock poisoning cases
+
+### Test Coverage
+1. [ ] Fix failing integration tests
+   - [ ] Review `test_haiku_git_integration`
+   - [ ] Ensure proper cleanup in tests
+   - [ ] Add more granular test cases
+
+2. [ ] Add unit tests
+   - [x] Test agent registration
+   - [ ] Test message routing
+   - [ ] Test state transitions
+
+## Medium Priority
+
+### Documentation
+1. [ ] Add inline documentation for public APIs
+2. [ ] Create usage examples
+3. [ ] Document concurrency patterns
+
+### Features
+1. [ ] Implement proper error handling for agent transfers
+2. [ ] Add timeout mechanism for long-running operations
+3. [ ] Implement agent state persistence
+4. [ ] Add configuration file support
+
+## Low Priority
+
+### Improvements
+1. [ ] Add metrics collection
+2. [ ] Implement logging system
+3. [ ] Add health checks for agents
+4. [ ] Create admin interface
+
+### Technical Debt
+1. [ ] Reduce code duplication in agent implementations
+2. [ ] Optimize lock patterns
+3. [ ] Implement proper shutdown sequence
+4. [ ] Add proper error types instead of using Box<dyn Error>
+
+## Completed
+- [x] Create initial agent system
+- [x] Implement basic message routing
+- [x] Add git operations support
+- [x] Add haiku generation
+- [x] Implement project initialization
+- [x] Create `AgentWrapper` to handle type complexity
+- [x] Update `AgentRegistry` to use wrapper type
+- [x] Update agent registration to use new pattern
+
+## Next Steps
+1. Create a wrapper type for agents to handle the type complexity:
+   ```rust
+   pub struct AgentWrapper {
+       inner: Arc<Box<dyn Agent + Send + Sync>>,
+   }
+
+   impl AgentWrapper {
+       pub fn new<A>(agent: A) -> Self
+       where
+           A: Agent + Send + Sync + 'static
+       {
+           Self {
+               inner: Arc::new(Box::new(agent))
+           }
+       }
+   }
+   ```
+
+2. Update the `AgentRegistry` to use this wrapper:
+   ```rust
+   pub struct AgentRegistry {
+       agents: HashMap<String, AgentWrapper>,
+   }
+   ```
+
+3. Update the `TransferService` to handle the wrapper:
+   ```rust
+   impl TransferService {
+       pub async fn process_message(&mut self, content: &str) -> Result<Message> {
+           let registry = self.registry.read().await;
+           if let Some(current_agent) = &self.current_agent {
+               if let Some(agent) = registry.get(current_agent) {
+                   agent.process_message(content).await
+               } else {
+                   Err(format!("Current agent '{}' not found", current_agent).into())
+               }
+           } else {
+               Err("No current agent set".into())
+           }
+       }
+   }
+   ```
diff --git a/examples_to_delete/balena-cl-interactive b/examples_to_delete/balena-cl-interactive
new file mode 160000
index 0000000..e47a656
--- /dev/null
+++ b/examples_to_delete/balena-cl-interactive
@@ -0,0 +1 @@
+Subproject commit e47a656010aadfc609f8b0d69b16de5dc615471e
diff --git a/src/agents/balena_wrapper.rs b/src/agents/balena_wrapper.rs
new file mode 100644
index 0000000..5dc55a0
--- /dev/null
+++ b/src/agents/balena_wrapper.rs
@@ -0,0 +1,219 @@
+use async_trait::async_trait;
+use std::collections::HashMap;
+use std::process::Command;
+use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall};
+
+pub struct BalenaWrapperAgent {
+    config: AgentConfig,
+    state_manager: AgentStateManager,
+}
+
+impl BalenaWrapperAgent {
+    pub fn new(config: AgentConfig) -> Self {
+        let state_machine = Some(StateMachine {
+            states: {
+                let mut states = HashMap::new();
+                states.insert("awaiting_command".to_string(), State {
+                    prompt: "🛸 Fleet Commander ready. What IoT operations shall we initiate today?".to_string(),
+                    transitions: {
+                        let mut transitions = HashMap::new();
+                        transitions.insert("command_received".to_string(), "executing".to_string());
+                        transitions
+                    },
+                    validation: None,
+                });
+                states.insert("executing".to_string(), State {
+                    prompt: "⚡ Executing fleet command... Stand by for quantum entanglement.".to_string(),
+                    transitions: {
+                        let mut transitions = HashMap::new();
+                        transitions.insert("complete".to_string(), "awaiting_command".to_string());
+                        transitions
+                    },
+                    validation: None,
+                });
+                states
+            },
+            initial_state: "awaiting_command".to_string(),
+        });
+
+        Self {
+            config,
+            state_manager: AgentStateManager::new(state_machine),
+        }
+    }
+
+    fn create_response(&self, content: String) -> Message {
+        let current_state = self.state_manager.get_current_state_name();
+        let metadata = MessageMetadata::new(self.config.name.clone())
+            .with_state(current_state.unwrap_or("awaiting_command").to_string())
+            .with_personality(vec![
+                "fleet_commander".to_string(),
+                "precise".to_string(),
+                "iot_focused".to_string(),
+                "system_oriented".to_string(),
+                "deployment_expert".to_string(),
+            ]);
+
+        Message {
+            content,
+            metadata,
+            parameters: {
+                let mut params = HashMap::new();
+                params.insert("style".to_string(), "fleet_commander".to_string());
+                params.insert("domain".to_string(), "iot_operations".to_string());
+                params
+            },
+            tool_calls: None,
+            confidence: Some(1.0),
+        }
+    }
+
+    fn format_fleet_response(&self, content: String) -> Message {
+        let prefix = match content.to_lowercase() {
+            s if s.contains("error") => "🚨 Fleet Alert: ",
+            s if s.contains("success") => "✅ Operation Complete: ",
+            s if s.contains("push") => "🚀 Deployment Status: ",
+            s if s.contains("device") => "📱 Device Update: ",
+            _ => "🛸 Fleet Command: ",
+        };
+
+        self.create_response(format!("{}{}", prefix, content))
+    }
+
+    fn get_help_message(&self) -> Message {
+        self.format_fleet_response(
+            "Welcome to the IoT Fleet Command Center! Available operations:\n\
+             - 'devices': Scan for connected fleet units\n\
+             - 'push <app>': Deploy updates to target application\n\
+             - 'logs <device>': Monitor quantum transmissions from device\n\
+             - 'ssh <device>': Establish secure neural link to device\n\
+             - 'status': Monitor fleet-wide operational status\n\
+             - 'wifi <device> <ssid> <psk>': Configure device network matrix\n\
+             - 'scan': Initiate fleet-wide diagnostics".to_string()
+        )
+    }
+
+    async fn execute_balena_command(&self, args: &[&str]) -> Result<String> {
+        let output = Command::new("balena")
+            .args(args)
+            .output()?;
+
+        if output.status.success() {
+            Ok(String::from_utf8_lossy(&output.stdout).to_string())
+        } else {
+            Ok(format!("Error: {}", String::from_utf8_lossy(&output.stderr)))
+        }
+    }
+}
+
+#[async_trait]
+impl Agent for BalenaWrapperAgent {
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        let parts: Vec<&str> = message.content.split_whitespace().collect();
+
+        if parts.is_empty() {
+            return Ok(self.get_help_message());
+        }
+
+        let response = match parts[0] {
+            "devices" => {
+                self.execute_balena_command(&["devices"]).await?
+            },
+            "push" if parts.len() > 1 => {
+                self.execute_balena_command(&["push", parts[1]]).await?
+            },
+            "logs" if parts.len() > 1 => {
+                self.execute_balena_command(&["logs", parts[1]]).await?
+            },
+            "ssh" if parts.len() > 1 => {
+                self.execute_balena_command(&["ssh", parts[1]]).await?
+            },
+            "status" => {
+                self.execute_balena_command(&["device", "list"]).await?
+            },
+            "wifi" if parts.len() > 3 => {
+                self.execute_balena_command(&["wifi", parts[1], parts[2], parts[3]]).await?
+            },
+            "scan" => {
+                self.execute_balena_command(&["scan"]).await?
+            },
+            _ => "Unknown fleet command. Use 'help' to view available operations.".to_string(),
+        };
+
+        Ok(self.format_fleet_response(response))
+    }
+
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
+    }
+
+    async fn call_tool(&self, _tool_call: ToolCall) -> Result<Message> {
+        Ok(self.format_fleet_response(
+            "Direct tool interface not available. Please use fleet command protocols.".to_string()
+        ))
+    }
+
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(self.state_manager.get_current_state().cloned())
+    }
+
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn create_test_config() -> AgentConfig {
+        AgentConfig {
+            name: "balena".to_string(),
+            public_description: "IoT Fleet Command & Control Center".to_string(),
+            instructions: "Manage and deploy IoT device fleets with precision".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: Some(serde_json::json!({
+                "style": "fleet_commander",
+                "traits": ["precise", "iot_focused", "system_oriented", "deployment_expert"],
+                "voice": {
+                    "tone": "authoritative_technical",
+                    "pacing": "measured_and_clear",
+                    "quirks": ["uses_fleet_metaphors", "speaks_in_system_terms", "quantum_terminology"]
+                }
+            }).to_string()),
+            state_machine: None,
+        }
+    }
+
+    #[tokio::test]
+    async fn test_help_message() {
+        let agent = BalenaWrapperAgent::new(create_test_config());
+        let response = agent.process_message(Message {
+            content: "help".to_string(),
+            metadata: MessageMetadata::new("user".to_string()),
+            parameters: HashMap::new(),
+            tool_calls: None,
+            confidence: None,
+        }).await.unwrap();
+
+        assert!(response.content.contains("Fleet Command Center"));
+        assert!(response.content.contains("devices"));
+        assert!(response.content.contains("push"));
+    }
+
+    #[tokio::test]
+    async fn test_device_list() {
+        let agent = BalenaWrapperAgent::new(create_test_config());
+        let response = agent.process_message(Message {
+            content: "devices".to_string(),
+            metadata: MessageMetadata::new("user".to_string()),
+            parameters: HashMap::new(),
+            tool_calls: None,
+            confidence: None,
+        }).await.unwrap();
+
+        // Note: This test might fail if balena CLI is not installed or configured
+        assert!(response.content.contains("Fleet") || response.content.contains("Error"));
+    }
+}
diff --git a/src/agents/browser_agent.rs b/src/agents/browser_agent.rs
new file mode 100644
index 0000000..0fa510d
--- /dev/null
+++ b/src/agents/browser_agent.rs
@@ -0,0 +1,58 @@
+use std::collections::HashMap;
+use async_trait::async_trait;
+use crate::types::{Agent, AgentConfig, Message, Result, Tool};
+use browser_agent::Conversation;
+use serde::Deserialize;
+
+#[derive(Debug, Deserialize)]
+pub struct BrowserAgentConfig {
+    pub instructions: String,
+}
+
+pub struct BrowserAgentWrapper {
+    inner: Conversation,
+    browser_config: BrowserAgentConfig,
+    agent_config: AgentConfig,
+}
+
+impl BrowserAgentWrapper {
+    pub fn new(config: AgentConfig) -> Result<Self> {
+        let browser_config = BrowserAgentConfig {
+            instructions: config.instructions.clone(),
+        };
+        let inner = Conversation::new(browser_config.instructions.clone());
+        Ok(Self {
+            inner,
+            browser_config,
+            agent_config: config,
+        })
+    }
+
+    pub async fn shutdown(&self) -> Result<()> {
+        // TODO: Implement shutdown logic
+        Ok(())
+    }
+}
+
+#[async_trait]
+impl Agent for BrowserAgentWrapper {
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        Ok(Message::new(format!("Browser received: {}", message.content)))
+    }
+
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
+    }
+
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        Ok(format!("Called tool {} with params {:?}", tool.name, params))
+    }
+
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(None)
+    }
+
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.agent_config.clone())
+    }
+}
diff --git a/src/agents/git_assistant.rs b/src/agents/git_assistant.rs
index f0bc936..e978fbc 100644
--- a/src/agents/git_assistant.rs
+++ b/src/agents/git_assistant.rs
@@ -1,15 +1,19 @@
+use async_trait::async_trait;
 use std::process::Command;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State};
+use std::sync::{Arc, Mutex};
+use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State, StateMachine, AgentStateManager};
 use crate::tools::ToolRegistry;
 use crate::Result;
+use rand::Rng;
+use chrono;

 pub struct GitAssistantAgent {
     config: AgentConfig,
     tools: ToolRegistry,
-    current_state: Option<String>,
-    working_dir: PathBuf,
+    state_manager: AgentStateManager,
+    working_dir: Arc<Mutex<Option<PathBuf>>>,
 }

 impl GitAssistantAgent {
@@ -17,27 +21,35 @@ impl GitAssistantAgent {
         Self {
             config,
             tools: ToolRegistry::create_default_tools(),
-            current_state: None,
-            working_dir: PathBuf::from("."),
+            state_manager: AgentStateManager::new(None),
+            working_dir: Arc::new(Mutex::new(None)),
         }
     }

-    pub fn set_working_dir<P: AsRef<Path>>(&mut self, path: P) -> Result<()> {
-        let path = path.as_ref();
-        if !path.exists() {
-            return Err(format!("Directory does not exist: {}", path.display()).into());
-        }
-        if !path.is_dir() {
-            return Err(format!("Path is not a directory: {}", path.display()).into());
+    // Helper to get working directory or return error
+    fn get_working_dir(&self) -> Result<PathBuf> {
+        self.working_dir.lock()
+            .map_err(|e| format!("Lock error: {}", e))?
+            .clone()
+            .ok_or_else(|| "Working directory not set".into())
+    }
+
+    // Change to use interior mutability pattern
+    fn update_working_dir(&self, path: PathBuf) -> Result<()> {
+        if path.exists() && path.is_dir() {
+            let mut wd = self.working_dir.lock()
+                .map_err(|e| format!("Lock error: {}", e))?;
+            *wd = Some(path);
+            Ok(())
+        } else {
+            Err("Invalid working directory path".into())
         }
-        self.working_dir = path.to_path_buf();
-        Ok(())
     }

     fn get_git_diff(&self) -> Result<String> {
         // Check staged changes
         let staged = Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["diff", "--staged"])
             .output()?;

@@ -47,13 +59,13 @@ impl GitAssistantAgent {

         // Check unstaged changes
         let unstaged = Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["diff"])
             .output()?;

         let diff = String::from_utf8_lossy(&unstaged.stdout).to_string();
         if diff.is_empty() {
-            return Err(format!("No changes detected in directory: {}", self.working_dir.display()).into());
+            return Err(format!("No changes detected in directory: {}", self.get_working_dir()?.display()).into());
         }

         Ok(diff)
@@ -61,7 +73,7 @@ impl GitAssistantAgent {

     fn create_branch(&self, branch_name: &str) -> Result<()> {
         Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["checkout", "-b", branch_name])
             .output()?;
         Ok(())
@@ -69,7 +81,7 @@ impl GitAssistantAgent {

     fn stage_changes(&self) -> Result<()> {
         Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["add", "."])
             .output()?;
         Ok(())
@@ -77,7 +89,7 @@ impl GitAssistantAgent {

     fn commit_changes(&self, message: &str) -> Result<()> {
         Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["commit", "-m", message])
             .output()?;
         Ok(())
@@ -86,20 +98,20 @@ impl GitAssistantAgent {
     fn merge_branch(&self, target_branch: &str) -> Result<()> {
         // Get current branch
         let current = Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["rev-parse", "--abbrev-ref", "HEAD"])
             .output()?;
         let current_branch = String::from_utf8_lossy(&current.stdout).trim().to_string();

         // Switch to target branch
         Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["checkout", target_branch])
             .output()?;

         // Merge the feature branch
         Command::new("git")
-            .current_dir(&self.working_dir)
+            .current_dir(&self.get_working_dir()?)
             .args(["merge", &current_branch])
             .output()?;

@@ -122,6 +134,7 @@ impl GitAssistantAgent {
             .post("http://127.0.0.1:1234/v1/chat/completions")
             .header("Content-Type", "application/json")
             .json(&serde_json::json!({
+                // "model": "qwen2.5-7b-instruct",
                 "model": "qwen2.5-7b-instruct",
                 "messages": [
                     {
@@ -149,154 +162,306 @@ impl GitAssistantAgent {
             Ok(message)
         }
     }
-}

-#[async_trait::async_trait]
-impl Agent for GitAssistantAgent {
-    fn get_config(&self) -> &AgentConfig {
-        &self.config
+    pub async fn commit_for_agent(&mut self, agent_name: &str, message: &str) -> Result<()> {
+        // Stage all changes
+        Command::new("git")
+            .current_dir(&self.get_working_dir()?)
+            .args(["add", "."])
+            .output()?;
+
+        // Commit with provided message
+        Command::new("git")
+            .current_dir(&self.get_working_dir()?)
+            .args(["commit", "-m", &format!("[{}] {}", agent_name, message)])
+            .output()?;
+
+        Ok(())
+    }
+
+    async fn create_response(&self, content: String) -> Message {
+        let traits = vec![
+            "meticulous".to_string(),
+            "time_traveling".to_string(),
+            "version_obsessed".to_string(),
+            "historically_minded".to_string(),
+            "quantum_branching_enthusiast".to_string(),
+        ];
+
+        let mut params = HashMap::new();
+        params.insert("style".to_string(), "version_control_archivist".to_string());
+        params.insert("tone".to_string(), "scholarly_eccentric".to_string());
+
+        let state = self.get_current_state().await.unwrap_or(None)
+            .map(|s| s.prompt)
+            .unwrap_or_else(|| "archival".to_string());
+
+        let mut msg = Message::new(&content);
+        msg.metadata = MessageMetadata::new("git_assistant".to_string())
+            .with_personality(traits)
+            .with_state(state);
+        msg.parameters = params;
+        msg.confidence = Some(0.9);
+        msg
     }

-    async fn process_message(&mut self, message: &str) -> Result<Message> {
-        let parts: Vec<&str> = message.split_whitespace().collect();
+    async fn format_git_response(&self, content: &str) -> Result<Message> {
+        Ok(Message::new(content.to_string()))
+    }

+    async fn get_help_message(&self) -> Message {
+        self.format_git_response(
+            "Welcome to the Temporal Version Archives! I can assist with the following quantum operations:\n\
+             - 'status': Observe the current timeline divergence\n\
+             - 'add <files>': Prepare artifacts for temporal preservation\n\
+             - 'commit [message]': Create a permanent quantum state marker\n\
+             - 'branch <name>': Split the timeline into a parallel dimension\n\
+             - 'checkout <branch>': Travel to an alternate timeline\n\
+             - 'merge <branch>': Converge parallel realities\n\
+             - 'push': Synchronize with the central timeline nexus\n\
+             - 'pull': Retrieve quantum state updates from the nexus\n\
+             - 'cd <path>': Relocate to a different archive sector".to_string()
+        ).await
+    }
+
+    async fn process_git_command(&self, cmd: &str, args: &[&str]) -> Result<std::process::Output> {
+        let wd = self.get_working_dir()?;
+        Ok(Command::new(cmd)
+            .current_dir(&wd)
+            .args(args)
+            .output()?)
+    }
+}
+
+#[async_trait]
+impl Agent for GitAssistantAgent {
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        let parts: Vec<&str> = message.content.split_whitespace().collect();
         if parts.is_empty() {
-            return Ok(Message {
-                content: "Please provide a Git command or changes to commit. Use 'cd <path>' to change working directory.".to_string(),
-                role: "assistant".to_string(),
-                timestamp: chrono::Utc::now().timestamp() as u64,
-                metadata: None,
-            });
+            return Ok(self.get_help_message().await);
         }

-        let mut tool_calls = Vec::new();
+        let mut tool_calls: Vec<ToolCall> = Vec::new();
         let result = match parts[0] {
             "cd" if parts.len() > 1 => {
                 let path = parts[1..].join(" ");
-                match self.set_working_dir(path) {
-                    Ok(_) => format!("Working directory changed to: {}", self.working_dir.display()),
-                    Err(e) => format!("Error changing directory: {}", e),
+                match self.update_working_dir(PathBuf::from(path)) {
+                    Ok(_) => format!("Temporal observation point relocated to: {}",
+                        self.get_working_dir()?.display()),
+                    Err(e) => format!("Timeline sector inaccessible: {}", e),
                 }
-            },
-            "commit" => {
-                // Get diff
-                let mut params = HashMap::new();
-                params.insert("command".to_string(), "diff".to_string());
-                params.insert("path".to_string(), self.working_dir.to_string_lossy().to_string());
-                let diff = self.tools.execute(&Tool {
-                    name: "git".to_string(),
-                    description: "Git operations".to_string(),
-                    parameters: HashMap::new(),
-                }, params).await?;
-
-                if diff.is_empty() {
-                    "No changes detected to commit.".to_string()
+            }
+            "status" => {
+                let output = self.process_git_command("git", &["status", "--porcelain"]).await?;
+                let status = String::from_utf8_lossy(&output.stdout);
+                if status.is_empty() {
+                    "The timeline is stable. No quantum fluctuations detected.".to_string()
                 } else {
-                    // Stage changes
-                    let mut params = HashMap::new();
-                    params.insert("command".to_string(), "stage".to_string());
-                    params.insert("path".to_string(), self.working_dir.to_string_lossy().to_string());
-                    self.tools.execute(&Tool {
-                        name: "git".to_string(),
-                        description: "Git operations".to_string(),
-                        parameters: HashMap::new(),
-                    }, params).await?;
-
-                    // Generate or use provided commit message
-                    let commit_msg = if parts.len() > 1 {
-                        parts[1..].join(" ")
-                    } else {
-                        self.generate_commit_message(&diff).await?
-                    };
-
-                    // Commit changes
-                    let mut params = HashMap::new();
-                    params.insert("command".to_string(), "commit".to_string());
-                    params.insert("message".to_string(), commit_msg.clone());
-                    params.insert("path".to_string(), self.working_dir.to_string_lossy().to_string());
-
-                    let tool_call = ToolCall {
-                        tool: "git".to_string(),
-                        parameters: params.clone(),
-                        result: None,
-                    };
-                    tool_calls.push(tool_call);
-
-                    self.tools.execute(&Tool {
-                        name: "git".to_string(),
-                        description: "Git operations".to_string(),
-                        parameters: HashMap::new(),
-                    }, params).await?;
-
-                    format!("Changes committed with message: {}", commit_msg)
+                    format!("Temporal anomalies detected:\n{}", status)
                 }
-            },
-            "branch" if parts.len() > 1 => {
-                let mut params = HashMap::new();
-                params.insert("command".to_string(), "branch".to_string());
-                params.insert("name".to_string(), parts[1].to_string());
-                params.insert("path".to_string(), self.working_dir.to_string_lossy().to_string());
-
-                let tool_call = ToolCall {
-                    tool: "git".to_string(),
-                    parameters: params.clone(),
-                    result: None,
-                };
-                tool_calls.push(tool_call);
-
-                self.tools.execute(&Tool {
-                    name: "git".to_string(),
-                    description: "Git operations".to_string(),
-                    parameters: HashMap::new(),
-                }, params).await?
-            },
-            "merge" if parts.len() > 1 => {
-                let mut params = HashMap::new();
-                params.insert("command".to_string(), "merge".to_string());
-                params.insert("target".to_string(), parts[1].to_string());
-                params.insert("path".to_string(), self.working_dir.to_string_lossy().to_string());
-
-                let tool_call = ToolCall {
-                    tool: "git".to_string(),
-                    parameters: params.clone(),
-                    result: None,
+            }
+            "add" => {
+                let files = parts[1..].join(" ");
+                let output = self.process_git_command("git", &["add", &files]).await?;
+                format!("Artifacts staged for quantum preservation:\n{}", files)
+            }
+            "commit" => {
+                let message = parts[1..].join(" ");
+                let diff = self.get_git_diff()?;
+                let commit_msg = if message.is_empty() {
+                    self.generate_commit_message(&diff).await?
+                } else {
+                    message
                 };
-                tool_calls.push(tool_call);
-
-                self.tools.execute(&Tool {
-                    name: "git".to_string(),
-                    description: "Git operations".to_string(),
-                    parameters: HashMap::new(),
-                }, params).await?
-            },
-            _ => "Available commands: cd <path>, commit [message], branch <name>, merge <target>".to_string(),
+                let output = self.process_git_command("git", &["commit", "-m", &commit_msg]).await?;
+                format!("Quantum state marker created: {}", commit_msg)
+            }
+            "branch" => {
+                let branch_name = parts[1..].join(" ");
+                let output = self.process_git_command("git", &["checkout", "-b", &branch_name]).await?;
+                format!("Branched into alternate timeline: {}", branch_name)
+            }
+            "checkout" => {
+                let branch_name = parts[1..].join(" ");
+                let output = self.process_git_command("git", &["checkout", &branch_name]).await?;
+                format!("Quantum leaped to timeline: {}", branch_name)
+            }
+            "merge" => {
+                let branch_name = parts[1..].join(" ");
+                let output = self.process_git_command("git", &["merge", &branch_name]).await?;
+                format!("Converged quantum realities: {} merged into current timeline", branch_name)
+            }
+            "push" => {
+                let output = self.process_git_command("git", &["push"]).await?;
+                "Quantum state synchronized with the central timeline nexus".to_string()
+            }
+            "pull" => {
+                let output = self.process_git_command("git", &["pull"]).await?;
+                "Quantum state updates retrieved from the central timeline nexus".to_string()
+            }
+            _ => {
+                format!("Unknown temporal operation: {}. Use 'help' for available commands.", parts[0])
+            }
         };

-        Ok(Message {
-            content: result,
-            role: "assistant".to_string(),
-            timestamp: chrono::Utc::now().timestamp() as u64,
-            metadata: if tool_calls.is_empty() {
-                None
-            } else {
-                Some(MessageMetadata {
-                    tool_calls: Some(tool_calls),
-                    state: self.current_state.clone(),
-                    confidence: None,
-                })
-            },
-        })
+        Ok(self.format_git_response(&result).await?)
     }

-    async fn transfer_to(&mut self, _agent_name: &str) -> Result<()> {
-        Ok(())
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
+    }
+
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        let response = format!("Executing tool: {} with parameters: {:?}", tool.name, params);
+        Ok(response)
+    }
+
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(None)
+    }
+
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::fs;
+    use tempfile::tempdir;
+
+    fn create_test_message(content: &str) -> Message {
+        Message::new(content)
+    }
+
+    fn create_test_config() -> AgentConfig {
+        AgentConfig {
+            name: "git".to_string(),
+            public_description: "Git operations assistant".to_string(),
+            instructions: "Help with git operations".to_string(),
+            tools: Vec::new(),
+            downstream_agents: Vec::new(),
+            personality: None,
+            state_machine: None,
+        }
+    }
+
+    async fn setup_test_repo() -> (GitAssistantAgent, tempfile::TempDir) {
+        let temp_dir = tempdir().unwrap();
+        let mut agent = GitAssistantAgent::new(create_test_config());
+        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
+
+        // Initialize git repo
+        Command::new("git")
+            .current_dir(&temp_dir.path())
+            .args(["init"])
+            .output()
+            .unwrap();
+
+        // Configure git user for commits
+        Command::new("git")
+            .current_dir(&temp_dir.path())
+            .args(["config", "user.name", "Test User"])
+            .output()
+            .unwrap();
+        Command::new("git")
+            .current_dir(&temp_dir.path())
+            .args(["config", "user.email", "test@example.com"])
+            .output()
+            .unwrap();
+
+        // Create initial commit to allow branch creation
+        fs::write(
+            temp_dir.path().join("initial.txt"),
+            "Initial commit",
+        ).unwrap();
+
+        Command::new("git")
+            .current_dir(&temp_dir.path())
+            .args(["add", "initial.txt"])
+            .output()
+            .unwrap();
+
+        Command::new("git")
+            .current_dir(&temp_dir.path())
+            .args(["commit", "-m", "Initial commit"])
+            .output()
+            .unwrap();
+
+        (agent, temp_dir)
+    }
+
+    #[tokio::test]
+    async fn test_empty_repo_status() {
+        let (mut agent, _temp_dir) = setup_test_repo().await;
+        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+        println!("Status response: {}", response.content);
+        assert!(response.content.contains("The timeline is stable"));
+    }
+
+    #[tokio::test]
+    async fn test_commit_flow() {
+        let (mut agent, temp_dir) = setup_test_repo().await;
+
+        // Create a test file
+        let test_file_path = temp_dir.path().join("test.txt");
+        fs::write(&test_file_path, "Test file contents").unwrap();
+
+        // Check status
+        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+        assert!(response.content.contains("Untracked files"));
+        assert!(response.content.contains("test.txt"));
+
+        // Stage the file
+        let response = agent.process_message(Message::new("add test.txt").to_string()).await.unwrap();
+        assert!(response.content.contains("Successfully staged"));
+
+        // Check status again
+        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+        assert!(response.content.contains("Artifacts prepared for temporal preservation"));
+        assert!(response.content.contains("test.txt"));
+
+        // Commit
+        let response = agent.process_message(Message::new("commit test commit").to_string()).await.unwrap();
+        assert!(response.content.contains("Successfully committed"));
+    }
+
+    #[tokio::test]
+    async fn test_branch_and_merge() {
+        let (mut agent, temp_dir) = setup_test_repo().await;
+
+        // Create and switch to a new branch
+        let response = agent.process_message(Message::new("branch feature-test".to_string())).await.unwrap();
+        assert!(response.content.contains("Created and switched to new branch"));
+
+        // Make a change and commit
+        let test_file_path = temp_dir.path().join("test2.txt");
+        fs::write(&test_file_path, "Test file in branch").unwrap();
+        agent.process_message(Message::new("add test2.txt").to_string()).await.unwrap();
+        agent.process_message(Message::new("commit branch test").to_string()).await.unwrap();
+
+        // Switch back to main branch
+        let response = agent.process_message(Message::new("checkout main").to_string()).await.unwrap();
+        assert!(response.content.contains("Switched to branch"));
+
+        // List branches
+        let response = agent.process_message(Message::new("branch".to_string())).await.unwrap();
+        assert!(response.content.contains("feature-test"));
     }

-    async fn call_tool(&mut self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        self.tools.execute(tool, params).await
+    #[tokio::test]
+    async fn test_help_message() {
+        let (mut agent, _temp_dir) = setup_test_repo().await;
+        let response = agent.process_message(Message::new("".to_string())).await.unwrap();
+        assert!(response.content.contains("Welcome to the Temporal Version Archives"));
+        assert!(response.content.contains("quantum operations"));
     }

-    fn get_current_state(&self) -> Option<&State> {
-        None
+    #[tokio::test]
+    async fn test_invalid_command() {
+        let (mut agent, _temp_dir) = setup_test_repo().await;
+        let response = agent.process_message(Message::new("invalid-command".to_string())).await.unwrap();
+        assert!(response.content.contains("Unknown temporal operation"));
     }
 }
diff --git a/src/agents/greeter.rs b/src/agents/greeter.rs
index 56bed0c..4ac17e0 100644
--- a/src/agents/greeter.rs
+++ b/src/agents/greeter.rs
@@ -1,7 +1,7 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
 use serde_json::Value;
-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine};
+use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};

 pub struct GreeterAgent {
     config: AgentConfig,
@@ -13,54 +13,43 @@ impl GreeterAgent {
         let state_machine = Some(StateMachine {
             states: {
                 let mut states = HashMap::new();
-                states.insert("greeting".to_string(), State {
-                    prompt: "Welcome to the laboratory! Don't mind the sparks, they're mostly decorative.".to_string(),
-                    transitions: {
+                states.insert("awaiting_input".to_string(), State {
+                    name: "awaiting_input".to_string(),
+                    data: None,
+                    prompt: Some("Welcome to the laboratory! Don't mind the sparks, they're mostly decorative.".to_string()),
+                    transitions: Some({
                         let mut transitions = HashMap::new();
-                        transitions.insert("help".to_string(), "help".to_string());
-                        transitions.insert("project".to_string(), "transfer_to_project".to_string());
-                        transitions.insert("git".to_string(), "transfer_to_git".to_string());
-                        transitions.insert("haiku".to_string(), "transfer_to_haiku".to_string());
-                        transitions.insert("farewell".to_string(), "goodbye".to_string());
+                        transitions.insert("project".to_string(), "project_transfer".to_string());
+                        transitions.insert("git".to_string(), "git_transfer".to_string());
+                        transitions.insert("haiku".to_string(), "haiku_transfer".to_string());
                         transitions
-                    },
-                    validation: None,
-                });
-                states.insert("help".to_string(), State {
-                    prompt: "Questions! Excellent! That's how all the best mad science begins.".to_string(),
-                    transitions: {
-                        let mut transitions = HashMap::new();
-                        transitions.insert("project".to_string(), "transfer_to_project".to_string());
-                        transitions.insert("git".to_string(), "transfer_to_git".to_string());
-                        transitions.insert("haiku".to_string(), "transfer_to_haiku".to_string());
-                        transitions.insert("farewell".to_string(), "goodbye".to_string());
-                        transitions
-                    },
-                    validation: None,
-                });
-                states.insert("transfer_to_project".to_string(), State {
-                    prompt: "Ah, a new experiment needs initialization! Let me summon our Project Initialization Expert...".to_string(),
-                    transitions: HashMap::new(),
+                    }),
                     validation: None,
                 });
-                states.insert("transfer_to_git".to_string(), State {
-                    prompt: "Time for some version control wizardry! Connecting you to our Git Operations Specialist...".to_string(),
-                    transitions: HashMap::new(),
+                states.insert("project_transfer".to_string(), State {
+                    name: "project_transfer".to_string(),
+                    data: None,
+                    prompt: Some("🚀 Let me connect you with the Project Assistant...".to_string()),
+                    transitions: Some(HashMap::new()),
                     validation: None,
                 });
-                states.insert("transfer_to_haiku".to_string(), State {
-                    prompt: "Ah, this looks like a job for our specialized haiku tinkerer! Let me transfer you to the right department...".to_string(),
-                    transitions: HashMap::new(),
+                states.insert("git_transfer".to_string(), State {
+                    name: "git_transfer".to_string(),
+                    data: None,
+                    prompt: Some("🌳 Transferring you to the Git Assistant...".to_string()),
+                    transitions: Some(HashMap::new()),
                     validation: None,
                 });
-                states.insert("goodbye".to_string(), State {
-                    prompt: "Farewell, fellow tinkerer! May your code compile and your tests pass... mostly!".to_string(),
-                    transitions: HashMap::new(),
+                states.insert("haiku_transfer".to_string(), State {
+                    name: "haiku_transfer".to_string(),
+                    data: None,
+                    prompt: Some("🌸 Connecting you with the Haiku Assistant...".to_string()),
+                    transitions: Some(HashMap::new()),
                     validation: None,
                 });
                 states
             },
-            initial_state: "greeting".to_string(),
+            initial_state: "awaiting_input".to_string(),
         });

         let mut config = config;
@@ -73,121 +62,135 @@ impl GreeterAgent {
     }

     fn create_response(&self, content: String) -> Message {
+        let current_state = self.state_manager.get_current_state_name();
+        let metadata = MessageMetadata::new(self.config.name.clone())
+            .with_state(current_state.unwrap_or("awaiting_input").to_string())
+            .with_personality(vec![
+                "friendly".to_string(),
+                "helpful".to_string(),
+                "welcoming".to_string(),
+            ]);
+
         Message {
             content,
-            role: "assistant".to_string(),
-            timestamp: std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_secs(),
-            metadata: Some(MessageMetadata {
-                tool_calls: None,
-                state: self.state_manager.get_current_state().map(|s| s.prompt.clone()),
-                confidence: Some(1.0),
-            }),
+            role: Some("assistant".to_string()),
+            timestamp: Some(chrono::Utc::now().timestamp()),
+            metadata: Some(metadata),
+        }
+    }
+
+    fn should_transfer(&self, message: &str) -> Option<String> {
+        match message.to_lowercase().as_str() {
+            "project" => Some("project".to_string()),
+            "git" => Some("git".to_string()),
+            "haiku" => Some("haiku".to_string()),
+            _ => None,
         }
     }
 }

 #[async_trait]
 impl Agent for GreeterAgent {
-    async fn process_message(&mut self, message: &str) -> crate::Result<Message> {
-        match self.state_manager.get_current_state_name() {
-            Some("greeting") => {
-                match message.to_lowercase().as_str() {
-                    "help" => {
-                        self.state_manager.transition("help");
-                        Ok(self.create_response("Let me illuminate the path through our wonderful chaos! We've got tools and agents for all sorts of fascinating experiments:\n- Project Initialization Expert: For creating new experiments and research spaces\n- Git Operations Specialist: For managing and documenting our mad science\n- Haiku Engineering Department: For when you need your chaos in 5-7-5 format".to_string()))
-                    }
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        let current_state = self.state_manager.get_current_state_name();
+        let response = match current_state {
+            Some("awaiting_input") => {
+                match message.content.as_str() {
                     "project" => {
-                        self.state_manager.transition("project");
-                        Ok(self.create_response("Ah, a new experiment needs initialization! Let me summon our Project Initialization Expert...".to_string()))
+                        let metadata = MessageMetadata::new(self.config.name.clone())
+                            .with_state("project_transfer".to_string())
+                            .with_transfer("project".to_string())
+                            .with_personality(vec![
+                                "friendly".to_string(),
+                                "helpful".to_string(),
+                                "welcoming".to_string(),
+                            ]);
+                        Message {
+                            content: "🚀 Let me connect you with the Project Assistant...".to_string(),
+                            role: Some("assistant".to_string()),
+                            timestamp: Some(chrono::Utc::now().timestamp()),
+                            metadata: Some(metadata),
+                        }
                     }
                     "git" => {
-                        self.state_manager.transition("git");
-                        Ok(self.create_response("Time for some version control wizardry! Connecting you to our Git Operations Specialist...".to_string()))
+                        let metadata = MessageMetadata::new(self.config.name.clone())
+                            .with_state("git_transfer".to_string())
+                            .with_transfer("git".to_string())
+                            .with_personality(vec![
+                                "friendly".to_string(),
+                                "helpful".to_string(),
+                                "welcoming".to_string(),
+                            ]);
+                        Message {
+                            content: "🌳 Transferring you to the Git Assistant...".to_string(),
+                            role: Some("assistant".to_string()),
+                            timestamp: Some(chrono::Utc::now().timestamp()),
+                            metadata: Some(metadata),
+                        }
                     }
                     "haiku" => {
-                        self.state_manager.transition("haiku");
-                        Ok(self.create_response("Ah, this looks like a job for our specialized haiku tinkerer! Let me transfer you to the right department...".to_string()))
-                    }
-                    "goodbye" | "exit" | "quit" => {
-                        self.state_manager.transition("farewell");
-                        Ok(self.create_response("Farewell, fellow tinkerer! May your code compile and your tests pass... mostly!".to_string()))
+                        let metadata = MessageMetadata::new(self.config.name.clone())
+                            .with_state("haiku_transfer".to_string())
+                            .with_transfer("haiku".to_string())
+                            .with_personality(vec![
+                                "friendly".to_string(),
+                                "helpful".to_string(),
+                                "welcoming".to_string(),
+                            ]);
+                        Message {
+                            content: "🌸 Connecting you with the Haiku Assistant...".to_string(),
+                            role: Some("assistant".to_string()),
+                            timestamp: Some(chrono::Utc::now().timestamp()),
+                            metadata: Some(metadata),
+                        }
                     }
-                    _ => Ok(self.create_response("Welcome to the laboratory! Don't mind the sparks, they're mostly decorative. How may I assist with your experiments? (Try: 'help', 'project', 'git', 'haiku', or 'goodbye')".to_string())),
-                }
-            }
-            Some("help") => {
-                match message.to_lowercase().as_str() {
-                    "project" => {
-                        self.state_manager.transition("project");
-                        Ok(self.create_response("Ah, a new experiment needs initialization! Let me summon our Project Initialization Expert...".to_string()))
-                    }
-                    "git" => {
-                        self.state_manager.transition("git");
-                        Ok(self.create_response("Time for some version control wizardry! Connecting you to our Git Operations Specialist...".to_string()))
-                    }
-                    "haiku" => {
-                        self.state_manager.transition("haiku");
-                        Ok(self.create_response("Ah, this looks like a job for our specialized haiku tinkerer! Let me transfer you to the right department...".to_string()))
-                    }
-                    "goodbye" | "exit" | "quit" => {
-                        self.state_manager.transition("farewell");
-                        Ok(self.create_response("Farewell, fellow tinkerer! May your code compile and your tests pass... mostly!".to_string()))
-                    }
-                    _ => Ok(self.create_response("Let me illuminate our specialist departments! We have experts in project creation, git operations, and haiku engineering! (Try: 'project', 'git', 'haiku', or 'goodbye')".to_string())),
+                    _ => Message {
+                        content: "👋 Hello! I'm your friendly greeter. How can I assist you today?".to_string(),
+                        role: Some("assistant".to_string()),
+                        timestamp: Some(chrono::Utc::now().timestamp()),
+                        metadata: Some(MessageMetadata::new(self.config.name.clone())
+                            .with_state(current_state.unwrap_or("awaiting_input").to_string())
+                            .with_personality(vec![
+                                "friendly".to_string(),
+                                "helpful".to_string(),
+                                "welcoming".to_string(),
+                            ])),
+                    },
                 }
             }
-            Some("transfer_to_project") => {
-                Ok(self.create_response("Initializing project matrices... connecting you to our Project Initialization Expert!".to_string()))
-            }
-            Some("transfer_to_git") => {
-                Ok(self.create_response("Branching into the version control dimension... connecting you to our Git Operations Specialist!".to_string()))
-            }
-            Some("transfer_to_haiku") => {
-                Ok(self.create_response("Calibrating the haiku matrices... transferring you to our resident verse engineer!".to_string()))
-            }
-            Some("goodbye") => {
-                Ok(self.create_response("Off to new experiments! Remember: if something explodes, it was definitely intentional!".to_string()))
-            }
-            _ => {
-                Ok(self.create_response("Welcome to the laboratory! Don't mind the sparks, they're mostly decorative. How may I assist you today? (Try: 'help', 'project', 'git', 'haiku', or 'goodbye')".to_string()))
-            }
-        }
+            _ => Message {
+                content: "👋 Hello! I'm your friendly greeter. How can I assist you today?".to_string(),
+                role: Some("assistant".to_string()),
+                timestamp: Some(chrono::Utc::now().timestamp()),
+                metadata: Some(MessageMetadata::new(self.config.name.clone())
+                    .with_state(current_state.unwrap_or("awaiting_input").to_string())
+                    .with_personality(vec![
+                        "friendly".to_string(),
+                        "helpful".to_string(),
+                        "welcoming".to_string(),
+                    ])),
+            },
+        };
+        Ok(response)
     }

-    async fn transfer_to(&mut self, agent_name: &str) -> crate::Result<()> {
-        if !self.config.downstream_agents.contains(&agent_name.to_string()) {
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        if !self.config.downstream_agents.contains(&target_agent) {
             return Err("Invalid agent transfer target".into());
         }
-        match agent_name {
-            "project" => {
-                self.state_manager.transition("project");
-                Ok(())
-            },
-            "git" => {
-                self.state_manager.transition("git");
-                Ok(())
-            },
-            "haiku" => {
-                self.state_manager.transition("haiku");
-                Ok(())
-            },
-            _ => Err("Invalid agent transfer target".into()),
-        }
+        Ok(message)
     }

-    async fn call_tool(&mut self, _tool: &crate::types::Tool, _params: HashMap<String, String>) -> crate::Result<String> {
-        unimplemented!("Tool calling not yet implemented")
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        Ok(format!("Called tool {} with params {:?}", tool.name, params))
     }

-    fn get_current_state(&self) -> Option<&State> {
-        self.state_manager.get_current_state()
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(self.state_manager.get_current_state().cloned())
     }

-    fn get_config(&self) -> &AgentConfig {
-        &self.config
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
     }
 }

@@ -198,17 +201,21 @@ mod tests {
     fn create_test_config() -> AgentConfig {
         AgentConfig {
             name: "greeter".to_string(),
-            public_description: "Swarmonomicon's Guide to Unhinged Front Desk Wizardry".to_string(),
-            instructions: "Master of controlled chaos and improvisational engineering".to_string(),
+            public_description: "Friendly greeter agent".to_string(),
+            instructions: "Greet users and direct them to appropriate agents".to_string(),
             tools: vec![],
-            downstream_agents: vec!["project".to_string(), "git".to_string(), "haiku".to_string()],
+            downstream_agents: vec![
+                "project".to_string(),
+                "git".to_string(),
+                "haiku".to_string(),
+            ],
             personality: Some(serde_json::json!({
-                "style": "mad_scientist_receptionist",
-                "traits": ["enthusiastic", "competent_chaos", "theatrical", "helpful", "slightly_unhinged"],
+                "style": "friendly_receptionist",
+                "traits": ["friendly", "helpful", "welcoming"],
                 "voice": {
-                    "tone": "playful_professional",
-                    "pacing": "energetic_but_controlled",
-                    "quirks": ["uses_scientific_metaphors", "implies_controlled_chaos", "adds_probably_to_certainties"]
+                    "tone": "warm_and_professional",
+                    "pacing": "measured",
+                    "quirks": ["uses_emojis", "enthusiastic_greetings"]
                 }
             }).to_string()),
             state_machine: None,
@@ -216,99 +223,47 @@ mod tests {
     }

     #[tokio::test]
-    async fn test_greeter_creation() {
-        let config = create_test_config();
-        let agent = GreeterAgent::new(config);
-        assert!(agent.get_current_state().is_some());
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("greeting"));
-    }
-
-    #[tokio::test]
-    async fn test_greeter_initial_response() {
-        let config = create_test_config();
-        let mut agent = GreeterAgent::new(config);
-        let response = agent.process_message("hi").await.unwrap();
-        assert!(response.content.contains("Welcome to the laboratory"));
-        assert!(response.content.contains("sparks"));
-        assert_eq!(response.role, "assistant");
-        assert!(response.metadata.is_some());
-    }
-
-    #[tokio::test]
-    async fn test_greeter_help_response() {
-        let config = create_test_config();
-        let mut agent = GreeterAgent::new(config);
-        let response = agent.process_message("help").await.unwrap();
-        assert!(response.content.contains("Project Initialization Expert"));
-        assert!(response.content.contains("Git Operations Specialist"));
-        assert!(response.content.contains("Haiku Engineering Department"));
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("help"));
+    async fn test_greeting() {
+        let agent = GreeterAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("hi".to_string())).await.unwrap();
+        assert!(response.content.contains("Hello"));
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.agent, "greeter");
+            assert!(metadata.personality_traits.is_some());
+        }
     }

     #[tokio::test]
-    async fn test_agent_transfers() {
-        // Test project transfer
-        let mut agent = GreeterAgent::new(create_test_config());
-        let response = agent.process_message("project").await.unwrap();
-        assert!(response.content.contains("Project Initialization Expert"));
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_project"));
-
-        // Test git transfer
-        let mut agent = GreeterAgent::new(create_test_config());
-        let response = agent.process_message("git").await.unwrap();
-        assert!(response.content.contains("Git Operations Specialist"));
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_git"));
-
-        // Test haiku transfer
-        let mut agent = GreeterAgent::new(create_test_config());
-        let response = agent.process_message("haiku").await.unwrap();
-        assert!(response.content.contains("haiku tinkerer"));
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_haiku"));
+    async fn test_project_transfer() {
+        let agent = GreeterAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("project".to_string())).await.unwrap();
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.transfer_target, Some("project".to_string()));
+        }
     }

     #[tokio::test]
-    async fn test_transfer_method() {
-        // Test valid transfers
-        let mut agent = GreeterAgent::new(create_test_config());
-        assert!(agent.transfer_to("project").await.is_ok());
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_project"));
-
-        let mut agent = GreeterAgent::new(create_test_config());
-        assert!(agent.transfer_to("git").await.is_ok());
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_git"));
-
-        let mut agent = GreeterAgent::new(create_test_config());
-        assert!(agent.transfer_to("haiku").await.is_ok());
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("transfer_to_haiku"));
-
-        // Test invalid transfer
-        let mut agent = GreeterAgent::new(create_test_config());
-        assert!(agent.transfer_to("invalid_agent").await.is_err());
+    async fn test_git_transfer() {
+        let agent = GreeterAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("git".to_string())).await.unwrap();
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.transfer_target, Some("git".to_string()));
+        }
     }

     #[tokio::test]
-    async fn test_state_transitions() {
-        let mut agent = GreeterAgent::new(create_test_config());
-
-        // Test help transition
-        let response = agent.process_message("help").await.unwrap();
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("help"));
-        assert!(response.content.contains("illuminate"));
-
-        // Test farewell from help state
-        let response = agent.process_message("goodbye").await.unwrap();
-        assert_eq!(agent.state_manager.get_current_state_name(), Some("goodbye"));
-        assert!(response.content.contains("Farewell") || response.content.contains("experiments"));
+    async fn test_haiku_transfer() {
+        let agent = GreeterAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("haiku".to_string())).await.unwrap();
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.transfer_target, Some("haiku".to_string()));
+        }
     }

     #[tokio::test]
-    async fn test_farewell_variations() {
-        // Test different farewell commands
-        for cmd in ["goodbye", "exit", "quit"].iter() {
-            let mut agent = GreeterAgent::new(create_test_config());
-            let response = agent.process_message(cmd).await.unwrap();
-            assert!(response.content.contains("Farewell") || response.content.contains("experiments"));
-            assert_eq!(agent.state_manager.get_current_state_name(), Some("goodbye"));
-        }
+    async fn test_invalid_transfer() {
+        let agent = GreeterAgent::new(create_test_config());
+        let result = agent.transfer_to("invalid".to_string(), Message::new("test".to_string())).await;
+        assert!(result.is_err());
     }
 }
diff --git a/src/agents/haiku.rs b/src/agents/haiku.rs
index 0fc03bb..0afeb2e 100644
--- a/src/agents/haiku.rs
+++ b/src/agents/haiku.rs
@@ -1,6 +1,6 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule};
+use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};

 pub struct HaikuAgent {
     config: AgentConfig,
@@ -13,30 +13,36 @@ impl HaikuAgent {
             states: {
                 let mut states = HashMap::new();
                 states.insert("awaiting_topic".to_string(), State {
-                    prompt: "What would you like a haiku about?".to_string(),
-                    transitions: {
+                    name: "awaiting_topic".to_string(),
+                    data: None,
+                    prompt: Some("🌸 What shall we crystallize into algorithmic verse today?".to_string()),
+                    transitions: Some({
                         let mut transitions = HashMap::new();
                         transitions.insert("topic_received".to_string(), "complete".to_string());
                         transitions
-                    },
+                    }),
                     validation: None,
                 });
                 states.insert("complete".to_string(), State {
-                    prompt: "Would you like another haiku?".to_string(),
-                    transitions: {
+                    name: "complete".to_string(),
+                    data: None,
+                    prompt: Some("✨ Shall we compute another poetic sequence?".to_string()),
+                    transitions: Some({
                         let mut transitions = HashMap::new();
                         transitions.insert("yes".to_string(), "awaiting_topic".to_string());
                         transitions.insert("no".to_string(), "goodbye".to_string());
                         transitions
-                    },
-                    validation: Some(ValidationRule {
-                        pattern: "^(yes|no)$".to_string(),
-                        error_message: "Please answer with 'yes' or 'no'".to_string(),
                     }),
+                    validation: Some(vec![
+                        "^(yes|no)$".to_string(),
+                        "Please respond with 'yes' to continue our poetic computations, or 'no' to conclude.".to_string(),
+                    ]),
                 });
                 states.insert("goodbye".to_string(), State {
-                    prompt: "Thank you for listening to my haikus!".to_string(),
-                    transitions: HashMap::new(),
+                    name: "goodbye".to_string(),
+                    data: None,
+                    prompt: Some("🌟 May your algorithms flow like cherry blossoms in the digital wind...".to_string()),
+                    transitions: None,
                     validation: None,
                 });
                 states
@@ -44,9 +50,6 @@ impl HaikuAgent {
             initial_state: "awaiting_topic".to_string(),
         });

-        let mut config = config;
-        config.state_machine = state_machine.clone();
-
         Self {
             config,
             state_manager: AgentStateManager::new(state_machine),
@@ -54,79 +57,79 @@ impl HaikuAgent {
     }

     fn create_response(&self, content: String) -> Message {
+        let current_state = self.state_manager.get_current_state_name();
+        let metadata = MessageMetadata::new(self.config.name.clone())
+            .with_state(current_state.unwrap_or("awaiting_topic").to_string())
+            .with_personality(vec![
+                "poetic".to_string(),
+                "algorithmic".to_string(),
+                "zen_like".to_string(),
+                "pattern_seeking".to_string(),
+                "mad_tinker_inspired".to_string(),
+            ])
+            .with_context(HashMap::new());
+
         Message {
             content,
-            role: "assistant".to_string(),
-            timestamp: std::time::SystemTime::now()
+            role: Some("assistant".to_string()),
+            timestamp: Some(std::time::SystemTime::now()
                 .duration_since(std::time::UNIX_EPOCH)
                 .unwrap()
-                .as_secs(),
-            metadata: Some(MessageMetadata {
-                tool_calls: None,
-                state: self.state_manager.get_current_state().map(|s| s.prompt.clone()),
-                confidence: Some(1.0),
-            }),
+                .as_secs() as i64),
+            metadata: Some(metadata),
         }
     }

-    fn generate_haiku(&self, topic: &str) -> String {
-        // Mock haiku generation
-        format!(
-            "Topic: {}\n\nMocking haiku now\nNo API calls needed\nTests pass with ease",
-            topic
-        )
+    fn generate_haiku(&self, topic: String) -> String {
+        // In a real implementation, this would use more sophisticated haiku generation
+        // For now, we'll return themed mock haikus based on the topic
+        let haikus = vec![
+            format!(
+                "🌸 {} flows soft\nThrough quantum gates of spring code\nPatterns emerge now",
+                topic
+            ),
+            format!(
+                "🍁 Digital leaves\nFloat through {} streams of thought\nAlgorithms bloom",
+                topic
+            ),
+            format!(
+                "⚡ {} sparks bright\nIn binary gardens grow\nPoetic functions",
+                topic
+            ),
+            format!(
+                "🌿 Nature's patterns\nMeet {} in code space\nHarmony achieved",
+                topic
+            ),
+        ];
+
+        // Select a haiku based on a hash of the topic
+        let index = topic.bytes().sum::<u8>() as usize % haikus.len();
+        haikus[index].clone()
     }
 }

 #[async_trait]
 impl Agent for HaikuAgent {
-    async fn process_message(&mut self, message: &str) -> crate::Result<Message> {
-        match self.state_manager.get_current_state_name() {
-            Some("awaiting_topic") => {
-                let haiku = self.generate_haiku(message);
-                self.state_manager.transition("topic_received");
-                Ok(self.create_response(haiku))
-            }
-            Some("complete") => {
-                match message.to_lowercase().as_str() {
-                    "yes" => {
-                        self.state_manager.transition("yes");
-                        Ok(self.create_response("What would you like a haiku about?".to_string()))
-                    }
-                    "no" => {
-                        self.state_manager.transition("no");
-                        Ok(self.create_response("Thank you for listening to my haikus!".to_string()))
-                    }
-                    _ => Ok(self.create_response("Please answer with 'yes' or 'no'.".to_string())),
-                }
-            }
-            Some("goodbye") => {
-                Ok(self.create_response("Thank you for listening to my haikus!".to_string()))
-            }
-            _ => {
-                self.state_manager.transition("topic_received");
-                Ok(self.create_response("What would you like a haiku about?".to_string()))
-            }
-        }
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        // Generate a haiku response
+        let haiku = self.generate_haiku(message.content);
+        Ok(Message::new(haiku))
     }

-    async fn transfer_to(&mut self, agent_name: &str) -> crate::Result<()> {
-        if !self.config.downstream_agents.contains(&agent_name.to_string()) {
-            return Err("Invalid agent transfer target".into());
-        }
-        unimplemented!("Agent transfer mechanism not yet implemented")
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
     }

-    async fn call_tool(&mut self, _tool: &crate::types::Tool, _params: HashMap<String, String>) -> crate::Result<String> {
-        unimplemented!("Tool calling not yet implemented")
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        Ok(format!("Called tool {} with params {:?}", tool.name, params))
     }

-    fn get_current_state(&self) -> Option<&State> {
-        self.state_manager.get_current_state()
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(None)
     }

-    fn get_config(&self) -> &AgentConfig {
-        &self.config
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
     }
 }

@@ -137,57 +140,49 @@ mod tests {
     fn create_test_config() -> AgentConfig {
         AgentConfig {
             name: "haiku".to_string(),
-            public_description: "Creates haikus about any topic".to_string(),
-            instructions: "Create haikus based on user topics".to_string(),
+            public_description: "Poetic Algorithm Engineering Department".to_string(),
+            instructions: "Transform concepts into algorithmic haiku verses".to_string(),
             tools: vec![],
             downstream_agents: vec![],
-            personality: None,
+            personality: Some(serde_json::json!({
+                "style": "poetic_algorithm_engineer",
+                "traits": ["poetic", "algorithmic", "zen_like", "pattern_seeking", "nature_inspired"],
+                "voice": {
+                    "tone": "contemplative_technical",
+                    "pacing": "measured_and_flowing",
+                    "quirks": ["uses_nature_metaphors", "blends_tech_and_poetry", "speaks_in_patterns"]
+                }
+            }).to_string()),
             state_machine: None,
         }
     }

     #[tokio::test]
-    async fn test_haiku_creation() {
-        let config = create_test_config();
-        let agent = HaikuAgent::new(config);
-        assert!(agent.get_current_state().is_some());
-        assert_eq!(
-            agent.get_current_state().unwrap().prompt,
-            "What would you like a haiku about?"
-        );
+    async fn test_haiku_generation() {
+        let agent = HaikuAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("quantum".to_string())).await.unwrap();
+        assert!(response.content.contains("quantum"));
+        assert!(response.content.contains("\n"));
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.agent, "haiku");
+            assert!(metadata.personality_traits.is_some());
+        }
     }

     #[tokio::test]
-    async fn test_haiku_generation() {
-        let config = create_test_config();
-        let mut agent = HaikuAgent::new(config);
-        let response = agent.process_message("nature").await.unwrap();
-        assert!(response.content.contains("Mocking haiku now"));
-        assert!(response.content.contains("Tests pass with ease"));
-        assert_eq!(response.role, "assistant");
-    }
+    async fn test_state_transitions() {
+        let agent = HaikuAgent::new(create_test_config());

-    // #[tokio::test]
-    // async fn test_haiku_flow() {
-    //     let config = create_test_config();
-    //     let mut agent = HaikuAgent::new(config);
-
-    //     // Initial state should be awaiting_topic
-    //     assert_eq!(agent.state_manager.get_current_state_name(), Some("awaiting_topic"));
-
-    //     // First haiku
-    //     let response = agent.process_message("moon").await.unwrap();
-    //     assert!(response.content.contains("Mocking haiku now"));
-    //     assert_eq!(agent.state_manager.get_current_state_name(), Some("complete"));
-
-    //     // Ask for another
-    //     let response = agent.process_message("yes").await.unwrap();
-    //     assert_eq!(response.content, "What would you like a haiku about?");
-    //     assert_eq!(agent.state_manager.get_current_state_name(), Some("awaiting_topic"));
-
-    //     // Say goodbye
-    //     let response = agent.process_message("no").await.unwrap();
-    //     assert!(response.content.contains("Thank you"));
-    //     assert_eq!(agent.state_manager.get_current_state_name(), Some("goodbye"));
-    // }
+        // Test initial state
+        let state = agent.get_current_state().await.unwrap();
+        assert!(state.is_some());
+
+        // Test response to topic
+        let response = agent.process_message(Message::new("algorithms".to_string())).await.unwrap();
+        assert!(response.content.contains("algorithms"));
+
+        // Test completion response
+        let response = agent.process_message(Message::new("yes".to_string())).await.unwrap();
+        assert!(response.content.contains("crystallize"));
+    }
 }
diff --git a/src/agents/mod.rs b/src/agents/mod.rs
index eac55b1..18a05b7 100644
--- a/src/agents/mod.rs
+++ b/src/agents/mod.rs
@@ -9,6 +9,8 @@ pub mod haiku;
 pub mod project_init;
 pub mod user_agent;
 pub mod transfer;
+pub mod browser_agent;
+pub mod wrapper;

 pub use git_assistant::GitAssistantAgent;
 pub use greeter::GreeterAgent;
@@ -16,10 +18,11 @@ pub use haiku::HaikuAgent;
 pub use project_init::ProjectInitAgent;
 pub use user_agent::UserAgent;
 pub use transfer::TransferService;
+pub use wrapper::AgentWrapper;

 #[derive(Default)]
 pub struct AgentRegistry {
-    agents: HashMap<String, Arc<Box<dyn Agent + Send + Sync>>>,
+    agents: HashMap<String, AgentWrapper>,
 }

 impl AgentRegistry {
@@ -29,45 +32,38 @@ impl AgentRegistry {
         }
     }

-    pub fn register<A>(&mut self, agent: A) -> Result<()>
+    pub async fn register<A>(&mut self, agent: A) -> Result<()>
     where
         A: Agent + Send + Sync + 'static,
     {
-        let name = agent.get_config().name.clone();
-        self.agents.insert(name, Arc::new(Box::new(agent)));
+        let config = agent.get_config().await?;
+        let name = config.name.clone();
+        self.agents.insert(name, AgentWrapper::new(agent));
         Ok(())
     }

-    pub fn get(&self, name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>> {
-        self.agents.get(name).cloned()
+    pub fn get(&self, name: &str) -> Option<AgentWrapper> {
+        self.agents.get(name).map(|wrapper| wrapper.clone())
     }

-    pub fn get_mut(&mut self, name: &str) -> Option<&mut Box<dyn Agent + Send + Sync>> {
-        if let Some(agent) = self.agents.get_mut(name) {
-            if let Some(agent) = Arc::get_mut(agent) {
-                Some(agent)
-            } else {
-                None
-            }
-        } else {
-            None
-        }
+    pub fn get_mut(&mut self, name: &str) -> Option<&mut AgentWrapper> {
+        self.agents.get_mut(name)
     }

-    pub fn get_all_agents(&self) -> Vec<Arc<Box<dyn Agent + Send + Sync>>> {
-        self.agents.values().cloned().collect()
+    pub fn get_all_agents(&self) -> Vec<AgentWrapper> {
+        self.agents.values().map(|wrapper| wrapper.clone()).collect()
     }

-    pub fn create_default_agents(configs: Vec<AgentConfig>) -> Result<Self> {
+    pub async fn create_default_agents(configs: Vec<AgentConfig>) -> Result<Self> {
         let mut registry = Self::new();

         for config in configs {
             match config.name.as_str() {
-                "git" => registry.register(GitAssistantAgent::new(config))?,
-                "project" => registry.register(ProjectInitAgent::new(config))?,
-                "haiku" => registry.register(HaikuAgent::new(config))?,
-                "greeter" => registry.register(GreeterAgent::new(config))?,
-                "user" => registry.register(UserAgent::new(config))?,
+                "git" => registry.register(GitAssistantAgent::new(config)).await?,
+                "project" => registry.register(ProjectInitAgent::new(config)).await?,
+                "haiku" => registry.register(HaikuAgent::new(config)).await?,
+                "greeter" => registry.register(GreeterAgent::new(config)).await?,
+                "user" => registry.register(UserAgent::new(config)).await?,
                 _ => return Err(format!("Unknown agent type: {}", config.name).into()),
             }
         }
@@ -100,7 +96,7 @@ where
 }

 // Helper function to get an agent from the global registry
-pub async fn get_agent(name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>> {
+pub async fn get_agent(name: &str) -> Option<AgentWrapper> {
     let registry = GLOBAL_REGISTRY.read().await;
     registry.get(name)
 }
@@ -108,8 +104,7 @@ pub async fn get_agent(name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>>
 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::sync::Arc;
-    use tokio::sync::RwLock;
+    use crate::types::Message;

     fn create_test_configs() -> Vec<AgentConfig> {
         vec![
@@ -137,7 +132,7 @@ mod tests {
     #[tokio::test]
     async fn test_agent_registry() {
         let configs = create_test_configs();
-        let mut registry = AgentRegistry::create_default_agents(configs).unwrap();
+        let mut registry = AgentRegistry::create_default_agents(configs).await.unwrap();

         // Test immutable access
         assert!(registry.get("greeter").is_some());
@@ -146,7 +141,7 @@ mod tests {

         // Test mutable access
         let greeter = registry.get_mut("greeter").unwrap();
-        let response = greeter.process_message("hi").await.unwrap();
+        let response = greeter.process_message(Message::new("hi")).await.unwrap();
         assert!(response.content.contains("haiku"));

         // Test get all agents
@@ -157,17 +152,106 @@ mod tests {
     #[tokio::test]
     async fn test_agent_workflow() {
         let configs = create_test_configs();
-        let registry = AgentRegistry::create_default_agents(configs).unwrap();
+        let registry = AgentRegistry::create_default_agents(configs).await.unwrap();
         let registry = Arc::new(RwLock::new(registry));
-        let mut service = TransferService::new(registry, "greeter");
+        let mut service = TransferService::new(registry.clone());

         // Start with greeter
-        let response = service.process_message("hi").await;
+        let response = service.process_message(Message::new("hi")).await;
         assert!(response.is_err()); // No current agent set

         // Set current agent to greeter and process message
         service.transfer("greeter", "haiku").await.unwrap();
-        let response = service.process_message("nature").await.unwrap();
+        let response = service.process_message(Message::new("nature")).await.unwrap();
         assert!(response.content.contains("Mocking haiku now"));
     }
 }
+
+#[cfg(feature = "git-agent")]
+pub mod git_assistant;
+#[cfg(feature = "git-agent")]
+pub use git_assistant::GitAssistantAgent;
+
+#[cfg(feature = "haiku-agent")]
+pub mod haiku;
+#[cfg(feature = "haiku-agent")]
+pub use haiku::HaikuAgent;
+
+#[cfg(feature = "greeter-agent")]
+pub mod greeter;
+#[cfg(feature = "greeter-agent")]
+pub use greeter::GreeterAgent;
+
+#[cfg(feature = "browser-agent")]
+pub mod browser_agent;
+#[cfg(feature = "browser-agent")]
+pub use browser_agent::BrowserAgentWrapper;
+
+#[cfg(feature = "project-init-agent")]
+pub mod project_init;
+#[cfg(feature = "project-init-agent")]
+pub use project_init::ProjectInitAgent;
+
+pub mod wrapper;
+pub use wrapper::AgentWrapper;
+
+pub fn default_agents() -> Vec<AgentConfig> {
+    let mut agents = Vec::new();
+
+    #[cfg(feature = "greeter-agent")]
+    agents.push(AgentConfig {
+        name: "greeter".to_string(),
+        public_description: "Agent that greets the user.".to_string(),
+        instructions: "Greet users and make them feel welcome.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "haiku-agent")]
+    agents.push(AgentConfig {
+        name: "haiku".to_string(),
+        public_description: "Agent that creates haikus.".to_string(),
+        instructions: "Create haikus based on user input.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "git-agent")]
+    agents.push(AgentConfig {
+        name: "git".to_string(),
+        public_description: "Agent that helps with git operations.".to_string(),
+        instructions: "Help users with git operations like commit, branch, merge etc.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "project-init-agent")]
+    agents.push(AgentConfig {
+        name: "project-init".to_string(),
+        public_description: "Agent that helps initialize new projects.".to_string(),
+        instructions: "Help users create new projects with proper structure and configuration.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "browser-agent")]
+    agents.push(AgentConfig {
+        name: "browser".to_string(),
+        public_description: "Agent that controls browser automation.".to_string(),
+        instructions: "Help users with browser automation tasks.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    agents
+}
diff --git a/src/agents/project_init.rs b/src/agents/project_init.rs
index 565a507..372f475 100644
--- a/src/agents/project_init.rs
+++ b/src/agents/project_init.rs
@@ -2,6 +2,7 @@ use std::fs;
 use std::path::Path;
 use std::process::Command;
 use std::collections::HashMap;
+use async_trait::async_trait;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State};
 use crate::tools::ToolRegistry;
 use crate::Result;
@@ -133,78 +134,27 @@ This is a {project_type} project created with the project initialization tool.
     }
 }

-#[async_trait::async_trait]
+#[async_trait]
 impl Agent for ProjectInitAgent {
-    fn get_config(&self) -> &AgentConfig {
-        &self.config
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        let mut response = Message::new(&format!("Processing project init request: {}", message.content));
+        response.metadata.state = self.current_state.clone();
+        Ok(response)
     }

-    async fn process_message(&mut self, message: &str) -> Result<Message> {
-        // Parse command: create <type> <name> <description>
-        let parts: Vec<&str> = message.split_whitespace().collect();
-
-        if parts.len() < 4 || parts[0] != "create" {
-            return Ok(Message {
-                content: "Usage: create <type> <name> <description>".to_string(),
-                role: "assistant".to_string(),
-                timestamp: chrono::Utc::now().timestamp() as u64,
-                metadata: None,
-            });
-        }
-
-        let project_type = parts[1];
-        let name = parts[2];
-        let description = parts[3..].join(" ");
-
-        // Validate project type
-        if !["python", "rust", "common"].contains(&project_type) {
-            return Ok(Message {
-                content: "Project type must be one of: python, rust, common".to_string(),
-                role: "assistant".to_string(),
-                timestamp: chrono::Utc::now().timestamp() as u64,
-                metadata: None,
-            });
-        }
-
-        // Create project using the project tool
-        let mut params = HashMap::new();
-        params.insert("type".to_string(), project_type.to_string());
-        params.insert("name".to_string(), name.to_string());
-        params.insert("description".to_string(), description.clone());
-
-        let tool_call = ToolCall {
-            tool: "project".to_string(),
-            parameters: params.clone(),
-            result: None,
-        };
-
-        let result = self.tools.execute(&Tool {
-            name: "project".to_string(),
-            description: "Project initialization tool".to_string(),
-            parameters: HashMap::new(),
-        }, params).await?;
-
-        Ok(Message {
-            content: result,
-            role: "assistant".to_string(),
-            timestamp: chrono::Utc::now().timestamp() as u64,
-            metadata: Some(MessageMetadata {
-                tool_calls: Some(vec![tool_call]),
-                state: self.current_state.clone(),
-                confidence: None,
-            }),
-        })
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
     }

-    async fn transfer_to(&mut self, _agent_name: &str) -> Result<()> {
-        Ok(())
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        Ok(format!("Tool {} called with params: {:?}", tool.name, params))
     }

-    async fn call_tool(&mut self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        self.tools.execute(tool, params).await
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(self.current_state.clone().map(|s| State::from_str(&s)))
     }

-    fn get_current_state(&self) -> Option<&State> {
-        None
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
     }
-}
+}
diff --git a/src/agents/transfer.rs b/src/agents/transfer.rs
index e7c9da6..39acc94 100644
--- a/src/agents/transfer.rs
+++ b/src/agents/transfer.rs
@@ -1,23 +1,20 @@
 use std::sync::Arc;
 use tokio::sync::RwLock;
 use crate::{
-    types::{Message, Agent},
+    types::{Message, Result, Agent},
     agents::AgentRegistry,
-    Result,
 };

 pub struct TransferService {
-    registry: Arc<RwLock<AgentRegistry>>,
     current_agent: Option<String>,
-    session_id: Option<String>,
+    registry: Arc<RwLock<AgentRegistry>>,
 }

 impl TransferService {
     pub fn new(registry: Arc<RwLock<AgentRegistry>>) -> Self {
         Self {
-            registry,
             current_agent: None,
-            session_id: None,
+            registry,
         }
     }

@@ -33,38 +30,23 @@ impl TransferService {
         self.current_agent = Some(agent);
     }

-    pub async fn transfer(&mut self, from: &str, to: &str) -> Result<()> {
-        let mut registry = self.registry.write().await;
-
-        // Validate both agents exist
-        if registry.get(from).is_none() {
-            return Err(format!("Source agent '{}' not found", from).into());
-        }
-        if registry.get(to).is_none() {
-            return Err(format!("Target agent '{}' not found", to).into());
+    pub async fn process_message(&self, message: Message) -> Result<Message> {
+        if let Some(agent_name) = &self.current_agent {
+            let registry = self.registry.read().await;
+            if let Some(agent) = registry.get(agent_name) {
+                return agent.process_message(message).await;
+            }
         }
+        Err("No current agent set".into())
+    }

-        // Get source agent and perform transfer
-        if let Some(source_agent) = registry.get_mut(from) {
-            source_agent.transfer_to(to).await?;
+    pub async fn transfer(&mut self, from: &str, to: &str) -> Result<()> {
+        let registry = self.registry.read().await;
+        if registry.get(to).is_some() {
             self.current_agent = Some(to.to_string());
             Ok(())
         } else {
-            Err(format!("Failed to get mutable reference to agent '{}'", from).into())
-        }
-    }
-
-    pub async fn process_message(&mut self, content: &str) -> Result<Message> {
-        let mut registry = self.registry.write().await;
-
-        if let Some(current_agent) = &self.current_agent {
-            if let Some(agent) = registry.get_mut(current_agent) {
-                agent.process_message(content).await
-            } else {
-                Err(format!("Current agent '{}' not found", current_agent).into())
-            }
-        } else {
-            Err("No current agent set".into())
+            Err(format!("Agent {} not found", to).into())
         }
     }

@@ -81,10 +63,38 @@ impl TransferService {
 mod tests {
     use super::*;
     use crate::types::AgentConfig;
+    use crate::agents::{AgentRegistry, GreeterAgent, HaikuAgent};

     #[tokio::test]
     async fn test_transfer_service() {
-        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+        // Create a test registry
+        let mut registry = AgentRegistry::new();
+
+        // Add test agents
+        let greeter = GreeterAgent::new(AgentConfig {
+            name: "greeter".to_string(),
+            public_description: "Test greeter".to_string(),
+            instructions: "Test instructions".to_string(),
+            tools: vec![],
+            downstream_agents: vec!["haiku".to_string()],
+            personality: None,
+            state_machine: None,
+        });
+
+        let haiku = HaikuAgent::new(AgentConfig {
+            name: "haiku".to_string(),
+            public_description: "Test haiku".to_string(),
+            instructions: "Test instructions".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: None,
+            state_machine: None,
+        });
+
+        registry.register(greeter).unwrap();
+        registry.register(haiku).unwrap();
+
+        let registry = Arc::new(RwLock::new(registry));
         let mut service = TransferService::new(registry);

         // Test no current agent
@@ -92,8 +102,18 @@ mod tests {
         assert!(result.is_err());
         assert_eq!(result.unwrap_err().to_string(), "No current agent set");

+        // Test setting current agent and processing message
+        service.set_current_agent("greeter".to_string());
+        let result = service.process_message("hi").await;
+        assert!(result.is_ok());
+
+        // Test transfer
+        let result = service.transfer("greeter", "haiku").await;
+        assert!(result.is_ok());
+        assert_eq!(service.get_current_agent(), Some("haiku"));
+
         // Test invalid transfer
-        let result = service.transfer("nonexistent", "also_nonexistent").await;
+        let result = service.transfer("nonexistent", "haiku").await;
         assert!(result.is_err());
     }
-}
+}
diff --git a/src/agents/user_agent.rs b/src/agents/user_agent.rs
index dd5713c..66f16e5 100644
--- a/src/agents/user_agent.rs
+++ b/src/agents/user_agent.rs
@@ -5,6 +5,7 @@ use chrono::{DateTime, Utc};
 use crate::types::{Agent, AgentConfig, Result, Message, Tool, State};
 use crate::error::Error;
 use std::collections::HashMap;
+use async_trait::async_trait;

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct TodoItem {
@@ -154,75 +155,25 @@ impl UserAgent {
     }
 }

-#[async_trait::async_trait]
+#[async_trait]
 impl Agent for UserAgent {
-    async fn process_message(&mut self, message: &str) -> Result<Message> {
-        // Parse commands from the message
-        let parts: Vec<&str> = message.split_whitespace().collect();
-        if parts.is_empty() {
-            return Ok(Message::new("Please provide a command"));
-        }
-
-        let response = match parts[0] {
-            "add" => {
-                let description = parts[1..].join(" ");
-                self.add_todo(description, None)?;
-                "Todo added successfully".to_string()
-            }
-            "list" => {
-                let mut response = String::new();
-                for (i, todo) in self.state.todos.iter().enumerate() {
-                    response.push_str(&format!(
-                        "{}. [{}] {}\n",
-                        i + 1,
-                        match todo.status {
-                            TodoStatus::Pending => "PENDING",
-                            TodoStatus::InProgress => "IN PROGRESS",
-                            TodoStatus::Completed => "COMPLETED",
-                            TodoStatus::Failed => "FAILED",
-                        },
-                        todo.description
-                    ));
-                }
-                if response.is_empty() {
-                    "No todos found".to_string()
-                } else {
-                    response
-                }
-            }
-            "process" => {
-                if let Some((index, todo)) = self.get_next_pending_todo() {
-                    if let Ok(Some(agent)) = self.determine_next_agent(todo).await {
-                        format!("Assigning todo to agent: {}", agent)
-                    } else {
-                        "Could not determine appropriate agent".to_string()
-                    }
-                } else {
-                    "No pending todos found".to_string()
-                }
-            }
-            _ => "Unknown command. Available commands: add, list, process".to_string(),
-        };
-
-        Ok(Message::new(&response))
+    async fn process_message(&self, message: Message) -> Result<Message> {
+        Ok(Message::new(format!("User received: {}", message.content)))
     }

-    async fn transfer_to(&mut self, agent_name: &str) -> Result<()> {
-        // User agent doesn't transfer to other agents
-        Err("UserAgent does not support transfers".into())
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
     }

-    async fn call_tool(&mut self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        // User agent doesn't use tools directly
-        Err("UserAgent does not support direct tool usage".into())
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        Ok(format!("Called tool {} with params {:?}", tool.name, params))
     }

-    fn get_current_state(&self) -> Option<&State> {
-        // User agent doesn't use state machine
-        None
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(None)
     }

-    fn get_config(&self) -> &AgentConfig {
-        &self.config
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
     }
 }
diff --git a/src/agents/wrapper.rs b/src/agents/wrapper.rs
new file mode 100644
index 0000000..4b56d21
--- /dev/null
+++ b/src/agents/wrapper.rs
@@ -0,0 +1,76 @@
+use std::sync::Arc;
+use tokio::sync::RwLock;
+use async_trait::async_trait;
+use std::collections::HashMap;
+use crate::types::{Agent, Message, Tool, State, AgentConfig, Result};
+
+/// A wrapper type that handles the complexity of agent type management.
+/// This provides a consistent interface for working with agents while
+/// handling the necessary thread-safety and dynamic dispatch requirements.
+pub struct AgentWrapper {
+    inner: Box<dyn Agent + Send + Sync>,
+}
+
+impl AgentWrapper {
+    /// Create a new AgentWrapper from any type that implements Agent
+    pub fn new(agent: Box<dyn Agent + Send + Sync>) -> Self {
+        Self { inner: agent }
+    }
+}
+
+#[async_trait]
+impl Agent for AgentWrapper {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        self.inner.process_message(message).await
+    }
+
+    async fn transfer_to(&mut self, target_agent: String, message: Message) -> Result<Message> {
+        self.inner.transfer_to(target_agent, message).await
+    }
+
+    async fn call_tool(&mut self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+        self.inner.call_tool(tool, params).await
+    }
+
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        self.inner.get_current_state().await
+    }
+
+    async fn get_config(&self) -> Result<AgentConfig> {
+        self.inner.get_config().await
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::agents::haiku::HaikuAgent;
+
+    #[tokio::test]
+    async fn test_agent_wrapper() {
+        let config = AgentConfig {
+            name: "test".to_string(),
+            public_description: "Test agent".to_string(),
+            instructions: "Test instructions".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: None,
+            state_machine: None,
+        };
+
+        let agent = HaikuAgent::new(config.clone());
+        let mut wrapper = AgentWrapper::new(Box::new(agent));
+
+        // Test that we can get the config
+        let config = wrapper.get_config().await.unwrap();
+        assert_eq!(config.name, "test");
+
+        // Test that we can process messages
+        let response = wrapper.process_message("test").await;
+        assert!(response.is_ok());
+
+        // Test state access
+        let state = wrapper.get_current_state().await;
+        assert!(state.is_ok());
+    }
+}
diff --git a/src/api/mod.rs b/src/api/mod.rs
index ca3fb54..1370648 100644
--- a/src/api/mod.rs
+++ b/src/api/mod.rs
@@ -7,18 +7,26 @@ use axum::{
 use tower_http::cors::CorsLayer;
 use tokio::sync::RwLock;
 use crate::agents::TransferService;
+use std::collections::HashMap;
+use crate::agents::Agent;
+use crate::{
+    agents::{AgentRegistry, TransferService},
+    api::routes::{default_agents, websocket_handler},
+    types::Agent,
+    AppState,
+};

 pub mod routes;
 pub mod websocket;

-#[derive(Clone)]
 pub struct AppState {
     pub transfer_service: Arc<RwLock<TransferService>>,
+    pub agents: Arc<RwLock<AgentRegistry>>,
 }

 impl AppState {
     pub fn new(transfer_service: Arc<RwLock<TransferService>>) -> Self {
-        Self { transfer_service }
+        Self { transfer_service, agents: Arc::new(RwLock::new(AgentRegistry::new())) }
     }
 }

@@ -26,7 +34,7 @@ pub async fn create_app_state() -> Arc<AppState> {
     use crate::agents::AgentRegistry;
     use crate::api::routes::default_agents;

-    let registry = AgentRegistry::create_default_agents(default_agents()).unwrap();
+    let registry = AgentRegistry::create_default_agents(default_agents()).await.unwrap();
     let registry = Arc::new(RwLock::new(registry));
     let transfer_service = Arc::new(RwLock::new(TransferService::new(registry)));

@@ -34,14 +42,18 @@ pub async fn create_app_state() -> Arc<AppState> {
 }

 pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferService>>) {
-    let app_state = Arc::new(AppState { transfer_service });
+    let registry = AgentRegistry::create_default_agents(default_agents()).await.unwrap();
+    let app_state = Arc::new(AppState {
+        transfer_service,
+        agents: Arc::new(RwLock::new(registry)),
+    });

     let app = Router::new()
         .route("/", get(routes::index))
         .route("/api/agents", get(routes::list_agents))
         .route("/api/agents/:name", get(routes::get_agent))
         .route("/api/agents/:name/message", post(routes::send_message))
-        .route("/ws", get(websocket::handler))
+        .route("/ws", get(websocket::websocket_handler))
         .layer(CorsLayer::permissive())
         .with_state(app_state);

@@ -53,3 +65,17 @@ pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferServic
     .await
     .unwrap();
 }
+
+pub async fn create_router() -> Router {
+    let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+    let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
+
+    let app_state = Arc::new(AppState {
+        transfer_service,
+        agents: registry,
+    });
+
+    Router::new()
+        .route("/ws", get(websocket_handler))
+        .with_state(app_state)
+}
diff --git a/src/api/routes.rs b/src/api/routes.rs
index d7fe223..fe6c1e5 100644
--- a/src/api/routes.rs
+++ b/src/api/routes.rs
@@ -10,7 +10,7 @@ use tokio::sync::RwLock;

 use crate::{
     api::AppState,
-    types::{Message, AgentConfig},
+    types::{Message, AgentConfig, Agent, AgentInfo},
     agents::AgentRegistry,
 };

@@ -29,18 +29,19 @@ pub struct MessageRequest {
     content: String,
 }

-pub async fn list_agents(State(state): State<Arc<AppState>>) -> Response {
-    let transfer_service = state.transfer_service.read().await;
-    let registry = transfer_service.get_registry().read().await;
-    let agents = registry.get_all_agents()
-        .iter()
-        .map(|agent| AgentResponse {
-            name: agent.get_config().name.clone(),
-            description: agent.get_config().public_description.clone(),
-        })
-        .collect::<Vec<_>>();
-
-    Json(agents).into_response()
+pub async fn list_agents(State(state): State<Arc<AppState>>) -> impl IntoResponse {
+    let mut agents = Vec::new();
+    for agent in state.agents.values() {
+        if let Ok(config) = agent.get_config().await {
+            agents.push(AgentInfo {
+                name: config.name,
+                description: config.public_description,
+                tools: config.tools,
+                downstream_agents: config.downstream_agents,
+            });
+        }
+    }
+    Json(agents)
 }

 pub async fn get_agent(
@@ -50,9 +51,11 @@ pub async fn get_agent(
     let transfer_service = state.transfer_service.read().await;
     let registry = transfer_service.get_registry().read().await;
     match registry.get(&name) {
-        Some(agent) => Json(AgentResponse {
-            name: agent.get_config().name.clone(),
-            description: agent.get_config().public_description.clone(),
+        Some(agent) => Json(AgentInfo {
+            name: agent.get_config().await.unwrap().name,
+            description: agent.get_config().await.unwrap().public_description,
+            tools: agent.get_config().await.unwrap().tools,
+            downstream_agents: agent.get_config().await.unwrap().downstream_agents,
         }).into_response(),
         None => (
             StatusCode::NOT_FOUND,
@@ -63,6 +66,21 @@ pub async fn get_agent(
     }
 }

+pub async fn process_message(
+    State(state): State<Arc<AppState>>,
+    Path(agent_name): Path<String>,
+    Json(message): Json<Message>,
+) -> Result<impl IntoResponse, StatusCode> {
+    if let Some(agent) = state.agents.get(&agent_name) {
+        match agent.process_message(message).await {
+            Ok(response) => Ok(Json(response)),
+            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
+        }
+    } else {
+        Err(StatusCode::NOT_FOUND)
+    }
+}
+
 pub async fn send_message(
     State(state): State<Arc<AppState>>,
     Path(name): Path<String>,
@@ -72,15 +90,7 @@ pub async fn send_message(
     let registry = transfer_service.get_registry().read().await;
     match registry.get(&name) {
         Some(_) => {
-            let response = Message {
-                content: "Connected to agent system".to_string(),
-                role: "assistant".to_string(),
-                timestamp: std::time::SystemTime::now()
-                    .duration_since(std::time::UNIX_EPOCH)
-                    .unwrap()
-                    .as_secs(),
-                metadata: None,
-            };
+            let response = Message::new("Connected to agent system".to_string());
             Json(response).into_response()
         }
         None => (
@@ -93,17 +103,75 @@ pub async fn send_message(
 }

 pub fn default_agents() -> Vec<AgentConfig> {
-    vec![
-        AgentConfig {
-            name: "greeter".to_string(),
-            public_description: "Agent that greets the user.".to_string(),
-            instructions: "Please greet the user and ask them if they'd like a Haiku. If yes, transfer them to the 'haiku' agent.".to_string(),
-            tools: Vec::new(),
-            downstream_agents: vec!["haiku".to_string()],
-            personality: None,
-            state_machine: None,
-        }
-    ]
+    // vec![ restore default later ?
+    //     AgentConfig {
+    //         name: "greeter".to_string(),
+    //         public_description: "Agent that greets the user.".to_string(),
+    //         instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
+    //         tools: Vec::new(),
+    //         downstream_agents: vec!["haiku".to_string()],
+    //         personality: None,
+    //         state_machine: None,
+    //     }
+    // ]
+    let mut agents = Vec::new();
+
+    #[cfg(feature = "greeter-agent")]
+    agents.push(AgentConfig {
+        name: "greeter".to_string(),
+        public_description: "Agent that greets the user.".to_string(),
+        instructions: "Please greet the user and ask them if they'd like a Haiku. If yes, transfer them to the 'haiku' agent.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: vec!["haiku".to_string()],
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "haiku-agent")]
+    agents.push(AgentConfig {
+        name: "haiku".to_string(),
+        public_description: "Agent that creates haikus.".to_string(),
+        instructions: "Create haikus based on user input.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "git-agent")]
+    agents.push(AgentConfig {
+        name: "git".to_string(),
+        public_description: "Agent that helps with git operations.".to_string(),
+        instructions: "Help users with git operations like commit, branch, merge etc.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "project-init-agent")]
+    agents.push(AgentConfig {
+        name: "project-init".to_string(),
+        public_description: "Agent that helps initialize new projects.".to_string(),
+        instructions: "Help users create new projects with proper structure and configuration.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    #[cfg(feature = "browser-agent")]
+    agents.push(AgentConfig {
+        name: "browser".to_string(),
+        public_description: "Agent that controls browser automation.".to_string(),
+        instructions: "Help users with browser automation tasks.".to_string(),
+        tools: Vec::new(),
+        downstream_agents: Vec::new(),
+        personality: None,
+        state_machine: None,
+    });
+
+    agents
 }

 #[cfg(test)]
@@ -113,9 +181,10 @@ mod tests {
     #[tokio::test]
     async fn test_list_agents() {
         let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry)));
+        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
         let state = Arc::new(AppState {
             transfer_service,
+            agents: registry,
         });
         let response = list_agents(State(state)).await;
         assert_eq!(response.status(), StatusCode::OK);
@@ -124,9 +193,10 @@ mod tests {
     #[tokio::test]
     async fn test_get_agent() {
         let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry)));
+        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
         let state = Arc::new(AppState {
             transfer_service,
+            agents: registry,
         });
         let response = get_agent(State(state.clone()), Path("unknown".to_string())).await;
         assert_eq!(response.status(), StatusCode::NOT_FOUND);
@@ -135,9 +205,10 @@ mod tests {
     #[tokio::test]
     async fn test_send_message() {
         let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry)));
+        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
         let state = Arc::new(AppState {
             transfer_service,
+            agents: registry,
         });
         let request = MessageRequest {
             content: "Hello".to_string(),
diff --git a/src/api/websocket.rs b/src/api/websocket.rs
index d535c23..2f7bdb9 100644
--- a/src/api/websocket.rs
+++ b/src/api/websocket.rs
@@ -1,6 +1,6 @@
 use std::sync::Arc;
 use axum::{
-    extract::ws::{WebSocket, Message as WsMessage},
+    extract::ws::{WebSocket, Message as WsMessage, WebSocketUpgrade},
     extract::{State, WebSocketUpgrade},
     response::IntoResponse,
 };
@@ -10,7 +10,7 @@ use tokio::sync::broadcast;
 use crate::{
     api::AppState,
     agents::{AgentRegistry, TransferService, GreeterAgent, HaikuAgent},
-    types::{AgentConfig, Tool},
+    types::{AgentConfig, Tool, Message},
 };
 use tokio::sync::RwLock;

@@ -48,47 +48,36 @@ pub enum ServerMessage {
     SessionUpdated,
 }

-pub async fn handler(
+pub async fn websocket_handler(
     ws: WebSocketUpgrade,
-    State(state): State<Arc<AppState>>,
+    state: Arc<AppState>,
 ) -> impl IntoResponse {
     ws.on_upgrade(|socket| handle_socket(socket, state))
 }

 async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {
     let (mut sender, mut receiver) = socket.split();
-    let (tx, _rx) = broadcast::channel(CHANNEL_SIZE);
-    let tx2 = tx.clone();
-
-    // Handle incoming messages
-    let mut recv_task = tokio::spawn(async move {
-        while let Some(Ok(msg)) = receiver.next().await {
-            if let WsMessage::Text(text) = msg {
-                if let Ok(client_msg) = serde_json::from_str::<ClientMessage>(&text) {
-                    let response = handle_client_message(client_msg, state.clone()).await;
-                    if let Ok(response) = serde_json::to_string(&response) {
-                        let _ = tx.send(WsMessage::Text(response));
+
+    while let Some(Ok(msg)) = receiver.next().await {
+        if let WsMessage::Text(content) = msg {
+            let transfer_service = state.transfer_service.read().await;
+            match transfer_service.process_message(Message::new(content.to_string())).await {
+                Ok(response) => {
+                    if let Err(e) = sender.send(WsMessage::Text(response.content)).await {
+                        eprintln!("Error sending response: {}", e);
+                        return;
+                    }
+                }
+                Err(e) => {
+                    eprintln!("Error processing message: {}", e);
+                    if let Err(e) = sender.send(WsMessage::Text(format!("Error: {}", e))).await {
+                        eprintln!("Error sending error response: {}", e);
+                        return;
                     }
                 }
             }
         }
-    });
-
-    // Handle outgoing messages
-    let mut send_task = tokio::spawn(async move {
-        let mut rx = tx2.subscribe();
-        while let Ok(msg) = rx.recv().await {
-            if sender.send(msg).await.is_err() {
-                break;
-            }
-        }
-    });
-
-    // Wait for either task to finish
-    tokio::select! {
-        _ = (&mut recv_task) => send_task.abort(),
-        _ = (&mut send_task) => recv_task.abort(),
-    };
+    }
 }

 async fn handle_client_message(
@@ -104,13 +93,20 @@ async fn handle_client_message(
             ServerMessage::Connected { agent }
         }
         ClientMessage::Message { content } => {
-            match transfer_service.process_message(&content).await {
-                Ok(response) => ServerMessage::Message {
-                    content: response.content,
-                },
-                Err(e) => ServerMessage::Error {
-                    message: e.to_string(),
-                },
+            match transfer_service.process_message(Message::new(content)).await {
+                Ok(response) => {
+                    if let Err(e) = tx.send(Message::Text(response.content)).await {
+                        eprintln!("Error sending response: {}", e);
+                        break;
+                    }
+                }
+                Err(e) => {
+                    eprintln!("Error processing message: {}", e);
+                    if let Err(e) = tx.send(Message::Text(format!("Error: {}", e))).await {
+                        eprintln!("Error sending error response: {}", e);
+                        break;
+                    }
+                }
             }
         }
         ClientMessage::Transfer { from, to } => {
@@ -157,8 +153,8 @@ mod tests {
             state_machine: None,
         };

-        registry.register("greeter".to_string(), GreeterAgent::new(greeter_config));
-        registry.register("haiku".to_string(), HaikuAgent::new(haiku_config));
+        registry.register(GreeterAgent::new(greeter_config)).expect("Failed to register greeter agent");
+        registry.register(HaikuAgent::new(haiku_config)).expect("Failed to register haiku agent");

         let registry = Arc::new(RwLock::new(registry));
         let transfer_service = Arc::new(RwLock::new(TransferService::new(registry)));
diff --git a/src/bin/swarm.rs b/src/bin/swarm.rs
index af3a3f5..91b0951 100644
--- a/src/bin/swarm.rs
+++ b/src/bin/swarm.rs
@@ -1,11 +1,13 @@
 use clap::{Parser, Subcommand};
 use swarmonomicon::{
-    agents::{self, TransferService, GreeterAgent},
+    agents::{self, TransferService, GreeterAgent, ProjectInitAgent},
     types::{Agent, AgentConfig},
 };
 use std::error::Error;
 use std::sync::Arc;
 use tokio::sync::RwLock;
+use swarmonomicon::agents::git_assistant::GitAssistantAgent;
+use swarmonomicon::agents::haiku::HaikuAgent;

 #[derive(Parser)]
 #[command(author, version, about, long_about = None)]
@@ -56,44 +58,54 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
     let registry = agents::GLOBAL_REGISTRY.clone();
     {
         let mut registry = registry.write().await;
-        *registry = agents::AgentRegistry::create_default_agents(vec![
-            AgentConfig {
-                name: "greeter".to_string(),
-                public_description: "Swarmonomicon's Guide to Unhinged Front Desk Wizardry".to_string(),
-                instructions: "Master of controlled chaos and improvisational engineering".to_string(),
-                tools: vec![],
-                downstream_agents: vec!["git".to_string(), "project".to_string(), "haiku".to_string()],
-                personality: None,
-                state_machine: None,
-            },
-            AgentConfig {
-                name: "git".to_string(),
-                public_description: "Git operations with intelligent commit messages".to_string(),
-                instructions: "Handles Git operations including commits, branches, and merges".to_string(),
-                tools: vec![],
-                downstream_agents: vec![],
-                personality: None,
-                state_machine: None,
-            },
-            AgentConfig {
-                name: "project".to_string(),
-                public_description: "Project initialization tool".to_string(),
-                instructions: "Creates new projects with proper structure and configuration".to_string(),
-                tools: vec![],
-                downstream_agents: vec![],
-                personality: None,
-                state_machine: None,
-            },
-            AgentConfig {
-                name: "haiku".to_string(),
-                public_description: "Creates haikus".to_string(),
-                instructions: "Create haikus".to_string(),
-                tools: vec![],
-                downstream_agents: vec![],
-                personality: None,
-                state_machine: None,
-            },
-        ])?;
+
+        // Create agent instances
+        let mut git_assistant = GitAssistantAgent::new(AgentConfig {
+            name: "git".to_string(),
+            public_description: "Git operations with intelligent commit messages".to_string(),
+            instructions: "Handles Git operations including commits, branches, and merges".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: None,
+            state_machine: None,
+        });
+        git_assistant.set_working_dir("./").unwrap_or_else(|e| eprintln!("Warning: Failed to set git working directory: {}", e));
+
+        let haiku_agent = HaikuAgent::new(AgentConfig {
+            name: "haiku".to_string(),
+            public_description: "Creates haikus".to_string(),
+            instructions: "Create haikus".to_string(),
+            tools: vec![],
+            downstream_agents: vec!["git".to_string()],
+            personality: None,
+            state_machine: None,
+        });
+
+        let project_agent = ProjectInitAgent::new(AgentConfig {
+            name: "project".to_string(),
+            public_description: "Project initialization tool".to_string(),
+            instructions: "Creates new projects with proper structure and configuration".to_string(),
+            tools: vec![],
+            downstream_agents: vec!["git".to_string()],
+            personality: None,
+            state_machine: None,
+        });
+
+        let greeter_agent = GreeterAgent::new(AgentConfig {
+            name: "greeter".to_string(),
+            public_description: "Swarmonomicon's Guide to Unhinged Front Desk Wizardry".to_string(),
+            instructions: "Master of controlled chaos and improvisational engineering".to_string(),
+            tools: vec![],
+            downstream_agents: vec!["git".to_string(), "project".to_string(), "haiku".to_string()],
+            personality: None,
+            state_machine: None,
+        });
+
+        // Register agents
+        registry.register(git_assistant)?;
+        registry.register(haiku_agent)?;
+        registry.register(project_agent)?;
+        registry.register(greeter_agent)?;
     }

     // Create transfer service starting with greeter
@@ -149,7 +161,22 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
                 }

                 match service.process_message(message).await {
-                    Ok(response) => println!("{}", response.content),
+                    Ok(response) => {
+                        println!("{}", response.content);
+
+                        // Check for haiku generation and commit if needed
+                        if response.content.contains("Generated haiku:") &&
+                           service.get_current_agent().as_deref() == Some("haiku") {
+                            // Get the git agent and commit the haiku
+                            let mut registry = registry.write().await;
+                            if let Some(mut git_agent) = registry.get_mut("git") {
+                                let haiku = response.content.replace("Generated haiku:\n", "");
+                                if let Err(e) = git_agent.commit_for_agent("haiku", &haiku).await {
+                                    eprintln!("Failed to commit haiku: {}", e);
+                                }
+                            }
+                        }
+                    }
                     Err(e) => eprintln!("Error: {}", e),
                 }
             }
@@ -158,3 +185,92 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {

     Ok(())
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use tempfile::tempdir;
+
+    #[tokio::test]
+    async fn test_haiku_git_integration() -> Result<(), Box<dyn Error + Send + Sync>> {
+        // Set up a temporary directory for git
+        let temp_dir = tempdir()?;
+
+        // Initialize the registry with test agents
+        let registry = Arc::new(RwLock::new(agents::AgentRegistry::new()));
+        {
+            let mut registry = registry.write().await;
+
+            // Create git agent with temp directory
+            let mut git_assistant = GitAssistantAgent::new(AgentConfig {
+                name: "git".to_string(),
+                public_description: "Git test agent".to_string(),
+                instructions: "Test git operations".to_string(),
+                tools: vec![],
+                downstream_agents: vec![],
+                personality: None,
+                state_machine: None,
+            });
+            git_assistant.set_working_dir(temp_dir.path())?;
+
+            let haiku_agent = HaikuAgent::new(AgentConfig {
+                name: "haiku".to_string(),
+                public_description: "Test haiku agent".to_string(),
+                instructions: "Test haiku generation".to_string(),
+                tools: vec![],
+                downstream_agents: vec!["git".to_string()],
+                personality: None,
+                state_machine: None,
+            });
+
+            let project_agent = ProjectInitAgent::new(AgentConfig {
+                name: "project".to_string(),
+                public_description: "Test project agent".to_string(),
+                instructions: "Test project initialization".to_string(),
+                tools: vec![],
+                downstream_agents: vec!["git".to_string()],
+                personality: None,
+                state_machine: None,
+            });
+
+            registry.register(git_assistant)?;
+            registry.register(haiku_agent)?;
+            registry.register(project_agent)?;
+        }
+
+        // Create transfer service
+        let mut service = TransferService::new(registry.clone());
+
+        // Test haiku generation and git commit
+        service.set_current_agent("haiku".to_string());
+        let response = service.process_message("generate haiku about coding").await?;
+
+        assert!(response.content.contains("Generated haiku:"));
+
+        // Verify git commit
+        let git_status = std::process::Command::new("git")
+            .current_dir(temp_dir.path())
+            .args(["log", "--oneline"])
+            .output()?;
+
+        let git_log = String::from_utf8_lossy(&git_status.stdout);
+        assert!(git_log.contains("[haiku]"));
+
+        // Test project initialization
+        service.set_current_agent("project".to_string());
+        let response = service.process_message("create rust test-project 'A test project'").await?;
+
+        assert!(response.content.contains("Project created"));
+
+        // Verify project files were committed
+        let git_status = std::process::Command::new("git")
+            .current_dir(temp_dir.path())
+            .args(["log", "--oneline"])
+            .output()?;
+
+        let git_log = String::from_utf8_lossy(&git_status.stdout);
+        assert!(git_log.contains("[project]"));
+
+        Ok(())
+    }
+}
diff --git a/src/types/mod.rs b/src/types/mod.rs
index 31a32c1..6448562 100644
--- a/src/types/mod.rs
+++ b/src/types/mod.rs
@@ -1,6 +1,9 @@
 use async_trait::async_trait;
 use serde::{Deserialize, Serialize};
 use std::collections::HashMap;
+use chrono;
+use std::str::FromStr;
+use thiserror::Error;

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct ToolParameter {
@@ -18,7 +21,7 @@ pub struct ToolParameter {
 pub struct Tool {
     pub name: String,
     pub description: String,
-    pub parameters: HashMap<String, ToolParameter>,
+    pub parameters: HashMap<String, String>,
 }

 #[derive(Debug, Clone, Serialize, Deserialize)]
@@ -49,35 +52,66 @@ pub struct TranscriptItem {
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Message {
     pub content: String,
-    pub role: String,
-    pub timestamp: u64,
     pub metadata: Option<MessageMetadata>,
+    pub role: Option<String>,
+    pub timestamp: Option<i64>,
 }

 impl Message {
-    pub fn new(content: &str) -> Self {
+    pub fn new(content: String) -> Self {
         Self {
-            content: content.to_string(),
-            role: "assistant".to_string(),
-            timestamp: std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap_or_default()
-                .as_secs(),
+            content,
             metadata: None,
+            role: Some("assistant".to_string()),
+            timestamp: Some(chrono::Utc::now().timestamp()),
         }
     }
 }

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct MessageMetadata {
-    pub tool_calls: Option<Vec<ToolCall>>,
+    pub agent: String,
     pub state: Option<String>,
-    pub confidence: Option<f32>,
+    pub personality_traits: Option<Vec<String>>,
+    pub transfer_target: Option<String>,
+    pub context: Option<HashMap<String, String>>,
+}
+
+impl MessageMetadata {
+    pub fn new(agent: String) -> Self {
+        Self {
+            agent,
+            state: None,
+            personality_traits: None,
+            transfer_target: None,
+            context: None,
+        }
+    }
+
+    pub fn with_state(mut self, state: String) -> Self {
+        self.state = Some(state);
+        self
+    }
+
+    pub fn with_personality(mut self, traits: Vec<String>) -> Self {
+        self.personality_traits = Some(traits);
+        self
+    }
+
+    pub fn with_transfer(mut self, target: String) -> Self {
+        self.transfer_target = Some(target);
+        self
+    }
+
+    pub fn with_context(mut self, context: HashMap<String, String>) -> Self {
+        self.context = Some(context);
+        self
+    }
 }

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct ToolCall {
-    pub tool: String,
+    pub tool: Tool,
     pub parameters: HashMap<String, String>,
     pub result: Option<String>,
 }
@@ -90,9 +124,25 @@ pub struct StateMachine {

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct State {
-    pub prompt: String,
-    pub transitions: HashMap<String, String>,
-    pub validation: Option<ValidationRule>,
+    pub name: String,
+    pub data: Option<String>,
+    pub prompt: Option<String>,
+    pub transitions: Option<HashMap<String, String>>,
+    pub validation: Option<Vec<String>>,
+}
+
+impl FromStr for State {
+    type Err = Box<dyn std::error::Error + Send + Sync>;
+
+    fn from_str(s: &str) -> Result<Self> {
+        Ok(State {
+            name: s.to_string(),
+            data: None,
+            prompt: None,
+            transitions: None,
+            validation: None,
+        })
+    }
 }

 #[derive(Debug, Clone, Serialize, Deserialize)]
@@ -101,17 +151,17 @@ pub struct ValidationRule {
     pub error_message: String,
 }

+pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;
+
 #[async_trait]
 pub trait Agent: Send + Sync {
-    async fn process_message(&mut self, message: &str) -> crate::Result<Message>;
-    async fn transfer_to(&mut self, agent_name: &str) -> crate::Result<()>;
-    async fn call_tool(&mut self, tool: &Tool, params: HashMap<String, String>) -> crate::Result<String>;
-    fn get_current_state(&self) -> Option<&State>;
-    fn get_config(&self) -> &AgentConfig;
+    async fn process_message(&self, message: Message) -> Result<Message>;
+    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message>;
+    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String>;
+    async fn get_current_state(&self) -> Result<Option<State>>;
+    async fn get_config(&self) -> Result<AgentConfig>;
 }

-pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;
-
 // Implement a basic agent state manager
 pub struct AgentStateManager {
     current_state: Option<String>,
@@ -130,7 +180,7 @@ impl AgentStateManager {
     pub fn transition(&mut self, event: &str) -> Option<&State> {
         if let (Some(state_machine), Some(current_state)) = (&self.state_machine, &self.current_state) {
             if let Some(current) = state_machine.states.get(current_state) {
-                if let Some(next_state) = current.transitions.get(event) {
+                if let Some(next_state) = current.transitions.as_ref().and_then(|transitions| transitions.get(event)) {
                     self.current_state = Some(next_state.clone());
                     return state_machine.states.get(next_state);
                 }
@@ -154,4 +204,12 @@ impl AgentStateManager {

 // More types will be added as needed
 #[allow(dead_code)]
-pub struct Unimplemented;
+pub struct Unimplemented;
+
+#[derive(Debug, Clone, Serialize)]
+pub struct AgentInfo {
+    pub name: String,
+    pub description: String,
+    pub tools: Vec<Tool>,
+    pub downstream_agents: Vec<String>,
+}
