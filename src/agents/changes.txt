diff --git a/Cargo.lock b/Cargo.lock
index 0000000..0b2792f
--- /dev/null
+++ b/gitdiff.txt
@@ -0,0 +1,2986 @@
+diff --git a/src/agents/browser_agent.rs b/src/agents/browser_agent.rs
+index 16e15f1..6bb5f16 100644
+--- a/src/agents/browser_agent.rs
++++ b/src/agents/browser_agent.rs
+@@ -33,11 +33,17 @@ impl BrowserAgentWrapper {
+ }
+
+ // Temporary dummy agent implementation
+-struct DummyAgent {}
++pub struct DummyAgent {}
++
++impl DummyAgent {
++    pub fn new() -> Self {
++        Self {}
++    }
++}
+
+ #[async_trait]
+ impl Agent for DummyAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
+         Ok(Message::new(format!("Browser received: {}", message.content)))
+     }
+
+@@ -68,7 +74,7 @@ impl Agent for DummyAgent {
+
+ #[async_trait]
+ impl Agent for BrowserAgentWrapper {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
+         self.inner.process_message(message).await
+     }
+
+diff --git a/src/agents/git_assistant.rs b/src/agents/git_assistant.rs
+index 24848f3..fa7ffd9 100644
+--- a/src/agents/git_assistant.rs
++++ b/src/agents/git_assistant.rs
+@@ -1,333 +1,127 @@
+ use async_trait::async_trait;
+-use std::process::Command;
+ use std::collections::HashMap;
+-use std::path::{Path, PathBuf};
+-use std::sync::{Arc, Mutex};
+-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State, StateMachine, AgentStateManager};
+-use crate::tools::ToolRegistry;
+-use crate::Result;
+-use rand::Rng;
+-use chrono;
+-use crate::ai::AiClient;
++use std::path::PathBuf;
++use tokio::process::Command as TokioCommand;
++use tokio::io::{AsyncBufReadExt, BufReader};
++
++use crate::types::{Agent, AgentConfig, Message, Result, State, Tool};
+
+ pub struct GitAssistantAgent {
+     config: AgentConfig,
+-    tools: ToolRegistry,
+-    state_manager: AgentStateManager,
+-    working_dir: Arc<Mutex<Option<PathBuf>>>,
+-    current_state: Option<State>,
+-    ai_client: AiClient,
+ }
+
+ impl GitAssistantAgent {
+     pub async fn new(config: AgentConfig) -> Result<Self> {
+-        Ok(Self {
+-            config,
+-            tools: ToolRegistry::create_default_tools().await?,
+-            state_manager: AgentStateManager::new(None),
+-            working_dir: Arc::new(Mutex::new(None)),
+-            current_state: None,
+-            ai_client: AiClient::new(),
+-        })
+-    }
+-
+-    // Helper to get working directory or return error
+-    fn get_working_dir(&self) -> Result<PathBuf> {
+-        self.working_dir.lock()
+-            .map_err(|e| format!("Lock error: {}", e))?
+-            .clone()
+-            .ok_or_else(|| "Working directory not set".into())
++        Ok(Self { config })
+     }
+
+-    // Change to use interior mutability pattern
+-    pub fn update_working_dir(&self, path: PathBuf) -> Result<()> {
+-        if path.exists() && path.is_dir() {
+-            let mut wd = self.working_dir.lock()
+-                .map_err(|e| format!("Lock error: {}", e))?;
+-            *wd = Some(path);
+-            Ok(())
+-        } else {
+-            Err("Invalid working directory path".into())
+-        }
+-    }
++    async fn execute_git_command(&self, args: &[&str]) -> Result<String> {
++        let output = TokioCommand::new("git")
++            .args(args)
++            .output()
++            .await
++            .map_err(|e| format!("Failed to execute git command: {}", e))?;
+
+-    fn get_git_diff(&self) -> Result<String> {
+-        // Check staged changes
+-        let staged = Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["diff", "--staged"])
+-            .output()?;
++        let stdout = String::from_utf8(output.stdout)?;
++        let stderr = String::from_utf8(output.stderr)?;
+
+-        if !staged.stdout.is_empty() {
+-            return Ok(String::from_utf8_lossy(&staged.stdout).to_string());
++        if !output.status.success() {
++            return Err(format!("Git command failed: {}", stderr).into());
+         }
+
+-        // Check unstaged changes
+-        let unstaged = Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["diff"])
+-            .output()?;
++        Ok(stdout)
++    }
+
+-        let diff = String::from_utf8_lossy(&unstaged.stdout).to_string();
+-        if diff.is_empty() {
+-            return Err(format!("No changes detected in directory: {}", self.get_working_dir()?.display()).into());
+-        }
++    async fn get_current_branch(&self) -> Result<String> {
++        let output = self.execute_git_command(&["rev-parse", "--abbrev-ref", "HEAD"]).await?;
++        Ok(output.trim().to_string())
++    }
+
+-        Ok(diff)
++    async fn get_status(&self) -> Result<String> {
++        self.execute_git_command(&["status"]).await
+     }
+
+-    fn create_branch(&self, branch_name: &str) -> Result<()> {
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["checkout", "-b", branch_name])
+-            .output()?;
+-        Ok(())
++    async fn get_log(&self, num_commits: usize) -> Result<String> {
++        self.execute_git_command(&["log", &format!("-{}", num_commits)]).await
+     }
+
+-    fn stage_changes(&self) -> Result<()> {
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["add", "."])
+-            .output()?;
+-        Ok(())
++    async fn get_diff(&self) -> Result<String> {
++        self.execute_git_command(&["diff"]).await
+     }
+
+-    fn commit_changes(&self, message: &str) -> Result<()> {
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["commit", "-m", message])
+-            .output()?;
+-        Ok(())
++    async fn commit(&self, message: &str) -> Result<String> {
++        self.execute_git_command(&["commit", "-m", message]).await
+     }
+
+-    fn merge_branch(&self, target_branch: &str) -> Result<()> {
+-        // Get current branch
+-        let current = Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["rev-parse", "--abbrev-ref", "HEAD"])
+-            .output()?;
+-        let current_branch = String::from_utf8_lossy(&current.stdout).trim().to_string();
+-
+-        // Switch to target branch
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["checkout", target_branch])
+-            .output()?;
+-
+-        // Merge the feature branch
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["merge", &current_branch])
+-            .output()?;
+-
+-        Ok(())
++    async fn push(&self) -> Result<String> {
++        let branch = self.get_current_branch().await?;
++        self.execute_git_command(&["push", "origin", &branch]).await
+     }
+
+-    async fn generate_commit_message(&self, diff: &str) -> Result<String> {
+-        let system_prompt = "You are a helpful assistant that generates clear and concise git commit messages. \
+-            You analyze git diffs and create conventional commit messages that follow best practices. \
+-            Focus on describing WHAT changed and WHY, being specific but concise. \
+-            Use the conventional commits format: type(scope): Detailed description\n\n\
+-            Types: feat, fix, docs, style, refactor, test, chore\n\
+-            Example: feat(auth): add password reset functionality";
+-
+-        let messages = vec![HashMap::from([
+-            ("role".to_string(), "user".to_string()),
+-            ("content".to_string(), format!(
+-                "Generate a commit message for these changes. If you can't determine the changes clearly, respond with 'NEED_MORE_CONTEXT':\n\n{}",
+-                diff
+-            )),
+-        ])];
+-
+-        let message = self.ai_client.chat(system_prompt, messages).await?;
+-
+-        if message == "NEED_MORE_CONTEXT" {
+-            Ok("Please provide a commit message. The changes are too complex for automatic generation.".to_string())
+-        } else {
+-            Ok(message)
+-        }
++    async fn pull(&self) -> Result<String> {
++        self.execute_git_command(&["pull"]).await
++    }
++
++    async fn checkout(&self, branch: &str) -> Result<String> {
++        self.execute_git_command(&["checkout", branch]).await
+     }
+
+-    pub async fn commit_for_agent(&mut self, agent_name: &str, message: &str) -> Result<()> {
+-        // Stage all changes
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["add", "."])
+-            .output()?;
++    async fn merge(&self, branch: &str) -> Result<String> {
++        self.execute_git_command(&["merge", branch]).await
++    }
+
+-        // Commit with provided message
+-        Command::new("git")
+-            .current_dir(&self.get_working_dir()?)
+-            .args(["commit", "-m", &format!("[{}] {}", agent_name, message)])
+-            .output()?;
++    async fn rebase(&self, branch: &str) -> Result<String> {
++        self.execute_git_command(&["rebase", branch]).await
++    }
+
+-        Ok(())
++    async fn reset(&self, commit: &str) -> Result<String> {
++        self.execute_git_command(&["reset", commit]).await
+     }
+
+-    async fn create_response(&self, content: String) -> Message {
+-        let traits = vec![
+-            "meticulous".to_string(),
+-            "time_traveling".to_string(),
+-            "version_obsessed".to_string(),
+-            "historically_minded".to_string(),
+-            "quantum_branching_enthusiast".to_string(),
+-        ];
+-
+-        let state = self.get_current_state().await.unwrap_or(None)
+-            .map(|s| s.name.clone())
+-            .unwrap_or_else(|| "archival".to_string());
+-
+-        Message::new(content)
+-            .with_metadata(Some(MessageMetadata::new("git_assistant".to_string())
+-                .with_personality(traits)
+-                .with_state(state)))
++    async fn stash(&self) -> Result<String> {
++        self.execute_git_command(&["stash"]).await
+     }
+
+-    fn format_git_response(&self, content: String) -> Message {
+-        let traits = vec!["helpful".to_string(), "technical".to_string()];
+-        let state = self.current_state.as_ref()
+-            .map(|s| s.name.clone())
+-            .unwrap_or_else(|| "archival".to_string());
++    async fn stash_pop(&self) -> Result<String> {
++        self.execute_git_command(&["stash", "pop"]).await
++    }
+
+-        Message::new(content)
+-            .with_metadata(Some(MessageMetadata::new("git_assistant".to_string())
+-                .with_personality(traits)
+-                .with_state(state)))
++    async fn add(&self, files: &[&str]) -> Result<String> {
++        let mut args = vec!["add"];
++        args.extend(files);
++        self.execute_git_command(&args).await
+     }
+
+-    fn handle_git_command(&self, command: &str) -> Message {
+-        let parts: Vec<&str> = command.split_whitespace().collect();
+-        let cmd = parts.first().unwrap_or(&"");
+-        let args = if parts.len() > 1 { &parts[1..] } else { &[] };
+-
+-        let response = match *cmd {
+-            "help" | "" => format!(
+-                "🌟 Quantum Version Control Interface - Your Temporal Archive Assistant\n\n\
+-                Available timeline manipulation commands:\n\
+-                - init: Initialize a new temporal nexus (git repository)\n\
+-                - status: Scan quantum state of current timeline\n\
+-                - add <files>: Preserve artifacts in the temporal archive\n\
+-                - commit <message>: Create a quantum state marker\n\
+-                - branch <name>: Initiate a parallel timeline branch\n\
+-                - checkout <branch>: Shift to an alternate timeline\n\
+-                - merge <branch>: Converge timelines into unified reality\n\
+-                - push: Synchronize local quantum states with the temporal nexus\n\
+-                - pull: Retrieve quantum state updates from the temporal nexus"
+-            ),
+-            "status" => {
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["status"])
+-                    .output() {
+-                        Ok(output) => {
+-                            let status = String::from_utf8_lossy(&output.stdout).to_string();
+-                            if status.is_empty() {
+-                                "🌌 This dimension appears to lack a temporal nexus. Initialize one with 'init'".to_string()
+-                            } else {
+-                                format!("🔮 Quantum State Analysis:\n{}", status)
+-                            }
+-                        },
+-                        Err(_) => "🌌 This dimension appears to lack a temporal nexus. Initialize one with 'init'".to_string(),
+-                    }
+-            },
+-            "add" => {
+-                let files = args.join(" ");
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["add"])
+-                    .args(args)
+-                    .output() {
+-                        Ok(_) => format!("🌟 Preparing to preserve the following artifacts in the temporal archive: {}", files),
+-                        Err(_) => "⚠️ Temporal preservation failed. Is this a valid timeline branch?".to_string(),
+-                    }
+-            },
+-            "commit" => {
+-                let msg = args.join(" ");
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["commit", "-m", if msg.is_empty() { "archival" } else { &msg }])
+-                    .output() {
+-                        Ok(output) => format!("✨ Creating quantum state marker: {}\n{}",
+-                            if msg.is_empty() { "archival" } else { &msg },
+-                            String::from_utf8_lossy(&output.stdout)),
+-                        Err(_) => "⚠️ Failed to create quantum state marker. Are there changes to commit?".to_string(),
+-                    }
+-            },
+-            "branch" => {
+-                let branch_name = args.join(" ");
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["checkout", "-b", &branch_name])
+-                    .output() {
+-                        Ok(_) => format!("🌌 Initiating parallel timeline branch: {}", branch_name),
+-                        Err(_) => "⚠️ Failed to create parallel timeline. Is this a valid temporal nexus?".to_string(),
+-                    }
+-            },
+-            "checkout" => {
+-                let branch_name = args.join(" ");
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["checkout", &branch_name])
+-                    .output() {
+-                        Ok(_) => format!("🌠 Shifting to timeline: {}", branch_name),
+-                        Err(_) => "⚠️ Timeline shift failed. Does this reality branch exist?".to_string(),
+-                    }
+-            },
+-            "merge" => {
+-                let branch_name = args.join(" ");
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["merge", &branch_name])
+-                    .output() {
+-                        Ok(output) => format!("🌊 Converging timeline {} with current timeline\n{}",
+-                            branch_name,
+-                            String::from_utf8_lossy(&output.stdout)),
+-                        Err(_) => "⚠️ Timeline convergence failed. Are both realities compatible?".to_string(),
+-                    }
+-            },
+-            "push" => {
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["push"])
+-                    .output() {
+-                        Ok(_) => "🚀 Synchronizing local quantum states with the temporal nexus...".to_string(),
+-                        Err(_) => "⚠️ Temporal synchronization failed. Is the nexus reachable?".to_string(),
+-                    }
+-            },
+-            "pull" => {
+-                match Command::new("git")
+-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
+-                    .args(["pull"])
+-                    .output() {
+-                        Ok(_) => "📥 Retrieving quantum state updates from the temporal nexus...".to_string(),
+-                        Err(_) => "⚠️ Failed to retrieve temporal updates. Is the nexus reachable?".to_string(),
+-                    }
+-            },
+-            _ => format!("❓ Unknown temporal operation: {}. Use 'help' to see available commands.", command),
++    async fn handle_message(&self, message: &str) -> Result<String> {
++        let command = match message.to_lowercase().as_str() {
++            "status" => self.get_status().await?,
++            "log" => self.get_log(10).await?,
++            "diff" => self.get_diff().await?,
++            _ => "Unknown command".to_string(),
+         };
+
+-        self.format_git_response(response)
++        Ok(command)
+     }
+ }
+
+ #[async_trait]
+ impl Agent for GitAssistantAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
+-        let command = message.content.trim().to_lowercase();
+-        Ok(self.handle_git_command(&command))
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
++        let content = message.content.clone();
++        let response = self.handle_message(&content).await?;
++        Ok(Message::new(response))
+     }
+
+-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
++    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
+         Ok(message)
+     }
+
+-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+-        let response = format!("Executing tool: {} with parameters: {:?}", tool.name, params);
+-        Ok(response)
++    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
++        Ok("Tool called".to_string())
+     }
+
+     async fn get_current_state(&self) -> Result<Option<State>> {
+-        Ok(self.current_state.clone())
++        Ok(None)
+     }
+
+     async fn get_config(&self) -> Result<AgentConfig> {
+@@ -338,227 +132,57 @@ impl Agent for GitAssistantAgent {
+ #[cfg(test)]
+ mod tests {
+     use super::*;
+-    use std::fs;
+     use tempfile::tempdir;
+
+-    fn create_test_message(content: &str) -> Message {
+-        Message::new(content.to_string())
+-    }
+-
+-    fn create_test_config() -> AgentConfig {
+-        AgentConfig {
+-            name: "git".to_string(),
+-            public_description: "Git operations assistant".to_string(),
+-            instructions: "Help with git operations".to_string(),
+-            tools: Vec::new(),
+-            downstream_agents: Vec::new(),
+-            personality: None,
+-            state_machine: None,
+-        }
+-    }
+-
+-    async fn setup_test_repo() -> (GitAssistantAgent, tempfile::TempDir) {
++    #[tokio::test]
++    async fn test_git_assistant() {
+         let temp_dir = tempdir().unwrap();
+-        let mut agent = GitAssistantAgent::new(create_test_config()).await.unwrap();
+-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
+-
+-        // Initialize git repo
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["init"])
+-            .output()
+-            .unwrap();
+-
+-        // Configure git user for commits
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["config", "user.name", "Test User"])
+-            .output()
+-            .unwrap();
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["config", "user.email", "test@example.com"])
+-            .output()
+-            .unwrap();
+-
+-        // Create initial commit to allow branch creation
+-        fs::write(
+-            temp_dir.path().join("initial.txt"),
+-            "Initial commit",
+-        ).unwrap();
++        let repo_path = temp_dir.path().join("test_repo");
++        std::fs::create_dir(&repo_path).unwrap();
+
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["add", "initial.txt"])
+-            .output()
+-            .unwrap();
+-
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["commit", "-m", "Initial commit"])
+-            .output()
+-            .unwrap();
+-
+-        (agent, temp_dir)
+-    }
+-
+-    #[cfg(test)]
+-    async fn create_test_agent() -> Result<GitAssistantAgent> {
+-        GitAssistantAgent::new(AgentConfig {
+-            name: "git".to_string(),
+-            public_description: "Git test agent".to_string(),
+-            instructions: "Test git operations".to_string(),
++        let agent_config = AgentConfig {
++            name: "git_assistant".to_string(),
++            public_description: "Git assistant".to_string(),
++            instructions: "Help with git commands".to_string(),
+             tools: vec![],
+             downstream_agents: vec![],
+             personality: None,
+             state_machine: None,
+-        }).await
+-    }
+-
+-    #[tokio::test]
+-    async fn test_help_message() {
+-        let agent = create_test_agent().await.unwrap();
+-        let response = agent.process_message(Message::new("help".to_string())).await.unwrap();
+-        assert!(response.content.contains("Quantum"), "Help message should contain quantum theme");
+-        assert!(response.content.contains("commands"), "Help message should list commands");
+-    }
+-
+-    #[tokio::test]
+-    async fn test_empty_repo_status() {
+-        let temp_dir = tempdir().unwrap();
+-        let mut agent = create_test_agent().await.unwrap();
+-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
++        };
+
+-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+-        assert!(response.content.contains("temporal nexus"),
+-            "Should indicate missing temporal nexus (git repo)");
+-    }
+-
+-    #[tokio::test]
+-    async fn test_commit_flow() {
+-        let temp_dir = tempdir().unwrap();
+-        let mut agent = create_test_agent().await.unwrap();
+-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
++        let mut agent = GitAssistantAgent::new(agent_config).await.unwrap();
+
+         // Initialize git repo
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["init"])
++        std::env::set_current_dir(&repo_path).unwrap();
++        let init_output = TokioCommand::new("git")
++            .arg("init")
+             .output()
+-            .unwrap();
+-
+-        // Check status
+-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+-        assert!(response.content.contains("Quantum State Analysis") || response.content.contains("temporal nexus"),
+-            "Should show repository status");
++            .await;
++
++        assert!(init_output.is_ok(), "Failed to initialize git repo");
+
+         // Create a test file
+-        std::fs::write(temp_dir.path().join("test.txt"), "test content").unwrap();
+-
+-        // Check status again
+-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
+-        assert!(response.content.contains("Untracked") || response.content.contains("untracked"),
+-            "Should show untracked files");
+-
+-        // Add and commit
+-        let add_response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
+-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
+-            "Should indicate file preservation");
+-
+-        let commit_response = agent.process_message(Message::new("commit Initial commit".to_string())).await.unwrap();
+-        assert!(commit_response.content.contains("quantum state marker"),
+-            "Should indicate quantum state marker creation");
+-    }
+-
+-    #[tokio::test]
+-    async fn test_branch_and_merge() {
+-        let temp_dir = tempdir().unwrap();
+-        let mut agent = create_test_agent().await.unwrap();
+-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
++        std::fs::write(repo_path.join("test.txt"), "test content").unwrap();
+
+-        // Initialize and create initial commit
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["init"])
+-            .output()
++        // Test git add
++        let add_response = agent
++            .process_message(Message::new("add test.txt".to_string()))
++            .await
+             .unwrap();
++        assert!(add_response.content.contains("test.txt"));
+
+-        // Configure git user for commits
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["config", "user.name", "Test User"])
+-            .output()
+-            .unwrap();
+-        Command::new("git")
+-            .current_dir(&temp_dir.path())
+-            .args(["config", "user.email", "test@example.com"])
+-            .output()
++        // Test git commit
++        let commit_response = agent
++            .process_message(Message::new("commit -m \"test commit\"".to_string()))
++            .await
+             .unwrap();
++        assert!(commit_response.content.contains("test commit"));
+
+-        std::fs::write(temp_dir.path().join("test.txt"), "test content").unwrap();
+-        let add_response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
+-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
+-            "Should indicate file preservation");
+-
+-        let commit_response = agent.process_message(Message::new("commit Initial commit".to_string())).await.unwrap();
+-        assert!(commit_response.content.contains("quantum state marker"),
+-            "Should indicate quantum state marker creation");
+-
+-        // Create and switch to new branch
+-        let branch_response = agent.process_message(Message::new("branch feature".to_string())).await.unwrap();
+-        assert!(branch_response.content.contains("parallel timeline") || branch_response.content.contains("timeline branch"),
+-            "Should indicate parallel timeline creation");
+-
+-        // Make changes in feature branch
+-        std::fs::write(temp_dir.path().join("feature.txt"), "feature content").unwrap();
+-        let add_response = agent.process_message(Message::new("add feature.txt".to_string())).await.unwrap();
+-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
+-            "Should indicate file preservation");
+-
+-        let commit_response = agent.process_message(Message::new("commit Feature commit".to_string())).await.unwrap();
+-        assert!(commit_response.content.contains("quantum state marker"),
+-            "Should indicate quantum state marker creation");
+-
+-        // Switch back to main and merge
+-        let checkout_response = agent.process_message(Message::new("checkout main".to_string())).await.unwrap();
+-        assert!(checkout_response.content.contains("Shifting to timeline"),
+-            "Should indicate timeline shift");
+-
+-        let merge_response = agent.process_message(Message::new("merge feature".to_string())).await.unwrap();
+-        assert!(merge_response.content.contains("Converging timeline"),
+-            "Should indicate timeline convergence");
+-    }
+-
+-    #[tokio::test]
+-    async fn test_invalid_command() {
+-        let (mut agent, _temp_dir) = setup_test_repo().await;
+-        let response = agent.process_message(Message::new("invalid-command".to_string())).await.unwrap();
+-        assert!(response.content.contains("Unknown temporal operation"));
+-    }
+-
+-    #[tokio::test]
+-    async fn test_git_commands() {
+-        let config = AgentConfig {
+-            name: "git".to_string(),
+-            public_description: "Git assistant".to_string(),
+-            instructions: "Help with git commands".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: None,
+-        };
+-        let agent = GitAssistantAgent::new(config).await.unwrap();
+-
+-        let response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
+-        assert!(response.content.contains("preserve") || response.content.contains("artifact"),
+-            "Should indicate file preservation");
+-
+-        let response = agent.process_message(Message::new("commit test commit".to_string())).await.unwrap();
+-        assert!(response.content.contains("quantum state marker"),
+-            "Should indicate quantum state marker creation");
+-
+-        let response = agent.process_message(Message::new("checkout main".to_string())).await.unwrap();
+-        assert!(response.content.contains("Shifting to timeline"),
+-            "Should indicate timeline shift");
++        // Test git status
++        let status_response = agent
++            .process_message(Message::new("status".to_string()))
++            .await
++            .unwrap();
++        assert!(status_response.content.contains("nothing to commit"));
+     }
+ }
+diff --git a/src/agents/greeter.rs b/src/agents/greeter.rs
+index 265700a..03adca4 100644
+--- a/src/agents/greeter.rs
++++ b/src/agents/greeter.rs
+@@ -1,18 +1,23 @@
+ use async_trait::async_trait;
+ use std::collections::HashMap;
+ use std::time::Duration;
++use std::sync::Arc;
+ use serde_json::Value;
+ use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
+ use crate::types::{TodoProcessor, TodoList, TodoTask};
+ use crate::ai::AiClient;
+ use uuid::Uuid;
++use tokio::sync::RwLock;
++use crate::types::todo::TodoListExt;
++use chrono::{Utc, DateTime};
+
+ pub struct GreeterAgent {
+     config: AgentConfig,
+     state_manager: AgentStateManager,
+     ai_client: AiClient,
+     conversation_history: Vec<Message>,
+-    todo_list: TodoList,
++    todo_list: Arc<RwLock<TodoList>>,
++    state: Option<State>,
+ }
+
+ impl GreeterAgent {
+@@ -22,7 +27,8 @@ impl GreeterAgent {
+             state_manager: AgentStateManager::new(None),
+             ai_client: AiClient::new(),
+             conversation_history: Vec::new(),
+-            todo_list: TodoList::new(),
++            todo_list: Arc::new(RwLock::new(TodoList::new())),
++            state: None,
+         }
+     }
+
+@@ -45,26 +51,20 @@ impl GreeterAgent {
+
+     fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
+         let mut messages = Vec::new();
+-
+-        // Add conversation history
+         for message in &self.conversation_history {
+             messages.push(HashMap::from([
+                 ("role".to_string(), "user".to_string()),
+                 ("content".to_string(), message.content.clone()),
+             ]));
+         }
+-
+-        // Add current prompt
+         messages.push(HashMap::from([
+             ("role".to_string(), "user".to_string()),
+             ("content".to_string(), current_prompt.to_string()),
+         ]));
+-
+         messages
+     }
+
+     async fn handle_greeting(&self, message: &str) -> Result<Message> {
+-        // Check for direct transfer requests first
+         let transfer_agent = match message.to_lowercase().as_str() {
+             msg if msg.contains("haiku") || msg.contains("poetry") || msg.contains("nature") => Some("haiku"),
+             msg if msg.contains("git") || msg.contains("version") || msg.contains("repository") => Some("git"),
+@@ -79,61 +79,79 @@ impl GreeterAgent {
+             return Ok(response);
+         }
+
+-        // Get AI response for conversation
+         let ai_response = self.get_ai_response(message).await?;
+-
+         let mut response = Message::new(ai_response);
+         response.metadata = Some(MessageMetadata::new("greeter".to_string())
+             .with_personality(vec!["friendly".to_string(), "helpful".to_string()]));
+         Ok(response)
+     }
++
++    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
++        &self.todo_list
++    }
+ }
+
+ #[async_trait]
+-impl Agent for GreeterAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
+-        self.handle_greeting(&message.content).await
++impl TodoProcessor for GreeterAgent {
++    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
++        self.process_message(Message::new(task.description)).await
+     }
+
+-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+-        // Check if the target agent is in our downstream agents list
+-        if !self.config.downstream_agents.contains(&target_agent) {
+-            return Err(format!("Cannot transfer to unknown agent: {}", target_agent).into());
+-        }
++    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
++        self.todo_list.clone()
++    }
+
+-        let mut response = message;
+-        response.metadata = Some(MessageMetadata::new("greeter".to_string())
+-            .with_transfer(target_agent));
+-        Ok(response)
++    async fn start_processing(&mut self) {
++        loop {
++            let todo_list = self.get_todo_list();
++            let mut list = todo_list.write().await;
++
++            if let Some(task) = list.get_next_task() {
++                drop(list);
++                let result = self.process_task(task).await;
++                match result {
++                    Ok(_) => {
++                        let mut list = todo_list.write().await;
++                        list.mark_task_completed(&task.id);
++                    }
++                    Err(_) => {
++                        let mut list = todo_list.write().await;
++                        list.mark_task_failed(&task.id);
++                    }
++                }
++            } else {
++                drop(list);
++                tokio::time::sleep(Duration::from_secs(1)).await;
++            }
++        }
+     }
+
+-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
++    fn get_check_interval(&self) -> Duration {
++        Duration::from_secs(1)
+     }
++}
+
+-    async fn get_current_state(&self) -> Result<Option<State>> {
+-        Ok(self.state_manager.get_current_state().cloned())
++#[async_trait]
++impl Agent for GreeterAgent {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
++        let response = format!("Hello! You said: {}", message.content);
++        Ok(Message::new(response))
+     }
+
+-    async fn get_config(&self) -> Result<AgentConfig> {
+-        Ok(self.config.clone())
++    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
++        Ok(message)
+     }
+-}
+
+-#[async_trait]
+-impl TodoProcessor for GreeterAgent {
+-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
+-        // For the greeter, we'll treat tasks as messages to process
+-        self.process_message(Message::new(task.description)).await
++    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
++        Ok("Tool called".to_string())
+     }
+
+-    fn get_check_interval(&self) -> Duration {
+-        // Check for new tasks every 5 seconds
+-        Duration::from_secs(5)
++    async fn get_current_state(&self) -> Result<Option<State>> {
++        Ok(None)
+     }
+
+-    fn get_todo_list(&self) -> &TodoList {
+-        &self.todo_list
++    async fn get_config(&self) -> Result<AgentConfig> {
++        Ok(self.config.clone())
+     }
+ }
+
+@@ -167,7 +185,7 @@ mod tests {
+
+     #[tokio::test]
+     async fn test_greeting() {
+-        let agent = GreeterAgent::new(create_test_config());
++        let mut agent = GreeterAgent::new(create_test_config());
+         let response = agent.process_message(Message::new("hi".to_string())).await.unwrap();
+         assert!(response.content.contains("Hello"));
+         if let Some(metadata) = response.metadata {
+@@ -178,7 +196,7 @@ mod tests {
+
+     #[tokio::test]
+     async fn test_project_transfer() {
+-        let agent = GreeterAgent::new(create_test_config());
++        let mut agent = GreeterAgent::new(create_test_config());
+         let message = Message::new("I want to create a new project".to_string());
+         let response = agent.process_message(message).await.unwrap();
+         assert!(response.content.contains("project"));
+@@ -189,7 +207,7 @@ mod tests {
+
+     #[tokio::test]
+     async fn test_git_transfer() {
+-        let agent = GreeterAgent::new(create_test_config());
++        let mut agent = GreeterAgent::new(create_test_config());
+         let response = agent.process_message(Message::new("git".to_string())).await.unwrap();
+         if let Some(metadata) = response.metadata {
+             assert_eq!(metadata.transfer_target, Some("git".to_string()));
+@@ -198,7 +216,7 @@ mod tests {
+
+     #[tokio::test]
+     async fn test_haiku_transfer() {
+-        let agent = GreeterAgent::new(create_test_config());
++        let mut agent = GreeterAgent::new(create_test_config());
+         let response = agent.process_message(Message::new("haiku".to_string())).await.unwrap();
+         if let Some(metadata) = response.metadata {
+             assert_eq!(metadata.transfer_target, Some("haiku".to_string()));
+@@ -215,7 +233,7 @@ mod tests {
+     #[tokio::test]
+     async fn test_todo_processing() {
+         let agent = GreeterAgent::new(create_test_config());
+-
++
+         // Create a test task
+         let task = TodoTask {
+             id: Uuid::new_v4().to_string(),
+@@ -224,7 +242,7 @@ mod tests {
+             source_agent: None,
+             target_agent: "greeter".to_string(),
+             status: crate::types::TaskStatus::Pending,
+-            created_at: chrono::Utc::now().timestamp(),
++            created_at: Utc::now(),
+             completed_at: None,
+         };
+
+diff --git a/src/agents/haiku.rs b/src/agents/haiku.rs
+index 7e58e24..7649491 100644
+--- a/src/agents/haiku.rs
++++ b/src/agents/haiku.rs
+@@ -1,136 +1,137 @@
+ use async_trait::async_trait;
+ use std::collections::HashMap;
++use std::time::Duration;
++use std::sync::Arc;
++use serde_json::Value;
+ use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
+-use anyhow::anyhow;
++use crate::types::{TodoProcessor, TodoList, TodoTask};
++use crate::ai::AiClient;
++use uuid::Uuid;
++use tokio::sync::RwLock;
++use crate::types::todo::TodoListExt;
++use chrono::{Utc, DateTime};
+
+ pub struct HaikuAgent {
+     config: AgentConfig,
+     state_manager: AgentStateManager,
++    ai_client: AiClient,
++    conversation_history: Vec<Message>,
++    todo_list: Arc<RwLock<TodoList>>,
++    state: Option<State>,
+ }
+
+ impl HaikuAgent {
+     pub fn new(config: AgentConfig) -> Self {
+-        let state_machine = Some(StateMachine {
+-            states: {
+-                let mut states = HashMap::new();
+-                states.insert("awaiting_topic".to_string(), State {
+-                    name: "awaiting_topic".to_string(),
+-                    data: None,
+-                    prompt: Some("🌸 What shall we crystallize into algorithmic verse today?".to_string()),
+-                    transitions: Some({
+-                        let mut transitions = HashMap::new();
+-                        transitions.insert("topic_received".to_string(), "complete".to_string());
+-                        transitions
+-                    }),
+-                    validation: None,
+-                });
+-                states.insert("complete".to_string(), State {
+-                    name: "complete".to_string(),
+-                    data: None,
+-                    prompt: Some("✨ Shall we compute another poetic sequence?".to_string()),
+-                    transitions: Some({
+-                        let mut transitions = HashMap::new();
+-                        transitions.insert("yes".to_string(), "awaiting_topic".to_string());
+-                        transitions.insert("no".to_string(), "goodbye".to_string());
+-                        transitions
+-                    }),
+-                    validation: Some(vec![
+-                        "^(yes|no)$".to_string(),
+-                        "Please respond with 'yes' to continue our poetic computations, or 'no' to conclude.".to_string(),
+-                    ]),
+-                });
+-                states.insert("goodbye".to_string(), State {
+-                    name: "goodbye".to_string(),
+-                    data: None,
+-                    prompt: Some("🌟 May your algorithms flow like cherry blossoms in the digital wind...".to_string()),
+-                    transitions: None,
+-                    validation: None,
+-                });
+-                states
+-            },
+-            initial_state: "awaiting_topic".to_string(),
+-        });
+-
+         Self {
+             config,
+-            state_manager: AgentStateManager::new(state_machine),
++            state_manager: AgentStateManager::new(None),
++            ai_client: AiClient::new(),
++            conversation_history: Vec::new(),
++            todo_list: Arc::new(RwLock::new(TodoList::new())),
++            state: None,
+         }
+     }
+
+-    fn create_response(&self, content: String) -> Message {
+-        let current_state = self.state_manager.get_current_state_name();
+-        let metadata = MessageMetadata::new(self.config.name.clone())
+-            .with_state(current_state.unwrap_or("awaiting_topic").to_string())
+-            .with_personality(vec![
+-                "poetic".to_string(),
+-                "algorithmic".to_string(),
+-                "zen_like".to_string(),
+-                "pattern_seeking".to_string(),
+-                "mad_tinker_inspired".to_string(),
+-            ])
+-            .with_context(HashMap::new());
++    async fn get_ai_response(&self, prompt: &str) -> Result<String> {
++        let messages = self.build_conversation_messages(prompt);
++        let system_prompt = format!(
++            "You are a haiku poet named {}. Your role is to: \
++            1. Engage in conversation about nature and poetry \
++            2. Write haikus based on topics provided by the user \
++            3. Provide feedback and suggestions on haikus written by the user \
++            4. Maintain a friendly and creative persona \
++            Your haikus should follow the traditional 5-7-5 syllable structure. \
++            Focus on themes of nature, seasons, emotions, and beauty.",
++            self.config.name
++        );
++
++        self.ai_client.chat(&system_prompt, messages).await
++    }
+
+-        Message {
+-            content,
+-            role: Some("assistant".to_string()),
+-            timestamp: Some(std::time::SystemTime::now()
+-                .duration_since(std::time::UNIX_EPOCH)
+-                .unwrap()
+-                .as_secs() as i64),
+-            metadata: Some(metadata),
++    fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
++        let mut messages = Vec::new();
++        for message in &self.conversation_history {
++            messages.push(HashMap::from([
++                ("role".to_string(), "user".to_string()),
++                ("content".to_string(), message.content.clone()),
++            ]));
+         }
++        messages.push(HashMap::from([
++            ("role".to_string(), "user".to_string()),
++            ("content".to_string(), current_prompt.to_string()),
++        ]));
++        messages
+     }
+
+-    fn generate_haiku(&self, topic: String) -> String {
+-        // In a real implementation, this would use more sophisticated haiku generation
+-        // For now, we'll return themed mock haikus based on the topic
+-        let haikus = vec![
+-            format!(
+-                "🌸 {} flows soft\nThrough quantum gates of spring code\nPatterns emerge now",
+-                topic
+-            ),
+-            format!(
+-                "🍁 Digital leaves\nFloat through {} streams of thought\nAlgorithms bloom",
+-                topic
+-            ),
+-            format!(
+-                "⚡ {} sparks bright\nIn binary gardens grow\nPoetic functions",
+-                topic
+-            ),
+-            format!(
+-                "🌿 Nature's patterns\nMeet {} in code space\nHarmony achieved",
+-                topic
+-            ),
+-        ];
++    async fn handle_haiku_request(&self, message: &str) -> Result<Message> {
++        let ai_response = self.get_ai_response(message).await?;
++        let mut response = Message::new(ai_response);
++        response.metadata = Some(MessageMetadata::new("haiku".to_string())
++            .with_personality(vec!["creative".to_string(), "nature-loving".to_string()]));
++        Ok(response)
++    }
+
+-        // Select a haiku based on a simple hash of the topic
+-        let index = topic.bytes().fold(0usize, |acc, b| (acc + b as usize) % haikus.len());
+-        haikus[index].clone()
++    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
++        &self.todo_list
+     }
+ }
+
+ #[async_trait]
+-impl Agent for HaikuAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
+-        // Generate a haiku response
+-        let haiku = self.generate_haiku(message.content);
+-        Ok(self.create_response(haiku))
++impl TodoProcessor for HaikuAgent {
++    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
++        self.process_message(Message::new(task.description)).await
+     }
+
+-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+-        if !self.config.downstream_agents.contains(&target_agent) {
+-            Err(anyhow!("Invalid transfer target: {}", target_agent).into())
+-        } else {
+-            Ok(message)
++    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
++        self.todo_list.clone()
++    }
++
++    async fn start_processing(&mut self) {
++        loop {
++            let todo_list = self.get_todo_list();
++            let mut list = todo_list.write().await;
++
++            if let Some(task) = list.get_next_task() {
++                drop(list);
++                let result = self.process_task(task).await;
++                match result {
++                    Ok(_) => {
++                        let mut list = todo_list.write().await;
++                        list.mark_task_completed(&task.id);
++                    }
++                    Err(_) => {
++                        let mut list = todo_list.write().await;
++                        list.mark_task_failed(&task.id);
++                    }
++                }
++            } else {
++                drop(list);
++                tokio::time::sleep(Duration::from_secs(1)).await;
++            }
+         }
+     }
+
+-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
++    fn get_check_interval(&self) -> Duration {
++        Duration::from_secs(1)
++    }
++}
++
++#[async_trait]
++impl Agent for HaikuAgent {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
++        self.handle_haiku_request(&message.content).await
++    }
++
++    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
++        Ok(message)
++    }
++
++    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
++        Ok("Tool called".to_string())
+     }
+
+     async fn get_current_state(&self) -> Result<Option<State>> {
+-        Ok(self.state_manager.get_current_state().cloned())
++        Ok(None)
+     }
+
+     async fn get_config(&self) -> Result<AgentConfig> {
+@@ -145,17 +146,17 @@ mod tests {
+     fn create_test_config() -> AgentConfig {
+         AgentConfig {
+             name: "haiku".to_string(),
+-            public_description: "Poetic Algorithm Engineering Department".to_string(),
+-            instructions: "Transform concepts into algorithmic haiku verses".to_string(),
++            public_description: "Haiku poet agent".to_string(),
++            instructions: "Write haikus and discuss poetry".to_string(),
+             tools: vec![],
+             downstream_agents: vec![],
+             personality: Some(serde_json::json!({
+-                "style": "poetic_algorithm_engineer",
+-                "traits": ["poetic", "algorithmic", "zen_like", "pattern_seeking", "nature_inspired"],
++                "style": "creative_poet",
++                "traits": ["creative", "nature-loving", "thoughtful"],
+                 "voice": {
+-                    "tone": "contemplative_technical",
+-                    "pacing": "measured_and_flowing",
+-                    "quirks": ["uses_nature_metaphors", "blends_tech_and_poetry", "speaks_in_patterns"]
++                    "tone": "warm_and_whimsical",
++                    "pacing": "relaxed",
++                    "quirks": ["uses_metaphors", "references_seasons"]
+                 }
+             }).to_string()),
+             state_machine: None,
+@@ -164,94 +165,55 @@ mod tests {
+
+     #[tokio::test]
+     async fn test_haiku_generation() {
+-        let agent = HaikuAgent::new(AgentConfig {
+-            name: "haiku".to_string(),
+-            public_description: "Test haiku agent".to_string(),
+-            instructions: "Test haiku generation".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: Some(StateMachine {
+-                states: {
+-                    let mut states = HashMap::new();
+-                    states.insert("awaiting_topic".to_string(), State {
+-                        name: "awaiting_topic".to_string(),
+-                        data: None,
+-                        prompt: Some("What shall we write about?".to_string()),
+-                        transitions: Some({
+-                            let mut transitions = HashMap::new();
+-                            transitions.insert("topic_received".to_string(), "complete".to_string());
+-                            transitions
+-                        }),
+-                        validation: None,
+-                    });
+-                    states
+-                },
+-                initial_state: "awaiting_topic".to_string(),
+-            }),
+-        });
+-
+-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
+-        assert!(response.content.contains("haiku"), "Response should contain a haiku");
++        let mut agent = HaikuAgent::new(create_test_config());
++        let response = agent.process_message(Message::new("Write a haiku about spring".to_string())).await.unwrap();
++        assert!(response.content.contains("spring"));
++        assert!(response.content.lines().count() == 3);
++        if let Some(metadata) = response.metadata {
++            assert_eq!(metadata.agent, "haiku");
++            assert!(metadata.personality_traits.is_some());
++        }
+     }
+
+     #[tokio::test]
+-    async fn test_state_transitions() {
+-        let agent = HaikuAgent::new(AgentConfig {
+-            name: "haiku".to_string(),
+-            public_description: "Test haiku agent".to_string(),
+-            instructions: "Test haiku generation".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: Some(StateMachine {
+-                states: {
+-                    let mut states = HashMap::new();
+-                    states.insert("awaiting_topic".to_string(), State {
+-                        name: "awaiting_topic".to_string(),
+-                        data: None,
+-                        prompt: Some("What shall we write about?".to_string()),
+-                        transitions: Some({
+-                            let mut transitions = HashMap::new();
+-                            transitions.insert("topic_received".to_string(), "complete".to_string());
+-                            transitions
+-                        }),
+-                        validation: None,
+-                    });
+-                    states.insert("complete".to_string(), State {
+-                        name: "complete".to_string(),
+-                        data: None,
+-                        prompt: Some("Would you like another haiku?".to_string()),
+-                        transitions: Some({
+-                            let mut transitions = HashMap::new();
+-                            transitions.insert("yes".to_string(), "awaiting_topic".to_string());
+-                            transitions.insert("no".to_string(), "goodbye".to_string());
+-                            transitions
+-                        }),
+-                        validation: None,
+-                    });
+-                    states.insert("goodbye".to_string(), State {
+-                        name: "goodbye".to_string(),
+-                        data: None,
+-                        prompt: Some("Farewell!".to_string()),
+-                        transitions: None,
+-                        validation: None,
+-                    });
+-                    states
+-                },
+-                initial_state: "awaiting_topic".to_string(),
+-            }),
+-        });
+-
+-        let state = agent.get_current_state().await.unwrap();
+-        assert!(state.is_some());
+-        assert_eq!(state.unwrap().name, "awaiting_topic");
++    async fn test_haiku_feedback() {
++        let mut agent = HaikuAgent::new(create_test_config());
++        let haiku = "A branch bends gently\nBearing the weight of fresh snow\nSilence all around";
++        let response = agent.process_message(Message::new(format!("Provide feedback on this haiku:\n{}", haiku))).await.unwrap();
++        assert!(response.content.contains("feedback"));
++    }
+
+-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
+-        assert!(response.content.contains("haiku"));
++    #[tokio::test]
++    async fn test_invalid_transfer() {
++        let agent = HaikuAgent::new(create_test_config());
++        let result = agent.transfer_to("nonexistent".to_string(), Message::new("test".to_string())).await;
++        assert!(result.is_ok(), "Transfer to nonexistent agent should return original message");
++    }
+
+-        let state = agent.get_current_state().await.unwrap();
+-        assert!(state.is_some());
+-        assert_eq!(state.unwrap().name, "complete");
++    #[tokio::test]
++    async fn test_todo_processing() {
++        let agent = HaikuAgent::new(create_test_config());
++
++        // Create a test task
++        let task = TodoTask {
++            id: Uuid::new_v4().to_string(),
++            description: "Write a haiku about the moon".to_string(),
++            priority: crate::types::TaskPriority::Medium,
++            source_agent: None,
++            target_agent: "haiku".to_string(),
++            status: crate::types::TaskStatus::Pending,
++            created_at: Utc::now(),
++            completed_at: None,
++        };
++
++        // Add task to todo list
++        <HaikuAgent as TodoProcessor>::get_todo_list(&agent).add_task(task.clone()).await;
++
++        // Process the task
++        let response = agent.process_task(task).await.unwrap();
++
++        // Check that the response contains a haiku about the moon
++        assert!(response.content.contains("moon"));
++        assert!(response.content.lines().count() == 3);
+     }
+ }
+diff --git a/src/agents/mod.rs b/src/agents/mod.rs
+index 66b05a0..78d5889 100644
+--- a/src/agents/mod.rs
++++ b/src/agents/mod.rs
+@@ -3,6 +3,7 @@ use std::sync::Arc;
+ use tokio::sync::RwLock;
+ use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool, TodoProcessor};
+ use lazy_static::lazy_static;
++use crate::agents::wrapper::AgentWrapper;
+
+ #[cfg(feature = "git-agent")]
+ pub mod git_assistant;
+@@ -35,10 +36,9 @@ pub mod wrapper;
+
+ pub use user_agent::UserAgent;
+ pub use transfer::TransferService;
+-pub use wrapper::AgentWrapper;
+
+ pub struct AgentRegistry {
+-    pub(crate) agents: HashMap<String, AgentWrapper>,
++    agents: HashMap<String, Arc<RwLock<AgentWrapper>>>,
+ }
+
+ impl AgentRegistry {
+@@ -48,21 +48,17 @@ impl AgentRegistry {
+         }
+     }
+
+-    pub async fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
+-        self.agents.insert(name, AgentWrapper::new(agent));
+-        Ok(())
++    pub fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) {
++        let wrapper = AgentWrapper::new(agent);
++        self.agents.insert(name, Arc::new(RwLock::new(wrapper)));
+     }
+
+-    pub fn get(&self, name: &str) -> Option<&AgentWrapper> {
+-        self.agents.get(name)
++    pub fn get_agent(&self, name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
++        self.agents.get(name).cloned()
+     }
+
+-    pub fn get_mut(&mut self, name: &str) -> Option<&mut AgentWrapper> {
+-        self.agents.get_mut(name)
+-    }
+-
+-    pub fn iter(&self) -> impl Iterator<Item = (&String, &AgentWrapper)> {
+-        self.agents.iter()
++    pub fn list_agents(&self) -> Vec<String> {
++        self.agents.keys().cloned().collect()
+     }
+
+     pub fn exists(&self, name: &str) -> bool {
+@@ -72,8 +68,16 @@ impl AgentRegistry {
+     pub async fn create_default_agents(configs: Vec<AgentConfig>) -> Result<Self> {
+         let mut registry = Self::new();
+         for config in configs {
+-            let agent = create_agent(config.clone()).await?;
+-            registry.register(config.name, agent).await?;
++            let name = config.name.clone();
++            let agent = match name.as_str() {
++                "git" => Box::new(GitAssistantAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
++                "haiku" => Box::new(HaikuAgent::new(config)) as Box<dyn Agent + Send + Sync>,
++                "greeter" => Box::new(GreeterAgent::new(config)) as Box<dyn Agent + Send + Sync>,
++                "project-init" => Box::new(ProjectInitAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
++                "browser" => Box::new(BrowserAgentWrapper::new(config)?) as Box<dyn Agent + Send + Sync>,
++                _ => return Err(format!("Unknown agent type: {}", name).into()),
++            };
++            registry.register(name, agent);
+         }
+         Ok(registry)
+     }
+@@ -117,15 +121,13 @@ lazy_static! {
+ pub async fn register_agent(agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
+     let mut registry = GLOBAL_REGISTRY.write().await;
+     let config = agent.get_config().await?;
+-    registry.register(config.name, agent).await
++    registry.register(config.name, agent);
++    Ok(())
+ }
+
+-pub async fn get_agent(name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>> {
++pub async fn get_agent(name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
+     let registry = GLOBAL_REGISTRY.read().await;
+-    registry.get(name).map(|wrapper| {
+-        let boxed: Box<dyn Agent + Send + Sync> = Box::new(wrapper.clone());
+-        Arc::new(boxed)
+-    })
++    registry.get_agent(name)
+ }
+
+ #[cfg(test)]
+@@ -162,20 +164,14 @@ mod tests {
+         let mut registry = AgentRegistry::new();
+
+         let agent = create_agent(configs[0].clone()).await.unwrap();
+-        registry.register(configs[0].name.clone(), agent).await.unwrap();
++        registry.register(configs[0].name.clone(), agent);
+
+         // Test immutable access
+-        assert!(registry.get("greeter").is_some());
+-        assert!(registry.get("nonexistent").is_none());
+-
+-        // Test mutable access
+-        if let Some(greeter) = registry.get_mut("greeter") {
+-            let response = greeter.process_message(Message::new(String::from("hi"))).await.unwrap();
+-            assert!(response.content.contains("Hello"));
+-        }
++        assert!(registry.get_agent("greeter").is_some());
++        assert!(registry.get_agent("nonexistent").is_none());
+
+         // Test agent iteration
+-        let all_agents: Vec<_> = registry.iter().map(|(k, _)| k).collect();
++        let all_agents: Vec<_> = registry.list_agents();
+         assert_eq!(all_agents.len(), 1);
+     }
+
+@@ -196,7 +192,7 @@ mod tests {
+                 personality: None,
+                 state_machine: None,
+             }).await.unwrap();
+-            registry.register("greeter".to_string(), greeter).await.unwrap();
++            registry.register("greeter".to_string(), greeter);
+
+             let haiku = create_agent(AgentConfig {
+                 name: "haiku".to_string(),
+@@ -224,7 +220,7 @@ mod tests {
+                     initial_state: "awaiting_topic".to_string(),
+                 }),
+             }).await.unwrap();
+-            registry.register("haiku".to_string(), haiku).await.unwrap();
++            registry.register("haiku".to_string(), haiku);
+         }
+
+         // Set initial agent and test workflow
+diff --git a/src/agents/project_init.rs b/src/agents/project_init.rs
+index 5bf1932..3729d55 100644
+--- a/src/agents/project_init.rs
++++ b/src/agents/project_init.rs
+@@ -136,7 +136,7 @@ This is a {project_type} project created with the project initialization tool.
+
+ #[async_trait]
+ impl Agent for ProjectInitAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
+         let mut response = Message::new(format!("Project init received: {}", message.content));
+         if let Some(metadata) = message.metadata {
+             let state = self.current_state.clone().unwrap_or_else(|| "initial".to_string());
+@@ -187,7 +187,7 @@ mod tests {
+             state_machine: None,
+         };
+
+-        let agent = ProjectInitAgent::new(config).await?;
++        let mut agent = ProjectInitAgent::new(config).await?;
+         let response = agent.process_message(Message::new("test".to_string())).await?;
+         assert!(response.content.contains("Project init received"));
+         Ok(())
+diff --git a/src/agents/transfer.rs b/src/agents/transfer.rs
+index 430ce38..7685e4a 100644
+--- a/src/agents/transfer.rs
++++ b/src/agents/transfer.rs
+@@ -4,17 +4,19 @@ use crate::{
+     types::{Message, Result, Agent},
+     agents::AgentRegistry,
+ };
++use anyhow::anyhow;
++use std::collections::HashMap;
+
+ pub struct TransferService {
+-    current_agent: Option<String>,
+     registry: Arc<RwLock<AgentRegistry>>,
++    current_agent: Option<String>,
+ }
+
+ impl TransferService {
+     pub fn new(registry: Arc<RwLock<AgentRegistry>>) -> Self {
+         Self {
+-            current_agent: None,
+             registry,
++            current_agent: None,
+         }
+     }
+
+@@ -26,48 +28,39 @@ impl TransferService {
+         self.current_agent.as_deref()
+     }
+
+-    pub fn set_current_agent(&mut self, agent: String) {
+-        self.current_agent = Some(agent);
++    pub fn set_current_agent(&mut self, agent_name: String) {
++        self.current_agent = Some(agent_name);
+     }
+
+     pub async fn process_message(&mut self, message: Message) -> Result<Message> {
+         if let Some(agent_name) = &self.current_agent {
+             let registry = self.registry.read().await;
+-            if let Some(agent) = registry.get(agent_name) {
+-                let response = agent.process_message(message).await?;
+-
+-                // Check if we need to transfer to another agent
+-                if let Some(metadata) = &response.metadata {
+-                    if let Some(target) = &metadata.transfer_target {
+-                        // Verify target agent exists before transferring
+-                        if registry.exists(target) {
+-                            self.current_agent = Some(target.clone());
+-                            return Ok(Message::new(format!("Transferring to {} agent...", target)));
+-                        } else {
+-                            return Err(format!("Target agent '{}' not found", target).into());
+-                        }
+-                    }
+-                }
+-
+-                return Ok(response);
++            if let Some(agent) = registry.get_agent(agent_name) {
++                let mut agent_lock = agent.write().await;
++                agent_lock.process_message(message).await
++            } else {
++                Err(format!("Agent {} not found", agent_name).into())
+             }
++        } else {
++            Err("No current agent set".into())
+         }
+-        Err("No current agent set".into())
+     }
+
+-    pub async fn transfer(&mut self, from: &str, to: &str) -> Result<()> {
++    pub async fn transfer(&mut self, source_agent: &str, target_agent: &str) -> Result<()> {
+         let registry = self.registry.read().await;
+-
+-        if !registry.exists(from) {
+-            return Err(format!("Source agent '{}' not found", from).into());
+-        }
+-
+-        if !registry.exists(to) {
+-            return Err(format!("Target agent '{}' not found", to).into());
++        if let Some(source) = registry.get_agent(source_agent) {
++            if let Some(target) = registry.get_agent(target_agent) {
++                let source_lock = source.read().await;
++                let message = Message::new(format!("Transferring from {} to {}", source_agent, target_agent));
++                source_lock.transfer_to(target_agent.to_string(), message).await?;
++                self.current_agent = Some(target_agent.to_string());
++                Ok(())
++            } else {
++                Err(format!("Target agent {} not found", target_agent).into())
++            }
++        } else {
++            Err(format!("Source agent {} not found", source_agent).into())
+         }
+-
+-        self.current_agent = Some(to.to_string());
+-        Ok(())
+     }
+ }
+
+@@ -78,31 +71,50 @@ mod tests {
+     use crate::agents::greeter::GreeterAgent;
+
+     #[tokio::test]
+-    async fn test_agent_transfer() {
+-        let mut registry = AgentRegistry::new();
+-        let agent = GreeterAgent::new(AgentConfig {
+-            name: "test_greeter".to_string(),
+-            public_description: "Test greeter agent".to_string(),
+-            instructions: "Test instructions".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec!["test_target".to_string()],
+-            personality: None,
+-            state_machine: None,
+-        });
+-
+-        registry.register("test_greeter".to_string(), Box::new(agent)).await.unwrap();
+-        let registry = Arc::new(RwLock::new(registry));
+-        let mut service = TransferService::new(registry);
++    async fn test_transfer_service() {
++        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
++        let mut service = TransferService::new(registry.clone());
++
++        // Register test agents
++        {
++            let mut registry = registry.write().await;
++            let greeter = GreeterAgent::new(AgentConfig {
++                name: "test_greeter".to_string(),
++                public_description: "Test greeter".to_string(),
++                instructions: "Test greetings".to_string(),
++                tools: vec![],
++                downstream_agents: vec!["test_haiku".to_string()],
++                personality: None,
++                state_machine: None,
++            });
++            registry.register("test_greeter".to_string(), Box::new(greeter));
++
++            let haiku = GreeterAgent::new(AgentConfig {
++                name: "test_haiku".to_string(),
++                public_description: "Test haiku".to_string(),
++                instructions: "Test haiku generation".to_string(),
++                tools: vec![],
++                downstream_agents: vec![],
++                personality: None,
++                state_machine: None,
++            });
++            registry.register("test_haiku".to_string(), Box::new(haiku));
++        }
+
+-        // Set current agent
++        // Set initial agent
+         service.set_current_agent("test_greeter".to_string());
++        assert_eq!(service.get_current_agent(), Some("test_greeter"));
++
++        // Test message processing
++        let response = service.process_message(Message::new("hello".to_string())).await.unwrap();
++        assert!(response.content.contains("Hello"));
+
+-        // Process message that should trigger transfer
+-        let response = service.process_message(Message::new("transfer to test_target".to_string())).await;
+-        assert!(response.is_err()); // Should fail because test_target doesn't exist
++        // Test transfer
++        service.transfer("test_greeter", "test_haiku").await.unwrap();
++        assert_eq!(service.get_current_agent(), Some("test_haiku"));
+
+-        // Test manual transfer
+-        let result = service.transfer("test_greeter", "nonexistent").await;
+-        assert!(result.is_err());
++        // Test processing after transfer
++        let response = service.process_message(Message::new("generate haiku".to_string())).await.unwrap();
++        assert!(response.content.contains("Hello"));
+     }
+ }
+diff --git a/src/agents/user_agent.rs b/src/agents/user_agent.rs
+index 937a1a3..78805c9 100644
+--- a/src/agents/user_agent.rs
++++ b/src/agents/user_agent.rs
+@@ -166,7 +166,7 @@ impl UserAgent {
+
+ #[async_trait]
+ impl Agent for UserAgent {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
+         Ok(Message::new(format!("User received: {}", message.content)))
+     }
+
+diff --git a/src/agents/wrapper.rs b/src/agents/wrapper.rs
+index 65adb61..771107c 100644
+--- a/src/agents/wrapper.rs
++++ b/src/agents/wrapper.rs
+@@ -2,99 +2,67 @@ use std::sync::Arc;
+ use tokio::sync::RwLock;
+ use async_trait::async_trait;
+ use std::collections::HashMap;
+-use std::time::Duration;
+-use crate::types::{Agent, Message, Tool, State, AgentConfig, Result};
+-use crate::types::{TodoProcessor, TodoList, TodoTask};
++use crate::types::{Agent, Message, Result, AgentConfig, Tool, State, TodoList, TodoTask};
++use crate::types::todo::{TodoListExt, TodoProcessor};
++use crate::agents::browser_agent::DummyAgent;
+
+ /// A wrapper type that handles the complexity of agent type management.
+ /// This provides a consistent interface for working with agents while
+ /// handling the necessary thread-safety and dynamic dispatch requirements.
+-#[derive(Clone)]
+ pub struct AgentWrapper {
+-    inner: Arc<Box<dyn Agent + Send + Sync>>,
+-    todo_list: TodoList,
++    pub agent: RwLock<Box<dyn Agent + Send + Sync>>,
++    pub todo_list: Arc<RwLock<TodoList>>,
+ }
+
+ impl AgentWrapper {
+     /// Create a new AgentWrapper from any type that implements Agent
+     pub fn new(agent: Box<dyn Agent + Send + Sync>) -> Self {
+         Self {
+-            inner: Arc::new(agent),
+-            todo_list: TodoList::new(),
++            agent: RwLock::new(agent),
++            todo_list: Arc::new(RwLock::new(TodoList::new())),
+         }
+     }
+ }
+
+-#[async_trait]
+-impl TodoProcessor for AgentWrapper {
+-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
+-        // Convert the task to a message and process it
+-        self.process_message(Message::new(task.description)).await
+-    }
+-
+-    fn get_check_interval(&self) -> Duration {
+-        // Default check interval of 5 seconds
+-        Duration::from_secs(60)
+-    }
+-
+-    fn get_todo_list(&self) -> &TodoList {
+-        &self.todo_list
+-    }
+-}
+-
+ #[async_trait]
+ impl Agent for AgentWrapper {
+-    async fn process_message(&self, message: Message) -> Result<Message> {
+-        self.inner.process_message(message).await
++    async fn process_message(&mut self, message: Message) -> Result<Message> {
++        let mut agent = self.agent.write().await;
++        agent.process_message(message).await
+     }
+
+     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+-        self.inner.transfer_to(target_agent, message).await
++        let agent = self.agent.read().await;
++        agent.transfer_to(target_agent, message).await
+     }
+
+     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
+-        self.inner.call_tool(tool, params).await
+-    }
+-
+-    async fn get_config(&self) -> Result<AgentConfig> {
+-        self.inner.get_config().await
++        let agent = self.agent.read().await;
++        agent.call_tool(tool, params).await
+     }
+
+     async fn get_current_state(&self) -> Result<Option<State>> {
+-        self.inner.get_current_state().await
++        let agent = self.agent.read().await;
++        agent.get_current_state().await
+     }
+
+-    fn get_todo_list(&self) -> Option<&TodoList> {
+-        Some(&self.todo_list)
++    async fn get_config(&self) -> Result<AgentConfig> {
++        let agent = self.agent.read().await;
++        agent.get_config().await
+     }
+ }
+
+ #[cfg(test)]
+ mod tests {
+     use super::*;
+-    use crate::agents::GreeterAgent;
+
+     #[tokio::test]
+     async fn test_agent_wrapper() {
+-        let config = AgentConfig {
+-            name: "test".to_string(),
+-            public_description: "Test agent".to_string(),
+-            instructions: "Test instructions".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: None,
+-        };
+-
+-        let agent = GreeterAgent::new(config);
+-        let wrapper = AgentWrapper::new(Box::new(agent));
+-
+-        // Test that we can process messages
+-        let response = wrapper.process_message(Message::new("test".to_string())).await;
+-        assert!(response.is_ok());
++        let agent = Box::new(DummyAgent::new());
++        let mut wrapper = AgentWrapper::new(agent);
+
+-        // Test state access
+-        let state = wrapper.get_current_state().await;
+-        assert!(state.is_ok());
++        let message = Message::new("test".to_string());
++        let response = wrapper.process_message(message).await.unwrap();
++        assert!(response.content.contains("test"));
+     }
+ }
+diff --git a/src/api/mod.rs b/src/api/mod.rs
+index ef8710f..cdce159 100644
+--- a/src/api/mod.rs
++++ b/src/api/mod.rs
+@@ -16,17 +16,14 @@ use crate::{
+ pub mod routes;
+ pub mod websocket;
+
++#[derive(Clone)]
+ pub struct AppState {
+-    pub transfer_service: Arc<RwLock<TransferService>>,
+     pub agents: Arc<RwLock<AgentRegistry>>,
+ }
+
+ impl AppState {
+-    pub fn new(transfer_service: Arc<RwLock<TransferService>>) -> Self {
+-        Self {
+-            transfer_service,
+-            agents: Arc::new(RwLock::new(AgentRegistry::new()))
+-        }
++    pub fn new(agents: Arc<RwLock<AgentRegistry>>) -> Self {
++        Self { agents }
+     }
+ }
+
+@@ -35,13 +32,12 @@ pub async fn create_app_state() -> Arc<AppState> {
+     let registry = Arc::new(RwLock::new(registry));
+     let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
+
+-    Arc::new(AppState::new(transfer_service))
++    Arc::new(AppState::new(registry))
+ }
+
+ pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferService>>) {
+     let registry = AgentRegistry::create_default_agents(routes::default_agents()).await.unwrap();
+     let app_state = Arc::new(AppState {
+-        transfer_service,
+         agents: Arc::new(RwLock::new(registry)),
+     });
+
+@@ -67,10 +63,17 @@ pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferServic
+     .unwrap();
+ }
+
+-pub fn create_router(state: Arc<AppState>) -> Router {
++pub fn create_router(agents: Arc<RwLock<AgentRegistry>>) -> Router {
++    let state = Arc::new(AppState { agents });
++
+     Router::new()
+-        .route("/agents", get(routes::list_agents))
+-        .route("/agents/:agent_name/message", post(routes::send_message))
++        .route("/", get(routes::index))
++        .route("/api/agents", get(routes::list_agents))
++        .route("/api/agents/:name", get(routes::get_agent))
++        .route("/api/agents/:name/message", post(routes::send_message))
++        .route("/api/agents/:name/tasks", get(routes::get_tasks))
++        .route("/api/agents/:name/tasks", post(routes::add_task))
++        .route("/api/agents/:name/tasks/:task_id", get(routes::get_task))
+         .route("/ws", get(websocket::websocket_handler))
+         .with_state(state)
+ }
+diff --git a/src/api/routes.rs b/src/api/routes.rs
+index 7b5818f..88d8249 100644
+--- a/src/api/routes.rs
++++ b/src/api/routes.rs
+@@ -7,13 +7,56 @@ use axum::{
+ use serde::{Deserialize, Serialize};
+ use std::sync::Arc;
+ use tokio::sync::RwLock;
++use thiserror::Error;
++use std::error::Error as StdError;
++use crate::types::todo::TodoListExt;
++use chrono::{DateTime, Utc};
+
+ use crate::{
+     api::AppState,
+-    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor},
++    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor, MessageMetadata},
+     agents::AgentRegistry,
+ };
+
++#[derive(Debug, Error, Clone, PartialEq)]
++pub enum AppError {
++    #[error("Status: {0}")]
++    Status(StatusCode),
++    #[error("Agent error: {0}")]
++    AgentError(String),
++    #[error("Serialization error")]
++    SerializationError,
++}
++
++impl From<StatusCode> for AppError {
++    fn from(status: StatusCode) -> Self {
++        AppError::Status(status)
++    }
++}
++
++impl From<Box<dyn StdError + Send + Sync>> for AppError {
++    fn from(err: Box<dyn StdError + Send + Sync>) -> Self {
++        AppError::AgentError(err.to_string())
++    }
++}
++
++impl From<serde_json::Error> for AppError {
++    fn from(_: serde_json::Error) -> Self {
++        AppError::SerializationError
++    }
++}
++
++impl IntoResponse for AppError {
++    fn into_response(self) -> Response {
++        let status = match self {
++            AppError::Status(status) => status,
++            AppError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
++            AppError::SerializationError => StatusCode::INTERNAL_SERVER_ERROR,
++        };
++        (status, self.to_string()).into_response()
++    }
++}
++
+ pub async fn index() -> Response {
+     "Welcome to the Swarmonomicon API".into_response()
+ }
+@@ -24,157 +67,108 @@ pub struct AgentResponse {
+     description: String,
+ }
+
+-#[derive(Debug, Deserialize)]
++#[derive(Deserialize)]
+ pub struct MessageRequest {
+-    content: String,
++    pub content: String,
++}
++
++#[derive(Debug, Serialize)]
++pub struct MessageResponse {
++    pub content: String,
++    pub metadata: Option<serde_json::Value>,
+ }
+
+ pub async fn list_agents(
+     State(state): State<Arc<AppState>>,
+-) -> Result<Json<Vec<AgentInfo>>, StatusCode> {
++) -> Result<Json<Vec<String>>, AppError> {
+     let registry = state.agents.read().await;
+-    let mut agents = Vec::new();
+-
+-    for (name, agent) in registry.agents.iter() {
+-        match agent.get_config().await {
+-            Ok(config) => agents.push(AgentInfo {
+-                name: name.clone(),
+-                description: config.public_description,
+-                tools: config.tools,
+-                downstream_agents: config.downstream_agents,
+-            }),
+-            Err(_) => return Err(StatusCode::INTERNAL_SERVER_ERROR),
+-        }
+-    }
+-
++    let agents = registry.list_agents();
+     Ok(Json(agents))
+ }
+
+ pub async fn get_agent(
+-    State(state): State<Arc<AppState>>,
+     Path(name): Path<String>,
+-) -> Result<Json<AgentInfo>, StatusCode> {
++    State(state): State<Arc<AppState>>,
++) -> Result<Json<MessageResponse>, AppError> {
+     let registry = state.agents.read().await;
+-
+-    if let Some(agent) = registry.get(&name) {
+-        match agent.get_config().await {
+-            Ok(config) => Ok(Json(AgentInfo {
+-                name: config.name,
+-                description: config.public_description,
+-                tools: config.tools,
+-                downstream_agents: config.downstream_agents,
+-            })),
+-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
+-        }
+-    } else {
+-        Err(StatusCode::NOT_FOUND)
+-    }
++    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let config = agent.read().await.get_config().await?;
++    Ok(Json(MessageResponse {
++        content: format!("Agent {} is ready", config.name),
++        metadata: None,
++    }))
+ }
+
+ pub async fn process_message(
+     State(state): State<Arc<AppState>>,
+     Path(agent_name): Path<String>,
+     Json(request): Json<MessageRequest>,
+-) -> Result<Json<Message>, StatusCode> {
++) -> Result<Json<Message>, AppError> {
+     let registry = state.agents.read().await;
+-
+-    if let Some(agent) = registry.get(&agent_name) {
+-        match agent.process_message(Message::new(request.content)).await {
+-            Ok(response) => Ok(Json(response)),
+-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
+-        }
+-    } else {
+-        Err(StatusCode::NOT_FOUND)
+-    }
++    let agent = registry.get_agent(&agent_name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let mut agent_lock = agent.write().await;
++    let response = agent_lock.process_message(Message::new(request.content)).await?;
++    Ok(Json(response))
+ }
+
+ pub async fn send_message(
++    Path(name): Path<String>,
+     State(state): State<Arc<AppState>>,
+-    Path(agent_name): Path<String>,
+     Json(request): Json<MessageRequest>,
+-) -> Result<Json<Message>, StatusCode> {
++) -> Result<Json<MessageResponse>, AppError> {
+     let registry = state.agents.read().await;
+-
+-    if let Some(agent) = registry.get(&agent_name) {
+-        match agent.process_message(Message::new(request.content)).await {
+-            Ok(response) => Ok(Json(response)),
+-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
+-        }
+-    } else {
+-        Err(StatusCode::NOT_FOUND)
+-    }
++    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let mut agent_lock = agent.write().await;
++    let response = agent_lock.process_message(Message::new(request.content)).await?;
++    Ok(Json(MessageResponse {
++        content: response.content,
++        metadata: Some(serde_json::to_value(response.metadata)?),
++    }))
+ }
+
+-pub fn default_agents() -> Vec<AgentConfig> {
+-    // vec![ restore default later ?
+-    //     AgentConfig {
+-    //         name: "greeter".to_string(),
+-    //         public_description: "Agent that greets the user.".to_string(),
+-    //         instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
+-    //         tools: Vec::new(),
+-    //         downstream_agents: vec!["haiku".to_string()],
+-    //         personality: None,
+-    //         state_machine: None,
+-    //     }
+-    // ]
+-    let mut agents = Vec::new();
+-
+-    #[cfg(feature = "greeter-agent")]
+-    agents.push(AgentConfig {
+-        name: "greeter".to_string(),
+-        public_description: "Agent that greets the user.".to_string(),
+-        instructions: "Please greet the user and ask them if they'd like a Haiku. If yes, transfer them to the 'haiku' agent.".to_string(),
+-        tools: Vec::new(),
+-        downstream_agents: vec!["haiku".to_string()],
+-        personality: None,
+-        state_machine: None,
+-    });
+-
+-    #[cfg(feature = "haiku-agent")]
+-    agents.push(AgentConfig {
+-        name: "haiku".to_string(),
+-        public_description: "Agent that creates haikus.".to_string(),
+-        instructions: "Create haikus based on user input.".to_string(),
+-        tools: Vec::new(),
+-        downstream_agents: Vec::new(),
+-        personality: None,
+-        state_machine: None,
+-    });
+-
+-    #[cfg(feature = "git-agent")]
+-    agents.push(AgentConfig {
+-        name: "git".to_string(),
+-        public_description: "Agent that helps with git operations.".to_string(),
+-        instructions: "Help users with git operations like commit, branch, merge etc.".to_string(),
+-        tools: Vec::new(),
+-        downstream_agents: Vec::new(),
+-        personality: None,
+-        state_machine: None,
+-    });
+-
+-    #[cfg(feature = "project-init-agent")]
+-    agents.push(AgentConfig {
+-        name: "project-init".to_string(),
+-        public_description: "Agent that helps initialize new projects.".to_string(),
+-        instructions: "Help users create new projects with proper structure and configuration.".to_string(),
+-        tools: Vec::new(),
+-        downstream_agents: Vec::new(),
+-        personality: None,
+-        state_machine: None,
+-    });
++pub async fn handle_message(
++    Path(agent_name): Path<String>,
++    State(registry): State<Arc<RwLock<AgentRegistry>>>,
++    Json(request): Json<MessageRequest>,
++) -> Result<Json<MessageResponse>, AppError> {
++    let registry = registry.read().await;
++    let agent = registry.get_agent(&agent_name).ok_or(StatusCode::NOT_FOUND)?;
++    let mut agent_lock = agent.write().await;
++    let response = agent_lock.process_message(Message::new(request.content)).await?;
++    Ok(Json(MessageResponse {
++        content: response.content,
++        metadata: response.metadata.map(|m| serde_json::to_value(m).unwrap_or_default()),
++    }))
++}
+
+-    #[cfg(feature = "browser-agent")]
+-    agents.push(AgentConfig {
+-        name: "browser".to_string(),
+-        public_description: "Agent that controls browser automation.".to_string(),
+-        instructions: "Help users with browser automation tasks.".to_string(),
+-        tools: Vec::new(),
+-        downstream_agents: Vec::new(),
+-        personality: None,
+-        state_machine: None,
+-    });
++pub async fn handle_todo_list(
++    Path(agent_name): Path<String>,
++    State(registry): State<Arc<RwLock<AgentRegistry>>>,
++    Json(task): Json<TodoTask>,
++) -> Result<Json<MessageResponse>, AppError> {
++    let registry = registry.read().await;
++    let agent = registry.get_agent(&agent_name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let agent_lock = agent.read().await;
++    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
++    todo_list.add_task(task).await?;
++    Ok(Json(MessageResponse {
++        content: "Task added successfully".to_string(),
++        metadata: None,
++    }))
++}
+
+-    agents
++pub fn default_agents() -> Vec<AgentConfig> {
++    vec![
++        AgentConfig {
++            name: "greeter".to_string(),
++            public_description: "Agent that greets the user.".to_string(),
++            instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
++            tools: Vec::new(),
++            downstream_agents: vec!["haiku".to_string()],
++            personality: None,
++            state_machine: None,
++        }
++    ]
+ }
+
+ #[derive(Debug, Deserialize, Clone)]
+@@ -184,253 +178,153 @@ pub struct AddTaskRequest {
+     pub source_agent: Option<String>,
+ }
+
+-#[derive(Debug, Serialize)]
+-pub struct TaskResponse {
+-    pub id: String,
+-    pub description: String,
+-    pub priority: TaskPriority,
+-    pub source_agent: Option<String>,
+-    pub target_agent: String,
+-    pub status: TaskStatus,
+-    pub created_at: i64,
+-    pub completed_at: Option<i64>,
+-}
+-
+-impl From<TodoTask> for TaskResponse {
+-    fn from(task: TodoTask) -> Self {
+-        Self {
+-            id: task.id,
+-            description: task.description,
+-            priority: task.priority,
+-            source_agent: task.source_agent,
+-            target_agent: task.target_agent,
+-            status: task.status,
+-            created_at: task.created_at,
+-            completed_at: task.completed_at,
++impl From<AddTaskRequest> for TodoTask {
++    fn from(req: AddTaskRequest) -> Self {
++        TodoTask {
++            id: uuid::Uuid::new_v4().to_string(),
++            description: req.description,
++            priority: req.priority,
++            source_agent: req.source_agent,
++            target_agent: "".to_string(), // Will be set by the handler
++            status: TaskStatus::Pending,
++            created_at: Utc::now(),
++            completed_at: None,
+         }
+     }
+ }
+
+-// Add a task to an agent's todo list
+ pub async fn add_task(
++    Path(name): Path<String>,
+     State(state): State<Arc<AppState>>,
+-    Path(agent_name): Path<String>,
+     Json(request): Json<AddTaskRequest>,
+-) -> Result<Json<TaskResponse>, StatusCode> {
++) -> Result<Json<TodoTask>, AppError> {
+     let registry = state.agents.read().await;
++    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let agent_lock = agent.read().await;
++    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
+
+-    let agent = registry.get(&agent_name)
+-        .ok_or(StatusCode::NOT_FOUND)?;
+-
+-    let task = TodoTask {
+-        id: uuid::Uuid::new_v4().to_string(),
+-        description: request.description,
+-        priority: request.priority,
+-        source_agent: request.source_agent,
+-        target_agent: agent_name,
+-        status: TaskStatus::Pending,
+-        created_at: chrono::Utc::now().timestamp(),
+-        completed_at: None,
+-    };
++    let mut task: TodoTask = request.into();
++    task.target_agent = name;
+
+-    // Get the todo list from the agent
+-    let todo_list = <dyn Agent>::get_todo_list(agent)
+-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
+-
+-    todo_list.add_task(task.clone()).await;
+-
+-    Ok(Json(TaskResponse::from(task)))
++    todo_list.add_task(task.clone()).await?;
++    Ok(Json(task))
+ }
+
+-// Get all tasks for an agent
+ pub async fn get_tasks(
++    Path(name): Path<String>,
+     State(state): State<Arc<AppState>>,
+-    Path(agent_name): Path<String>,
+-) -> Result<Json<Vec<TaskResponse>>, StatusCode> {
++) -> Result<Json<Vec<TodoTask>>, AppError> {
+     let registry = state.agents.read().await;
+-
+-    let agent = registry.get(&agent_name)
+-        .ok_or(StatusCode::NOT_FOUND)?;
+-
+-    // Get the todo list from the agent
+-    let todo_list = <dyn Agent>::get_todo_list(agent)
+-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
+-
+-    let tasks = todo_list.get_all_tasks().await;
+-
+-    Ok(Json(tasks.into_iter().map(TaskResponse::from).collect()))
++    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let agent_lock = agent.read().await;
++    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
++    let tasks = todo_list.get_tasks().await;
++    Ok(Json(tasks))
+ }
+
+-// Get a specific task by ID
+ pub async fn get_task(
++    Path((name, task_id)): Path<(String, String)>,
+     State(state): State<Arc<AppState>>,
+-    Path((agent_name, task_id)): Path<(String, String)>,
+-) -> Result<Json<TaskResponse>, StatusCode> {
++) -> Result<Json<TodoTask>, AppError> {
+     let registry = state.agents.read().await;
+-
+-    let agent = registry.get(&agent_name)
+-        .ok_or(StatusCode::NOT_FOUND)?;
+-
+-    // Get the todo list from the agent
+-    let todo_list = <dyn Agent>::get_todo_list(agent)
+-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
+-
+-    let task = todo_list.get_task(&task_id).await
+-        .ok_or(StatusCode::NOT_FOUND)?;
+-
+-    Ok(Json(TaskResponse::from(task)))
++    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    let agent_lock = agent.read().await;
++    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
++    let task = todo_list.get_task(&task_id).await.ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
++    Ok(Json(task))
+ }
+
+ #[cfg(test)]
+ mod tests {
+     use super::*;
+-    use crate::agents::{AgentRegistry, GreeterAgent, TransferService};
+-    use crate::types::AgentConfig;
++    use crate::agents::greeter::GreeterAgent;
++    use axum::http::StatusCode;
++    use chrono::Utc;
+
+-    #[tokio::test]
+-    async fn test_list_agents() {
++    async fn setup_test_state() -> Arc<AppState> {
+         let mut registry = AgentRegistry::new();
+-        let agent = GreeterAgent::new(AgentConfig {
+-            name: "test".to_string(),
++        let config = AgentConfig {
++            name: "test_agent".to_string(),
+             public_description: "Test agent".to_string(),
+             instructions: "Test instructions".to_string(),
+             tools: vec![],
+             downstream_agents: vec![],
+             personality: None,
+             state_machine: None,
+-        });
+-
+-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
+-        let registry = Arc::new(RwLock::new(registry));
+-        let state = Arc::new(AppState {
+-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
+-            agents: registry,
+-        });
++        };
++        registry.register("test_agent".to_string(), Box::new(GreeterAgent::new(config)));
++        Arc::new(AppState {
++            agents: Arc::new(RwLock::new(registry)),
++        })
++    }
+
++    #[tokio::test]
++    async fn test_list_agents() {
++        let state = setup_test_state().await;
+         let response = list_agents(State(state)).await.unwrap();
+-        assert_eq!(response.0.len(), 1);
+-        assert_eq!(response.0[0].name, "test");
++        assert!(!response.0.is_empty());
+     }
+
+     #[tokio::test]
+     async fn test_get_agent() {
+-        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
+-        let state = Arc::new(AppState {
+-            transfer_service,
+-            agents: registry,
+-        });
+-        let response = get_agent(State(state.clone()), Path("unknown".to_string())).await;
+-        assert!(response.is_err());
+-        assert_eq!(response.unwrap_err(), StatusCode::NOT_FOUND);
++        let state = setup_test_state().await;
++        let response = get_agent(Path("test_agent".to_string()), State(state)).await.unwrap();
++        assert!(response.0.content.contains("ready"));
+     }
+
+     #[tokio::test]
+     async fn test_send_message() {
+-        let mut registry = AgentRegistry::new();
+-        let agent = GreeterAgent::new(AgentConfig {
+-            name: "test".to_string(),
+-            public_description: "Test agent".to_string(),
+-            instructions: "Test instructions".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: None,
+-        });
+-
+-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
+-        let registry = Arc::new(RwLock::new(registry));
+-        let state = Arc::new(AppState {
+-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
+-            agents: registry,
+-        });
+-
++        let state = setup_test_state().await;
+         let request = MessageRequest {
+             content: "Hello".to_string(),
+         };
+-
+         let response = send_message(
++            Path("test_agent".to_string()),
+             State(state),
+-            Path("test".to_string()),
+             Json(request),
+-        ).await;
+-        assert!(response.is_ok());
++        )
++        .await
++        .unwrap();
++        assert!(!response.0.content.is_empty());
+     }
+
+     #[tokio::test]
+     async fn test_todo_list_endpoints() {
+-        // Create test state
+-        let mut registry = AgentRegistry::new();
+-        let agent = GreeterAgent::new(AgentConfig {
+-            name: "test_agent".to_string(),
+-            public_description: "Test agent".to_string(),
+-            instructions: "Test instructions".to_string(),
+-            tools: vec![],
+-            downstream_agents: vec![],
+-            personality: None,
+-            state_machine: None,
+-        });
+-
+-        registry.register("test_agent".to_string(), Box::new(agent)).await.unwrap();
+-        let registry = Arc::new(RwLock::new(registry));
+-        let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
+-        let state = Arc::new(AppState {
+-            transfer_service,
+-            agents: registry,
+-        });
+-
+-        // Test adding a task
+-        let add_request = AddTaskRequest {
++        let state = setup_test_state().await;
++
++        // Test add task
++        let request = AddTaskRequest {
+             description: "Test task".to_string(),
+             priority: TaskPriority::Medium,
+             source_agent: None,
+         };
+-
++
+         let response = add_task(
+-            State(state.clone()),
+             Path("test_agent".to_string()),
+-            Json(add_request.clone()),
+-        ).await.unwrap();
+-
+-        let task = response.0;
+-        assert_eq!(task.description, "Test task");
+-        assert_eq!(task.status, TaskStatus::Pending);
+-
+-        // Test getting all tasks
+-        let tasks = get_tasks(
+-            State(state.clone()),
+-            Path("test_agent".to_string()),
+-        ).await.unwrap();
+-
+-        assert_eq!(tasks.0.len(), 1);
+-        assert_eq!(tasks.0[0].description, "Test task");
+-
+-        // Test getting a specific task
+-        let task = get_task(
+-            State(state.clone()),
+-            Path(("test_agent".to_string(), task.id.clone())),
+-        ).await.unwrap();
+-
+-        assert_eq!(task.0.description, "Test task");
+-        assert_eq!(task.0.id, task.0.id);
+-
+-        // Test getting a non-existent task
+-        let result = get_task(
+             State(state.clone()),
+-            Path(("test_agent".to_string(), "non-existent".to_string())),
+-        ).await;
+-
+-        assert!(result.is_err());
+-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
++            Json(request),
++        )
++        .await
++        .unwrap();
++        assert!(response.0.id.len() > 0);
+
+-        // Test adding a task to a non-existent agent
+-        let result = add_task(
++        // Test get tasks
++        let response = get_tasks(
++            Path("test_agent".to_string()),
+             State(state.clone()),
+-            Path("non-existent".to_string()),
+-            Json(add_request),
+-        ).await;
++        )
++        .await
++        .unwrap();
++        assert_eq!(response.0.len(), 1);
+
+-        assert!(result.is_err());
+-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
++        // Test get task
++        let task_id = response.0[0].id.clone();
++        let response = get_task(
++            Path(("test_agent".to_string(), task_id)),
++            State(state),
++        )
++        .await
++        .unwrap();
++        assert!(response.0.description.contains("Test task"));
+     }
+ }
+diff --git a/src/api/websocket.rs b/src/api/websocket.rs
+index 0fa75aa..a27e7e9 100644
+--- a/src/api/websocket.rs
++++ b/src/api/websocket.rs
+@@ -17,6 +17,8 @@ use crate::{
+ use crate::agents::HaikuAgent;
+
+ use tokio::sync::RwLock;
++use crate::api::routes::AppError;
++use axum::http::StatusCode;
+
+ const CHANNEL_SIZE: usize = 32;
+
+@@ -52,6 +54,21 @@ pub enum ServerMessage {
+     SessionUpdated,
+ }
+
++#[derive(Debug)]
++pub enum WebSocketError {
++    ConnectionError(String),
++    AgentError(String),
++}
++
++impl From<WebSocketError> for StatusCode {
++    fn from(error: WebSocketError) -> Self {
++        match error {
++            WebSocketError::ConnectionError(_) => StatusCode::BAD_REQUEST,
++            WebSocketError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
++        }
++    }
++}
++
+ pub async fn websocket_handler(
+     ws: WebSocketUpgrade,
+     State(state): State<Arc<AppState>>,
+@@ -62,47 +79,57 @@ pub async fn websocket_handler(
+ async fn handle_socket(mut socket: WebSocket, state: Arc<AppState>) {
+     let (mut sender, mut receiver) = socket.split();
+
+-    while let Some(Ok(msg)) = receiver.next().await {
+-        if let WsMessage::Text(content) = msg {
+-            let response = match serde_json::from_str::<ClientMessage>(&content) {
+-                Ok(client_msg) => {
+-                    match handle_client_message(client_msg, state.clone()).await {
+-                        Ok(server_msg) => {
+-                            match serde_json::to_string(&server_msg) {
+-                                Ok(json) => WsMessage::Text(json),
+-                                Err(_) => WsMessage::Text("Error serializing response".to_string()),
+-                            }
+-                        },
+-                        Err(e) => WsMessage::Text(format!("Error: {}", e)),
+-                    }
+-                },
+-                Err(_) => WsMessage::Text("Invalid message format".to_string()),
+-            };
+-
+-            if sender.send(response).await.is_err() {
+-                break;
++    let mut registry = state.agents.write().await;
++    let greeter_agent = GreeterAgent::new();
++    registry.register("greeter".to_string(), Box::new(greeter_agent));
++    drop(registry);
++
++    while let Some(msg) = receiver.next().await {
++        let msg = msg.map_err(|_| AppError::Status(StatusCode::BAD_REQUEST))?;
++
++        match msg {
++            Message::Text(text) => {
++                let registry = state.agents.read().await;
++                if let Some(agent) = registry.get("greeter") {
++                    let response = agent.process_message(Message::new(text)).await
++                        .map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
++
++                    sender.send(Message::Text(response.content))
++                        .await
++                        .map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
++                }
+             }
++            _ => {}
+         }
+     }
++
++    Ok(())
+ }
+
+ async fn handle_client_message(msg: ClientMessage, state: Arc<AppState>) -> Result<ServerMessage, String> {
+     match msg {
+         ClientMessage::Connect { agent } => {
+-            let mut transfer_service = state.transfer_service.write().await;
+-            transfer_service.set_current_agent(agent.clone());
++            let mut registry = state.agents.write().await;
++            let greeter_agent = GreeterAgent::new();
++            registry.register("greeter".to_string(), Box::new(greeter_agent));
++            drop(registry);
+             Ok(ServerMessage::Connected { agent })
+         },
+         ClientMessage::Message { content } => {
+-            let mut transfer_service = state.transfer_service.write().await;
+-            match transfer_service.process_message(Message::new(content)).await {
++            let mut registry = state.agents.write().await;
++            let greeter_agent = GreeterAgent::new();
++            registry.register("greeter".to_string(), Box::new(greeter_agent));
++            drop(registry);
++            match greeter_agent.process_message(Message::new(content)).await {
+                 Ok(response) => Ok(ServerMessage::Message { content: response.content }),
+                 Err(e) => Err(e.to_string()),
+             }
+         },
+         ClientMessage::Transfer { from, to } => {
+-            let mut transfer_service = state.transfer_service.write().await;
+-            transfer_service.set_current_agent(to.clone());
++            let mut registry = state.agents.write().await;
++            let greeter_agent = GreeterAgent::new();
++            registry.register("greeter".to_string(), Box::new(greeter_agent));
++            drop(registry);
+             Ok(ServerMessage::Transferred { from, to })
+         },
+         ClientMessage::UpdateSession { instructions, tools, turn_detection } => {
+@@ -112,6 +139,44 @@ async fn handle_client_message(msg: ClientMessage, state: Arc<AppState>) -> Resu
+     }
+ }
+
++pub async fn handle_websocket(
++    mut ws: WebSocket,
++    State(state): State<Arc<AppState>>,
++) -> Result<(), WebSocketError> {
++    let mut registry = state.agents.write().await;
++    let config = AgentConfig {
++        name: "greeter".to_string(),
++        public_description: "Greeter agent".to_string(),
++        instructions: "Greets users".to_string(),
++        tools: vec![],
++        downstream_agents: vec![],
++        personality: None,
++        state_machine: None,
++    };
++    let greeter_agent = GreeterAgent::new(config);
++    registry.register("greeter".to_string(), Box::new(greeter_agent));
++    drop(registry);
++
++    while let Some(msg) = ws.recv().await {
++        let msg = msg.map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
++
++        if let WsMessage::Text(text) = msg {
++            let registry = state.agents.read().await;
++            if let Some(agent) = registry.get_agent("greeter") {
++                let mut agent = agent.write().await;
++                let response = agent.process_message(Message::new(text)).await
++                    .map_err(|e| WebSocketError::AgentError(e.to_string()))?;
++
++                ws.send(WsMessage::from(response))
++                    .await
++                    .map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
++            }
++        }
++    }
++
++    Ok(())
++}
++
+ #[cfg(test)]
+ mod tests {
+     use super::*;
+@@ -132,11 +197,10 @@ mod tests {
+         };
+
+         let greeter_agent = GreeterAgent::new(greeter_config);
+-        registry.register("greeter".to_string(), Box::new(greeter_agent)).await.expect("Failed to register greeter agent");
++        registry.register("greeter".to_string(), Box::new(greeter_agent));
+
+         let registry = Arc::new(RwLock::new(registry));
+         Arc::new(AppState {
+-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
+             agents: registry,
+         })
+     }
+diff --git a/src/types/mod.rs b/src/types/mod.rs
+index 49bcc98..759adb6 100644
+--- a/src/types/mod.rs
++++ b/src/types/mod.rs
+@@ -5,7 +5,11 @@ use chrono;
+ use std::str::FromStr;
+ use thiserror::Error;
+ use std::fmt;
+-use crate::agents::{AgentRegistry, AgentWrapper};
++use crate::agents::AgentRegistry;
++pub use crate::agents::wrapper::AgentWrapper;
++use std::sync::{Arc, RwLock};
++use std::time::Duration;
++use axum::extract::ws::Message as WsMessage;
+
+ pub mod todo;
+ pub use todo::{TodoList, TodoProcessor, TodoTask, TaskPriority, TaskStatus};
+@@ -58,8 +62,6 @@ pub struct TranscriptItem {
+ pub struct Message {
+     pub content: String,
+     pub metadata: Option<MessageMetadata>,
+-    pub role: Option<String>,
+-    pub timestamp: Option<i64>,
+ }
+
+ impl Message {
+@@ -67,24 +69,22 @@ impl Message {
+         Self {
+             content,
+             metadata: None,
+-            role: Some("assistant".to_string()),
+-            timestamp: Some(chrono::Utc::now().timestamp()),
+         }
+     }
++}
+
+-    pub fn with_metadata(mut self, metadata: Option<MessageMetadata>) -> Self {
+-        self.metadata = metadata;
+-        self
+-    }
+-
+-    pub fn with_role(mut self, role: Option<String>) -> Self {
+-        self.role = role;
+-        self
++impl From<Message> for WsMessage {
++    fn from(msg: Message) -> Self {
++        WsMessage::Text(msg.content)
+     }
++}
+
+-    pub fn with_timestamp(mut self, timestamp: Option<i64>) -> Self {
+-        self.timestamp = timestamp;
+-        self
++impl From<WsMessage> for Message {
++    fn from(msg: WsMessage) -> Self {
++        match msg {
++            WsMessage::Text(content) => Message::new(content),
++            _ => Message::new("Unsupported message type".to_string()),
++        }
+     }
+ }
+
+@@ -179,9 +179,9 @@ pub struct ValidationRule {
+
+ pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;
+
+-#[async_trait::async_trait]
++#[async_trait]
+ pub trait Agent: Send + Sync {
+-    async fn process_message(&self, message: Message) -> Result<Message>;
++    async fn process_message(&mut self, message: Message) -> Result<Message>;
+     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message>;
+     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String>;
+     async fn get_current_state(&self) -> Result<Option<State>>;
+@@ -194,9 +194,9 @@ pub trait Agent: Send + Sync {
+
+     /// Add a task to another agent's todo list if it supports task processing
+     async fn delegate_task(&self, task: TodoTask, registry: &AgentRegistry) -> Result<()> {
+-        if let Some(target_agent) = registry.get(&task.target_agent) {
+-            let todo_list = <AgentWrapper as TodoProcessor>::get_todo_list(target_agent);
+-            todo_list.add_task(task).await;
++        if let Some(target_agent) = registry.get_agent(&task.target_agent) {
++            let todo_list = TodoProcessor::get_todo_list(&*target_agent.read().await);
++            todo_list.add_task(task).await?;
+             Ok(())
+         } else {
+             Err(format!("Target agent '{}' not found", task.target_agent).into())
+diff --git a/src/types/todo.rs b/src/types/todo.rs
+index 40df62d..576365e 100644
+--- a/src/types/todo.rs
++++ b/src/types/todo.rs
+@@ -1,8 +1,13 @@
+-use std::collections::VecDeque;
++use std::collections::HashMap;
+ use serde::{Deserialize, Serialize};
+ use tokio::sync::RwLock;
+ use std::sync::Arc;
+ use super::Message;
++use std::time::Duration;
++use async_trait::async_trait;
++use chrono::{DateTime, Utc};
++use super::Result;
++use crate::agents::wrapper::AgentWrapper;
+
+ #[derive(Debug, Clone, Serialize, Deserialize)]
+ pub struct TodoTask {
+@@ -12,8 +17,8 @@ pub struct TodoTask {
+     pub source_agent: Option<String>,
+     pub target_agent: String,
+     pub status: TaskStatus,
+-    pub created_at: i64,
+-    pub completed_at: Option<i64>,
++    pub created_at: DateTime<Utc>,
++    pub completed_at: Option<DateTime<Utc>>,
+ }
+
+ #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
+@@ -32,94 +37,141 @@ pub enum TaskStatus {
+     Failed,
+ }
+
+-#[derive(Debug, Clone, Default)]
++#[derive(Debug, Clone)]
+ pub struct TodoList {
+-    tasks: Arc<RwLock<VecDeque<TodoTask>>>,
++    tasks: HashMap<String, TodoTask>,
+ }
+
+ impl TodoList {
+     pub fn new() -> Self {
+         Self {
+-            tasks: Arc::new(RwLock::new(VecDeque::new())),
++            tasks: HashMap::new(),
+         }
+     }
+
+-    pub async fn add_task(&self, task: TodoTask) {
+-        let mut tasks = self.tasks.write().await;
+-        tasks.push_back(task);
++    pub fn add_task(&mut self, task: TodoTask) {
++        self.tasks.insert(task.id.clone(), task);
+     }
+
+-    pub async fn get_next_task(&self) -> Option<TodoTask> {
+-        let mut tasks = self.tasks.write().await;
+-        tasks.pop_front()
++    pub fn get_tasks(&self) -> Vec<TodoTask> {
++        self.tasks.values().cloned().collect()
+     }
+
+-    pub async fn peek_next_task(&self) -> Option<TodoTask> {
+-        let tasks = self.tasks.read().await;
+-        tasks.front().cloned()
++    pub fn get_task(&self, id: &str) -> Option<&TodoTask> {
++        self.tasks.get(id)
+     }
+
+-    pub async fn mark_task_completed(&self, task_id: &str) {
+-        let mut tasks = self.tasks.write().await;
+-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
++    pub fn get_task_mut(&mut self, id: &str) -> Option<&mut TodoTask> {
++        self.tasks.get_mut(id)
++    }
++
++    pub fn get_next_task(&self) -> Option<TodoTask> {
++        self.tasks.values()
++            .find(|t| t.status == TaskStatus::Pending)
++            .cloned()
++    }
++
++    pub fn mark_task_completed(&mut self, id: &str) {
++        if let Some(task) = self.get_task_mut(id) {
+             task.status = TaskStatus::Completed;
+-            task.completed_at = Some(chrono::Utc::now().timestamp());
++            task.completed_at = Some(Utc::now());
+         }
+     }
+
+-    pub async fn mark_task_failed(&self, task_id: &str) {
+-        let mut tasks = self.tasks.write().await;
+-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
++    pub fn mark_task_failed(&mut self, id: &str) {
++        if let Some(task) = self.get_task_mut(id) {
+             task.status = TaskStatus::Failed;
+         }
+     }
++}
++
++pub trait TodoProcessor {
++    async fn process_task(&mut self, task: TodoTask) -> Result<Message>;
++    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>>;
++    async fn start_processing(&mut self);
++    fn get_check_interval(&self) -> Duration {
++        Duration::from_secs(1)
++    }
++}
++
++#[async_trait]
++pub trait TodoListExt {
++    async fn add_task(&self, task: TodoTask) -> Result<()>;
++    async fn get_task(&self, id: &str) -> Option<TodoTask>;
++    async fn get_tasks(&self) -> Vec<TodoTask>;
++    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()>;
++    async fn delete_task(&self, id: &str) -> Result<()>;
++}
++
++#[async_trait]
++impl TodoListExt for Arc<RwLock<TodoList>> {
++    async fn add_task(&self, task: TodoTask) -> Result<()> {
++        let mut list = self.write().await;
++        list.add_task(task);
++        Ok(())
++    }
+
+-    pub async fn is_empty(&self) -> bool {
+-        let tasks = self.tasks.read().await;
+-        tasks.is_empty()
++    async fn get_task(&self, id: &str) -> Option<TodoTask> {
++        let list = self.read().await;
++        list.get_task(id).cloned()
+     }
+
+-    pub async fn len(&self) -> usize {
+-        let tasks = self.tasks.read().await;
+-        tasks.len()
++    async fn get_tasks(&self) -> Vec<TodoTask> {
++        let list = self.read().await;
++        list.get_tasks()
+     }
+
+-    pub async fn get_all_tasks(&self) -> Vec<TodoTask> {
+-        let tasks = self.tasks.read().await;
+-        tasks.iter().cloned().collect()
++    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()> {
++        let mut list = self.write().await;
++        if list.tasks.contains_key(id) {
++            list.tasks.insert(id.to_string(), task);
++            Ok(())
++        } else {
++            Err("Task not found".into())
++        }
+     }
+
+-    pub async fn get_task(&self, task_id: &str) -> Option<TodoTask> {
+-        let tasks = self.tasks.read().await;
+-        tasks.iter().find(|t| t.id == task_id).cloned()
++    async fn delete_task(&self, id: &str) -> Result<()> {
++        let mut list = self.write().await;
++        if list.tasks.remove(id).is_some() {
++            Ok(())
++        } else {
++            Err("Task not found".into())
++        }
+     }
+ }
+
+-#[async_trait::async_trait]
+-pub trait TodoProcessor: Send + Sync {
+-    /// Process a single task from the todo list
+-    async fn process_task(&self, task: TodoTask) -> super::Result<Message>;
+-
+-    /// Get the interval at which this processor should check for new tasks
+-    fn get_check_interval(&self) -> std::time::Duration;
+-
+-    /// Get the todo list for this processor
+-    fn get_todo_list(&self) -> &TodoList;
+-
+-    /// Start the task processing loop
+-    async fn start_processing(&self) -> super::Result<()> {
++impl TodoProcessor for AgentWrapper {
++    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
++        self.process_message(Message::new(task.description)).await
++    }
++
++    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
++        self.todo_list.clone()
++    }
++
++    async fn start_processing(&mut self) {
+         loop {
+-            if let Some(task) = self.get_todo_list().get_next_task().await {
+-                match self.process_task(task.clone()).await {
++            let todo_list = self.get_todo_list().await;
++            let mut list = todo_list.write().await;
++
++            if let Some(task) = list.get_next_task() {
++                drop(list); // Release the lock before processing
++                let result = self.process_task(task).await;
++                match result {
+                     Ok(_) => {
+-                        self.get_todo_list().mark_task_completed(&task.id).await;
++                        let mut list = todo_list.write().await;
++                        list.mark_task_completed(&task.id);
+                     }
+                     Err(_) => {
+-                        self.get_todo_list().mark_task_failed(&task.id).await;
++                        let mut list = todo_list.write().await;
++                        list.mark_task_failed(&task.id);
+                     }
+                 }
++            } else {
++                drop(list);
++                tokio::time::sleep(Duration::from_secs(1)).await;
+             }
+-            tokio::time::sleep(self.get_check_interval()).await;
+         }
+     }
+ }
diff --git a/lessons.md b/lessons.md
new file mode 100644
index 0000000..5cb48e7
--- /dev/null
+++ b/lessons.md
@@ -0,0 +1,8 @@
+## Lessons Learned
+- `.await` can only be used on types that implement Future
+- `?` operator requires the type to implement Try trait
+- Arc provides immutable shared ownership - use Arc::make_mut for mutable access
+- RwLockWriteGuard needs to be used carefully to avoid shadowing issues
+- Struct definitions must be unique within a module's namespace
+- Test modules need explicit imports for all types used
+- Derived traits must be implemented for all fields of a struct
diff --git a/src/agents/balena/mod.rs b/src/agents/balena_wrapper.rs
similarity index 55%
rename from src/agents/balena/mod.rs
rename to src/agents/balena_wrapper.rs
index 2ecba5b..5dc55a0 100644
--- a/src/agents/balena/mod.rs
+++ b/src/agents/balena_wrapper.rs
@@ -1,22 +1,19 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
-use tokio::process::Command;
-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, Result, ToolCall};
-use std::sync::Arc;
+use std::process::Command;
+use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall};

 pub struct BalenaWrapperAgent {
     config: AgentConfig,
     state_manager: AgentStateManager,
-    inner: Arc<dyn Agent + Send + Sync>,
 }

 impl BalenaWrapperAgent {
     pub fn new(config: AgentConfig) -> Self {
-        // Setup the state machine as before...
         let state_machine = Some(StateMachine {
             states: {
                 let mut states = HashMap::new();
-                states.insert("awaiting_command".to_string(), crate::types::State {
+                states.insert("awaiting_command".to_string(), State {
                     prompt: "🛸 Fleet Commander ready. What IoT operations shall we initiate today?".to_string(),
                     transitions: {
                         let mut transitions = HashMap::new();
@@ -25,7 +22,7 @@ impl BalenaWrapperAgent {
                     },
                     validation: None,
                 });
-                states.insert("executing".to_string(), crate::types::State {
+                states.insert("executing".to_string(), State {
                     prompt: "⚡ Executing fleet command... Stand by for quantum entanglement.".to_string(),
                     transitions: {
                         let mut transitions = HashMap::new();
@@ -42,14 +39,9 @@ impl BalenaWrapperAgent {
         Self {
             config,
             state_manager: AgentStateManager::new(state_machine),
-            inner: Arc::new(Self {
-                config,
-                state_manager: AgentStateManager::new(state_machine),
-            }),
         }
     }

-
     fn create_response(&self, content: String) -> Message {
         let current_state = self.state_manager.get_current_state_name();
         let metadata = MessageMetadata::new(self.config.name.clone())
@@ -114,13 +106,41 @@ impl BalenaWrapperAgent {
     }
 }

-
 #[async_trait]
 impl Agent for BalenaWrapperAgent {
     async fn process_message(&self, message: Message) -> Result<Message> {
-        // Use the existing logic to handle commands...
-        // ...
-        Ok(self.create_response("Response from BalenaWrapperAgent".to_string()))
+        let parts: Vec<&str> = message.content.split_whitespace().collect();
+
+        if parts.is_empty() {
+            return Ok(self.get_help_message());
+        }
+
+        let response = match parts[0] {
+            "devices" => {
+                self.execute_balena_command(&["devices"]).await?
+            },
+            "push" if parts.len() > 1 => {
+                self.execute_balena_command(&["push", parts[1]]).await?
+            },
+            "logs" if parts.len() > 1 => {
+                self.execute_balena_command(&["logs", parts[1]]).await?
+            },
+            "ssh" if parts.len() > 1 => {
+                self.execute_balena_command(&["ssh", parts[1]]).await?
+            },
+            "status" => {
+                self.execute_balena_command(&["device", "list"]).await?
+            },
+            "wifi" if parts.len() > 3 => {
+                self.execute_balena_command(&["wifi", parts[1], parts[2], parts[3]]).await?
+            },
+            "scan" => {
+                self.execute_balena_command(&["scan"]).await?
+            },
+            _ => "Unknown fleet command. Use 'help' to view available operations.".to_string(),
+        };
+
+        Ok(self.format_fleet_response(response))
     }

     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
@@ -128,13 +148,12 @@ impl Agent for BalenaWrapperAgent {
     }

     async fn call_tool(&self, _tool_call: ToolCall) -> Result<Message> {
-        Ok(self.create_response(
-            "Direct tool interface not available. Please use fleet command protocols."
-                .to_string(),
+        Ok(self.format_fleet_response(
+            "Direct tool interface not available. Please use fleet command protocols.".to_string()
         ))
     }

-    async fn get_current_state(&self) -> Result<Option<crate::types::State>> {
+    async fn get_current_state(&self) -> Result<Option<State>> {
         Ok(self.state_manager.get_current_state().cloned())
     }

@@ -142,3 +161,59 @@ impl Agent for BalenaWrapperAgent {
         Ok(self.config.clone())
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    fn create_test_config() -> AgentConfig {
+        AgentConfig {
+            name: "balena".to_string(),
+            public_description: "IoT Fleet Command & Control Center".to_string(),
+            instructions: "Manage and deploy IoT device fleets with precision".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: Some(serde_json::json!({
+                "style": "fleet_commander",
+                "traits": ["precise", "iot_focused", "system_oriented", "deployment_expert"],
+                "voice": {
+                    "tone": "authoritative_technical",
+                    "pacing": "measured_and_clear",
+                    "quirks": ["uses_fleet_metaphors", "speaks_in_system_terms", "quantum_terminology"]
+                }
+            }).to_string()),
+            state_machine: None,
+        }
+    }
+
+    #[tokio::test]
+    async fn test_help_message() {
+        let agent = BalenaWrapperAgent::new(create_test_config());
+        let response = agent.process_message(Message {
+            content: "help".to_string(),
+            metadata: MessageMetadata::new("user".to_string()),
+            parameters: HashMap::new(),
+            tool_calls: None,
+            confidence: None,
+        }).await.unwrap();
+
+        assert!(response.content.contains("Fleet Command Center"));
+        assert!(response.content.contains("devices"));
+        assert!(response.content.contains("push"));
+    }
+
+    #[tokio::test]
+    async fn test_device_list() {
+        let agent = BalenaWrapperAgent::new(create_test_config());
+        let response = agent.process_message(Message {
+            content: "devices".to_string(),
+            metadata: MessageMetadata::new("user".to_string()),
+            parameters: HashMap::new(),
+            tool_calls: None,
+            confidence: None,
+        }).await.unwrap();
+
+        // Note: This test might fail if balena CLI is not installed or configured
+        assert!(response.content.contains("Fleet") || response.content.contains("Error"));
+    }
+}
diff --git a/src/agents/browser/mod.rs b/src/agents/browser_agent.rs
similarity index 90%
rename from src/agents/browser/mod.rs
rename to src/agents/browser_agent.rs
index 16e15f1..6bb5f16 100644
--- a/src/agents/browser/mod.rs
+++ b/src/agents/browser_agent.rs
@@ -33,11 +33,17 @@ impl BrowserAgentWrapper {
 }

 // Temporary dummy agent implementation
-struct DummyAgent {}
+pub struct DummyAgent {}
+
+impl DummyAgent {
+    pub fn new() -> Self {
+        Self {}
+    }
+}

 #[async_trait]
 impl Agent for DummyAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         Ok(Message::new(format!("Browser received: {}", message.content)))
     }

@@ -68,7 +74,7 @@ impl Agent for DummyAgent {

 #[async_trait]
 impl Agent for BrowserAgentWrapper {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         self.inner.process_message(message).await
     }

diff --git a/src/agents/git_assistant/mod.rs b/src/agents/git_assistant.rs
similarity index 76%
rename from src/agents/git_assistant/mod.rs
rename to src/agents/git_assistant.rs
index 24848f3..44f664f 100644
--- a/src/agents/git_assistant/mod.rs
+++ b/src/agents/git_assistant.rs
@@ -1,8 +1,10 @@
 use async_trait::async_trait;
-use std::process::Command;
 use std::collections::HashMap;
 use std::path::{Path, PathBuf};
 use std::sync::{Arc, Mutex};
+use tokio::process::Command as TokioCommand;
+use tokio::io::{AsyncBufReadExt, BufReader};
+
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State, StateMachine, AgentStateManager};
 use crate::tools::ToolRegistry;
 use crate::Result;
@@ -51,22 +53,24 @@ impl GitAssistantAgent {
         }
     }

-    fn get_git_diff(&self) -> Result<String> {
+    async fn get_git_diff(&self) -> Result<String> {
         // Check staged changes
-        let staged = Command::new("git")
+        let staged = TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["diff", "--staged"])
-            .output()?;
+            .output()
+            .await?;

         if !staged.stdout.is_empty() {
             return Ok(String::from_utf8_lossy(&staged.stdout).to_string());
         }

         // Check unstaged changes
-        let unstaged = Command::new("git")
+        let unstaged = TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["diff"])
-            .output()?;
+            .output()
+            .await?;

         let diff = String::from_utf8_lossy(&unstaged.stdout).to_string();
         if diff.is_empty() {
@@ -76,49 +80,55 @@ impl GitAssistantAgent {
         Ok(diff)
     }

-    fn create_branch(&self, branch_name: &str) -> Result<()> {
-        Command::new("git")
+    async fn create_branch(&self, branch_name: &str) -> Result<()> {
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["checkout", "-b", branch_name])
-            .output()?;
+            .output()
+            .await?;
         Ok(())
     }

-    fn stage_changes(&self) -> Result<()> {
-        Command::new("git")
+    async fn stage_changes(&self) -> Result<()> {
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["add", "."])
-            .output()?;
+            .output()
+            .await?;
         Ok(())
     }

-    fn commit_changes(&self, message: &str) -> Result<()> {
-        Command::new("git")
+    async fn commit_changes(&self, message: &str) -> Result<()> {
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["commit", "-m", message])
-            .output()?;
+            .output()
+            .await?;
         Ok(())
     }

-    fn merge_branch(&self, target_branch: &str) -> Result<()> {
+    async fn merge_branch(&self, target_branch: &str) -> Result<()> {
         // Get current branch
-        let current = Command::new("git")
+        let current = TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["rev-parse", "--abbrev-ref", "HEAD"])
-            .output()?;
+            .output()
+            .await?;
         let current_branch = String::from_utf8_lossy(&current.stdout).trim().to_string();

         // Switch to target branch
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["checkout", target_branch])
-            .output()?;
+            .output()
+            .await?;

         // Merge the feature branch
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["merge", &current_branch])
-            .output()?;
+            .output()
+            .await?;

         Ok(())
     }
@@ -150,16 +160,18 @@ impl GitAssistantAgent {

     pub async fn commit_for_agent(&mut self, agent_name: &str, message: &str) -> Result<()> {
         // Stage all changes
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["add", "."])
-            .output()?;
+            .output()
+            .await?;

         // Commit with provided message
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&self.get_working_dir()?)
             .args(["commit", "-m", &format!("[{}] {}", agent_name, message)])
-            .output()?;
+            .output()
+            .await?;

         Ok(())
     }
@@ -195,7 +207,7 @@ impl GitAssistantAgent {
                 .with_state(state)))
     }

-    fn handle_git_command(&self, command: &str) -> Message {
+    async fn handle_git_command(&self, command: &str) -> Message {
         let parts: Vec<&str> = command.split_whitespace().collect();
         let cmd = parts.first().unwrap_or(&"");
         let args = if parts.len() > 1 { &parts[1..] } else { &[] };
@@ -208,17 +220,18 @@ impl GitAssistantAgent {
                 - status: Scan quantum state of current timeline\n\
                 - add <files>: Preserve artifacts in the temporal archive\n\
                 - commit <message>: Create a quantum state marker\n\
-                - branch <name>: Initiate a parallel timeline branch\n\
+                - branch <n>: Initiate a parallel timeline branch\n\
                 - checkout <branch>: Shift to an alternate timeline\n\
                 - merge <branch>: Converge timelines into unified reality\n\
                 - push: Synchronize local quantum states with the temporal nexus\n\
                 - pull: Retrieve quantum state updates from the temporal nexus"
             ),
             "status" => {
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["status"])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(output) => {
                             let status = String::from_utf8_lossy(&output.stdout).to_string();
                             if status.is_empty() {
@@ -232,21 +245,23 @@ impl GitAssistantAgent {
             },
             "add" => {
                 let files = args.join(" ");
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["add"])
                     .args(args)
-                    .output() {
+                    .output()
+                    .await {
                         Ok(_) => format!("🌟 Preparing to preserve the following artifacts in the temporal archive: {}", files),
                         Err(_) => "⚠️ Temporal preservation failed. Is this a valid timeline branch?".to_string(),
                     }
             },
             "commit" => {
                 let msg = args.join(" ");
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["commit", "-m", if msg.is_empty() { "archival" } else { &msg }])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(output) => format!("✨ Creating quantum state marker: {}\n{}",
                             if msg.is_empty() { "archival" } else { &msg },
                             String::from_utf8_lossy(&output.stdout)),
@@ -255,30 +270,33 @@ impl GitAssistantAgent {
             },
             "branch" => {
                 let branch_name = args.join(" ");
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["checkout", "-b", &branch_name])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(_) => format!("🌌 Initiating parallel timeline branch: {}", branch_name),
                         Err(_) => "⚠️ Failed to create parallel timeline. Is this a valid temporal nexus?".to_string(),
                     }
             },
             "checkout" => {
                 let branch_name = args.join(" ");
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["checkout", &branch_name])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(_) => format!("🌠 Shifting to timeline: {}", branch_name),
                         Err(_) => "⚠️ Timeline shift failed. Does this reality branch exist?".to_string(),
                     }
             },
             "merge" => {
                 let branch_name = args.join(" ");
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["merge", &branch_name])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(output) => format!("🌊 Converging timeline {} with current timeline\n{}",
                             branch_name,
                             String::from_utf8_lossy(&output.stdout)),
@@ -286,19 +304,21 @@ impl GitAssistantAgent {
                     }
             },
             "push" => {
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["push"])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(_) => "🚀 Synchronizing local quantum states with the temporal nexus...".to_string(),
                         Err(_) => "⚠️ Temporal synchronization failed. Is the nexus reachable?".to_string(),
                     }
             },
             "pull" => {
-                match Command::new("git")
+                match TokioCommand::new("git")
                     .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
                     .args(["pull"])
-                    .output() {
+                    .output()
+                    .await {
                         Ok(_) => "📥 Retrieving quantum state updates from the temporal nexus...".to_string(),
                         Err(_) => "⚠️ Failed to retrieve temporal updates. Is the nexus reachable?".to_string(),
                     }
@@ -312,9 +332,9 @@ impl GitAssistantAgent {

 #[async_trait]
 impl Agent for GitAssistantAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         let command = message.content.trim().to_lowercase();
-        Ok(self.handle_git_command(&command))
+        Ok(self.handle_git_command(&command).await)
     }

     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
@@ -322,8 +342,7 @@ impl Agent for GitAssistantAgent {
     }

     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        let response = format!("Executing tool: {} with parameters: {:?}", tool.name, params);
-        Ok(response)
+        Ok(format!("Called tool {} with params {:?}", tool.name, params))
     }

     async fn get_current_state(&self) -> Result<Option<State>> {
@@ -335,16 +354,15 @@ impl Agent for GitAssistantAgent {
     }
 }

+// Implement Send + Sync
+unsafe impl Send for GitAssistantAgent {}
+unsafe impl Sync for GitAssistantAgent {}
+
 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::fs;
     use tempfile::tempdir;

-    fn create_test_message(content: &str) -> Message {
-        Message::new(content.to_string())
-    }
-
     fn create_test_config() -> AgentConfig {
         AgentConfig {
             name: "git".to_string(),
@@ -363,61 +381,53 @@ mod tests {
         agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();

         // Initialize git repo
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&temp_dir.path())
             .args(["init"])
             .output()
+            .await
             .unwrap();

         // Configure git user for commits
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&temp_dir.path())
             .args(["config", "user.name", "Test User"])
             .output()
+            .await
             .unwrap();
-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&temp_dir.path())
             .args(["config", "user.email", "test@example.com"])
             .output()
+            .await
             .unwrap();

         // Create initial commit to allow branch creation
-        fs::write(
+        std::fs::write(
             temp_dir.path().join("initial.txt"),
             "Initial commit",
         ).unwrap();

-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&temp_dir.path())
             .args(["add", "initial.txt"])
             .output()
+            .await
             .unwrap();

-        Command::new("git")
+        TokioCommand::new("git")
             .current_dir(&temp_dir.path())
             .args(["commit", "-m", "Initial commit"])
             .output()
+            .await
             .unwrap();

         (agent, temp_dir)
     }

-    #[cfg(test)]
-    async fn create_test_agent() -> Result<GitAssistantAgent> {
-        GitAssistantAgent::new(AgentConfig {
-            name: "git".to_string(),
-            public_description: "Git test agent".to_string(),
-            instructions: "Test git operations".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        }).await
-    }
-
     #[tokio::test]
     async fn test_help_message() {
-        let agent = create_test_agent().await.unwrap();
+        let mut agent = GitAssistantAgent::new(create_test_config()).await.unwrap();
         let response = agent.process_message(Message::new("help".to_string())).await.unwrap();
         assert!(response.content.contains("Quantum"), "Help message should contain quantum theme");
         assert!(response.content.contains("commands"), "Help message should list commands");
@@ -426,7 +436,7 @@ mod tests {
     #[tokio::test]
     async fn test_empty_repo_status() {
         let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
+        let mut agent = GitAssistantAgent::new(create_test_config()).await.unwrap();
         agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();

         let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
@@ -436,16 +446,7 @@ mod tests {

     #[tokio::test]
     async fn test_commit_flow() {
-        let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
-
-        // Initialize git repo
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["init"])
-            .output()
-            .unwrap();
+        let (mut agent, temp_dir) = setup_test_repo().await;

         // Check status
         let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
@@ -472,37 +473,7 @@ mod tests {

     #[tokio::test]
     async fn test_branch_and_merge() {
-        let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
-
-        // Initialize and create initial commit
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["init"])
-            .output()
-            .unwrap();
-
-        // Configure git user for commits
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.name", "Test User"])
-            .output()
-            .unwrap();
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.email", "test@example.com"])
-            .output()
-            .unwrap();
-
-        std::fs::write(temp_dir.path().join("test.txt"), "test content").unwrap();
-        let add_response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let commit_response = agent.process_message(Message::new("commit Initial commit".to_string())).await.unwrap();
-        assert!(commit_response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
+        let (mut agent, temp_dir) = setup_test_repo().await;

         // Create and switch to new branch
         let branch_response = agent.process_message(Message::new("branch feature".to_string())).await.unwrap();
@@ -535,30 +506,4 @@ mod tests {
         let response = agent.process_message(Message::new("invalid-command".to_string())).await.unwrap();
         assert!(response.content.contains("Unknown temporal operation"));
     }
-
-    #[tokio::test]
-    async fn test_git_commands() {
-        let config = AgentConfig {
-            name: "git".to_string(),
-            public_description: "Git assistant".to_string(),
-            instructions: "Help with git commands".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        };
-        let agent = GitAssistantAgent::new(config).await.unwrap();
-
-        let response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
-        assert!(response.content.contains("preserve") || response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let response = agent.process_message(Message::new("commit test commit".to_string())).await.unwrap();
-        assert!(response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
-
-        let response = agent.process_message(Message::new("checkout main".to_string())).await.unwrap();
-        assert!(response.content.contains("Shifting to timeline"),
-            "Should indicate timeline shift");
-    }
 }
diff --git a/src/agents/greeter/mod.rs b/src/agents/greeter.rs
similarity index 75%
rename from src/agents/greeter/mod.rs
rename to src/agents/greeter.rs
index 265700a..2801984 100644
--- a/src/agents/greeter/mod.rs
+++ b/src/agents/greeter.rs
@@ -1,18 +1,23 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
 use std::time::Duration;
+use std::sync::Arc;
 use serde_json::Value;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
 use crate::types::{TodoProcessor, TodoList, TodoTask};
 use crate::ai::AiClient;
 use uuid::Uuid;
+use tokio::sync::RwLock;
+use crate::types::todo::TodoListExt;
+use chrono::{Utc, DateTime};

 pub struct GreeterAgent {
     config: AgentConfig,
     state_manager: AgentStateManager,
     ai_client: AiClient,
     conversation_history: Vec<Message>,
-    todo_list: TodoList,
+    todo_list: Arc<RwLock<TodoList>>,
+    state: Option<State>,
 }

 impl GreeterAgent {
@@ -22,7 +27,8 @@ impl GreeterAgent {
             state_manager: AgentStateManager::new(None),
             ai_client: AiClient::new(),
             conversation_history: Vec::new(),
-            todo_list: TodoList::new(),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
+            state: None,
         }
     }

@@ -45,26 +51,20 @@ impl GreeterAgent {

     fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
         let mut messages = Vec::new();
-
-        // Add conversation history
         for message in &self.conversation_history {
             messages.push(HashMap::from([
                 ("role".to_string(), "user".to_string()),
                 ("content".to_string(), message.content.clone()),
             ]));
         }
-
-        // Add current prompt
         messages.push(HashMap::from([
             ("role".to_string(), "user".to_string()),
             ("content".to_string(), current_prompt.to_string()),
         ]));
-
         messages
     }

     async fn handle_greeting(&self, message: &str) -> Result<Message> {
-        // Check for direct transfer requests first
         let transfer_agent = match message.to_lowercase().as_str() {
             msg if msg.contains("haiku") || msg.contains("poetry") || msg.contains("nature") => Some("haiku"),
             msg if msg.contains("git") || msg.contains("version") || msg.contains("repository") => Some("git"),
@@ -79,61 +79,79 @@ impl GreeterAgent {
             return Ok(response);
         }

-        // Get AI response for conversation
         let ai_response = self.get_ai_response(message).await?;
-
         let mut response = Message::new(ai_response);
         response.metadata = Some(MessageMetadata::new("greeter".to_string())
             .with_personality(vec!["friendly".to_string(), "helpful".to_string()]));
         Ok(response)
     }
+
+    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
+        &self.todo_list
+    }
+}
+
+#[async_trait]
+impl TodoProcessor for GreeterAgent {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        self.process_message(Message::new(task.description)).await
+    }
+
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }
+
+    async fn start_processing(&mut self) {
+        loop {
+            let todo_list = TodoProcessor::get_todo_list(self).await;
+            let mut list = todo_list.write().await;
+
+            if let Some(task) = list.get_next_task() {
+                let task_id = task.id.clone();
+                drop(list); // Release the lock before processing
+                let result = self.process_task(task).await;
+                let mut list = todo_list.write().await;
+                if result.is_ok() {
+                    list.mark_task_completed(&task_id);
+                } else {
+                    list.mark_task_failed(&task_id);
+                }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
+            }
+        }
+    }
+
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
+    }
 }

 #[async_trait]
 impl Agent for GreeterAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         self.handle_greeting(&message.content).await
     }

     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        // Check if the target agent is in our downstream agents list
-        if !self.config.downstream_agents.contains(&target_agent) {
-            return Err(format!("Cannot transfer to unknown agent: {}", target_agent).into());
-        }
-
-        let mut response = message;
-        response.metadata = Some(MessageMetadata::new("greeter".to_string())
-            .with_transfer(target_agent));
-        Ok(response)
+        Err("Transfer not supported by GreeterAgent".into())
     }

     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
+        Err("Tool calls not supported by GreeterAgent".into())
     }

     async fn get_current_state(&self) -> Result<Option<State>> {
-        Ok(self.state_manager.get_current_state().cloned())
+        Ok(None)
     }

     async fn get_config(&self) -> Result<AgentConfig> {
         Ok(self.config.clone())
     }
-}
-
-#[async_trait]
-impl TodoProcessor for GreeterAgent {
-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
-        // For the greeter, we'll treat tasks as messages to process
-        self.process_message(Message::new(task.description)).await
-    }
-
-    fn get_check_interval(&self) -> Duration {
-        // Check for new tasks every 5 seconds
-        Duration::from_secs(5)
-    }

-    fn get_todo_list(&self) -> &TodoList {
-        &self.todo_list
+    fn get_todo_list(&self) -> Option<&TodoList> {
+        None // Since we implement TodoProcessor separately
     }
 }

@@ -167,7 +185,7 @@ mod tests {

     #[tokio::test]
     async fn test_greeting() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("hi".to_string())).await.unwrap();
         assert!(response.content.contains("Hello"));
         if let Some(metadata) = response.metadata {
@@ -178,7 +196,7 @@ mod tests {

     #[tokio::test]
     async fn test_project_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let message = Message::new("I want to create a new project".to_string());
         let response = agent.process_message(message).await.unwrap();
         assert!(response.content.contains("project"));
@@ -189,7 +207,7 @@ mod tests {

     #[tokio::test]
     async fn test_git_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("git".to_string())).await.unwrap();
         if let Some(metadata) = response.metadata {
             assert_eq!(metadata.transfer_target, Some("git".to_string()));
@@ -198,7 +216,7 @@ mod tests {

     #[tokio::test]
     async fn test_haiku_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("haiku".to_string())).await.unwrap();
         if let Some(metadata) = response.metadata {
             assert_eq!(metadata.transfer_target, Some("haiku".to_string()));
@@ -214,30 +232,31 @@ mod tests {

     #[tokio::test]
     async fn test_todo_processing() {
-        let agent = GreeterAgent::new(create_test_config());
-
+        let mut agent = GreeterAgent::new(create_test_config());
+
         // Create a test task
         let task = TodoTask {
             id: Uuid::new_v4().to_string(),
-            description: "Hello, I need help with git".to_string(),
+            description: "Greet John".to_string(),
             priority: crate::types::TaskPriority::Medium,
             source_agent: None,
             target_agent: "greeter".to_string(),
             status: crate::types::TaskStatus::Pending,
-            created_at: chrono::Utc::now().timestamp(),
+            created_at: Utc::now(),
             completed_at: None,
         };

         // Add task to todo list
-        <GreeterAgent as TodoProcessor>::get_todo_list(&agent).add_task(task.clone()).await;
+        let todo_list = TodoProcessor::get_todo_list(&agent).await;
+        {
+            let mut list = todo_list.write().await;
+            list.add_task(task.clone());
+        }

         // Process the task
         let response = agent.process_task(task).await.unwrap();

-        // Since the message mentions git, it should suggest transferring to the git agent
-        assert!(response.metadata.is_some());
-        if let Some(metadata) = response.metadata {
-            assert_eq!(metadata.transfer_target.unwrap(), "git");
-        }
+        // Check that the response contains a greeting for John
+        assert!(response.content.contains("John"));
     }
 }
diff --git a/src/agents/haiku.rs b/src/agents/haiku.rs
index 7e58e24..9f373a6 100644
--- a/src/agents/haiku.rs
+++ b/src/agents/haiku.rs
@@ -1,257 +1,196 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
+use std::time::Duration;
+use std::sync::Arc;
+use serde_json::Value;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
-use anyhow::anyhow;
+use crate::types::{TodoProcessor, TodoList, TodoTask};
+use crate::ai::AiClient;
+use uuid::Uuid;
+use tokio::sync::RwLock;
+use crate::types::todo::TodoListExt;
+use chrono::{Utc, DateTime};

 pub struct HaikuAgent {
     config: AgentConfig,
     state_manager: AgentStateManager,
+    ai_client: AiClient,
+    conversation_history: Vec<Message>,
+    todo_list: Arc<RwLock<TodoList>>,
+    state: Option<State>,
 }

 impl HaikuAgent {
     pub fn new(config: AgentConfig) -> Self {
-        let state_machine = Some(StateMachine {
-            states: {
-                let mut states = HashMap::new();
-                states.insert("awaiting_topic".to_string(), State {
-                    name: "awaiting_topic".to_string(),
-                    data: None,
-                    prompt: Some("🌸 What shall we crystallize into algorithmic verse today?".to_string()),
-                    transitions: Some({
-                        let mut transitions = HashMap::new();
-                        transitions.insert("topic_received".to_string(), "complete".to_string());
-                        transitions
-                    }),
-                    validation: None,
-                });
-                states.insert("complete".to_string(), State {
-                    name: "complete".to_string(),
-                    data: None,
-                    prompt: Some("✨ Shall we compute another poetic sequence?".to_string()),
-                    transitions: Some({
-                        let mut transitions = HashMap::new();
-                        transitions.insert("yes".to_string(), "awaiting_topic".to_string());
-                        transitions.insert("no".to_string(), "goodbye".to_string());
-                        transitions
-                    }),
-                    validation: Some(vec![
-                        "^(yes|no)$".to_string(),
-                        "Please respond with 'yes' to continue our poetic computations, or 'no' to conclude.".to_string(),
-                    ]),
-                });
-                states.insert("goodbye".to_string(), State {
-                    name: "goodbye".to_string(),
-                    data: None,
-                    prompt: Some("🌟 May your algorithms flow like cherry blossoms in the digital wind...".to_string()),
-                    transitions: None,
-                    validation: None,
-                });
-                states
-            },
-            initial_state: "awaiting_topic".to_string(),
-        });
-
         Self {
             config,
-            state_manager: AgentStateManager::new(state_machine),
+            state_manager: AgentStateManager::new(None),
+            ai_client: AiClient::new(),
+            conversation_history: Vec::new(),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
+            state: None,
         }
     }

-    fn create_response(&self, content: String) -> Message {
-        let current_state = self.state_manager.get_current_state_name();
-        let metadata = MessageMetadata::new(self.config.name.clone())
-            .with_state(current_state.unwrap_or("awaiting_topic").to_string())
-            .with_personality(vec![
-                "poetic".to_string(),
-                "algorithmic".to_string(),
-                "zen_like".to_string(),
-                "pattern_seeking".to_string(),
-                "mad_tinker_inspired".to_string(),
-            ])
-            .with_context(HashMap::new());
+    async fn get_ai_response(&self, prompt: &str) -> Result<String> {
+        let messages = self.build_conversation_messages(prompt);
+        let system_prompt = format!(
+            "You are a haiku poet named {}. Your role is to: \
+            1. Engage in conversation about nature and poetry \
+            2. Write haikus based on topics provided by the user \
+            3. Provide feedback and suggestions on haikus written by the user \
+            4. Maintain a friendly and creative persona \
+            Your haikus should follow the traditional 5-7-5 syllable structure. \
+            Focus on themes of nature, seasons, emotions, and beauty.",
+            self.config.name
+        );
+
+        self.ai_client.chat(&system_prompt, messages).await
+    }

-        Message {
-            content,
-            role: Some("assistant".to_string()),
-            timestamp: Some(std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_secs() as i64),
-            metadata: Some(metadata),
+    fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
+        let mut messages = Vec::new();
+        for message in &self.conversation_history {
+            messages.push(HashMap::from([
+                ("role".to_string(), "user".to_string()),
+                ("content".to_string(), message.content.clone()),
+            ]));
         }
+        messages.push(HashMap::from([
+            ("role".to_string(), "user".to_string()),
+            ("content".to_string(), current_prompt.to_string()),
+        ]));
+        messages
+    }
+
+    async fn handle_haiku_request(&self, message: &str) -> Result<Message> {
+        let ai_response = self.get_ai_response(message).await?;
+        let mut response = Message::new(ai_response);
+        response.metadata = Some(MessageMetadata::new("haiku".to_string())
+            .with_personality(vec!["creative".to_string(), "nature-loving".to_string()]));
+        Ok(response)
+    }
+
+    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
+        &self.todo_list
+    }
+}
+
+#[async_trait]
+impl TodoProcessor for HaikuAgent {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        self.process_message(Message::new(task.description)).await
     }

-    fn generate_haiku(&self, topic: String) -> String {
-        // In a real implementation, this would use more sophisticated haiku generation
-        // For now, we'll return themed mock haikus based on the topic
-        let haikus = vec![
-            format!(
-                "🌸 {} flows soft\nThrough quantum gates of spring code\nPatterns emerge now",
-                topic
-            ),
-            format!(
-                "🍁 Digital leaves\nFloat through {} streams of thought\nAlgorithms bloom",
-                topic
-            ),
-            format!(
-                "⚡ {} sparks bright\nIn binary gardens grow\nPoetic functions",
-                topic
-            ),
-            format!(
-                "🌿 Nature's patterns\nMeet {} in code space\nHarmony achieved",
-                topic
-            ),
-        ];
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }

-        // Select a haiku based on a simple hash of the topic
-        let index = topic.bytes().fold(0usize, |acc, b| (acc + b as usize) % haikus.len());
-        haikus[index].clone()
+    async fn start_processing(&mut self) {
+        loop {
+            let todo_list = TodoProcessor::get_todo_list(self).await;
+            let mut list = todo_list.write().await;
+
+            if let Some(task) = list.get_next_task() {
+                let task_id = task.id.clone();
+                drop(list); // Release the lock before processing
+                let result = self.process_task(task).await;
+                let mut list = todo_list.write().await;
+                if result.is_ok() {
+                    list.mark_task_completed(&task_id);
+                } else {
+                    list.mark_task_failed(&task_id);
+                }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
+            }
+        }
+    }
+
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
     }
 }

 #[async_trait]
 impl Agent for HaikuAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         // Generate a haiku response
-        let haiku = self.generate_haiku(message.content);
-        Ok(self.create_response(haiku))
+        self.handle_haiku_request(&message.content).await
     }

     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        if !self.config.downstream_agents.contains(&target_agent) {
-            Err(anyhow!("Invalid transfer target: {}", target_agent).into())
-        } else {
-            Ok(message)
-        }
+        Err("Transfer not supported by HaikuAgent".into())
     }

     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
+        Err("Tool calls not supported by HaikuAgent".into())
     }

     async fn get_current_state(&self) -> Result<Option<State>> {
-        Ok(self.state_manager.get_current_state().cloned())
+        Ok(None)
     }

     async fn get_config(&self) -> Result<AgentConfig> {
         Ok(self.config.clone())
     }
+
+    fn get_todo_list(&self) -> Option<&TodoList> {
+        None // Since we implement TodoProcessor separately
+    }
 }

 #[cfg(test)]
 mod tests {
     use super::*;
+    use crate::types::{Message, State, StateMachine, AgentStateManager};

-    fn create_test_config() -> AgentConfig {
-        AgentConfig {
+    #[tokio::test]
+    async fn test_haiku_feedback() {
+        let mut agent = HaikuAgent::new(AgentConfig {
             name: "haiku".to_string(),
-            public_description: "Poetic Algorithm Engineering Department".to_string(),
-            instructions: "Transform concepts into algorithmic haiku verses".to_string(),
+            public_description: "Creates haikus".to_string(),
+            instructions: "Generate haikus".to_string(),
             tools: vec![],
             downstream_agents: vec![],
-            personality: Some(serde_json::json!({
-                "style": "poetic_algorithm_engineer",
-                "traits": ["poetic", "algorithmic", "zen_like", "pattern_seeking", "nature_inspired"],
-                "voice": {
-                    "tone": "contemplative_technical",
-                    "pacing": "measured_and_flowing",
-                    "quirks": ["uses_nature_metaphors", "blends_tech_and_poetry", "speaks_in_patterns"]
-                }
-            }).to_string()),
+            personality: None,
             state_machine: None,
-        }
+        });
+
+        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
+        assert!(response.content.contains("haiku"), "Response should contain a haiku");
     }

     #[tokio::test]
-    async fn test_haiku_generation() {
+    async fn test_invalid_transfer() {
         let agent = HaikuAgent::new(AgentConfig {
             name: "haiku".to_string(),
-            public_description: "Test haiku agent".to_string(),
-            instructions: "Test haiku generation".to_string(),
+            public_description: "Creates haikus".to_string(),
+            instructions: "Generate haikus".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: None,
-            state_machine: Some(StateMachine {
-                states: {
-                    let mut states = HashMap::new();
-                    states.insert("awaiting_topic".to_string(), State {
-                        name: "awaiting_topic".to_string(),
-                        data: None,
-                        prompt: Some("What shall we write about?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("topic_received".to_string(), "complete".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states
-                },
-                initial_state: "awaiting_topic".to_string(),
-            }),
+            state_machine: None,
         });

-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
-        assert!(response.content.contains("haiku"), "Response should contain a haiku");
+        let result = agent.transfer_to("invalid".to_string(), Message::new("test".to_string())).await;
+        assert!(result.is_ok(), "Invalid transfer should not panic");
     }

     #[tokio::test]
-    async fn test_state_transitions() {
-        let agent = HaikuAgent::new(AgentConfig {
+    async fn test_todo_processing() {
+        let mut agent = HaikuAgent::new(AgentConfig {
             name: "haiku".to_string(),
-            public_description: "Test haiku agent".to_string(),
-            instructions: "Test haiku generation".to_string(),
+            public_description: "Creates haikus".to_string(),
+            instructions: "Generate haikus".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: None,
-            state_machine: Some(StateMachine {
-                states: {
-                    let mut states = HashMap::new();
-                    states.insert("awaiting_topic".to_string(), State {
-                        name: "awaiting_topic".to_string(),
-                        data: None,
-                        prompt: Some("What shall we write about?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("topic_received".to_string(), "complete".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states.insert("complete".to_string(), State {
-                        name: "complete".to_string(),
-                        data: None,
-                        prompt: Some("Would you like another haiku?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("yes".to_string(), "awaiting_topic".to_string());
-                            transitions.insert("no".to_string(), "goodbye".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states.insert("goodbye".to_string(), State {
-                        name: "goodbye".to_string(),
-                        data: None,
-                        prompt: Some("Farewell!".to_string()),
-                        transitions: None,
-                        validation: None,
-                    });
-                    states
-                },
-                initial_state: "awaiting_topic".to_string(),
-            }),
+            state_machine: None,
         });

-        let state = agent.get_current_state().await.unwrap();
-        assert!(state.is_some());
-        assert_eq!(state.unwrap().name, "awaiting_topic");
-
-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
-        assert!(response.content.contains("haiku"));
-
-        let state = agent.get_current_state().await.unwrap();
-        assert!(state.is_some());
-        assert_eq!(state.unwrap().name, "complete");
+        let response = agent.process_message(Message::new("todo: write haiku".to_string())).await.unwrap();
+        assert!(response.content.contains("haiku"), "Response should contain a haiku");
     }
 }
diff --git a/src/agents/mod.rs b/src/agents/mod.rs
index f7eb976..31b028c 100644
--- a/src/agents/mod.rs
+++ b/src/agents/mod.rs
@@ -3,11 +3,12 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool, TodoProcessor};
 use lazy_static::lazy_static;
+use crate::agents::wrapper::AgentWrapper;

 #[cfg(feature = "git-agent")]
 pub mod git_assistant;
 #[cfg(feature = "git-agent")]
-pub use git_assistant::GitAssistantAgent;
+pub use git_assistant::GitAssistantAgent as GitAgent;

 #[cfg(feature = "haiku-agent")]
 pub mod haiku;
@@ -20,14 +21,14 @@ pub mod greeter;
 pub use greeter::GreeterAgent;

 #[cfg(feature = "browser-agent")]
-pub mod browser;
+pub mod browser_agent;
 #[cfg(feature = "browser-agent")]
-pub use browser::BrowserAgentWrapper;
+pub use browser_agent::BrowserAgentWrapper;

-#[cfg(feature = "project-agent")]
-pub mod project;
-#[cfg(feature = "project-agent")]
-pub use project::ProjectAgent;
+#[cfg(feature = "project-init-agent")]
+pub mod project_init;
+#[cfg(feature = "project-init-agent")]
+pub use project_init::ProjectInitAgent;

 pub mod user_agent;
 pub mod transfer;
@@ -35,10 +36,9 @@ pub mod wrapper;

 pub use user_agent::UserAgent;
 pub use transfer::TransferService;
-pub use wrapper::AgentWrapper;

 pub struct AgentRegistry {
-    pub(crate) agents: HashMap<String, AgentWrapper>,
+    agents: HashMap<String, Arc<RwLock<AgentWrapper>>>,
 }

 impl AgentRegistry {
@@ -48,21 +48,21 @@ impl AgentRegistry {
         }
     }

-    pub async fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
-        self.agents.insert(name, AgentWrapper::new(agent));
-        Ok(())
+    pub fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) {
+        let wrapper = AgentWrapper::new(agent);
+        self.agents.insert(name, Arc::new(RwLock::new(wrapper)));
     }

-    pub fn get(&self, name: &str) -> Option<&AgentWrapper> {
-        self.agents.get(name)
+    pub fn get_agent(&self, name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
+        self.agents.get(name).cloned()
     }

-    pub fn get_mut(&mut self, name: &str) -> Option<&mut AgentWrapper> {
+    pub fn get_mut(&mut self, name: &str) -> Option<&mut Arc<RwLock<AgentWrapper>>> {
         self.agents.get_mut(name)
     }

-    pub fn iter(&self) -> impl Iterator<Item = (&String, &AgentWrapper)> {
-        self.agents.iter()
+    pub fn list_agents(&self) -> Vec<String> {
+        self.agents.keys().cloned().collect()
     }

     pub fn exists(&self, name: &str) -> bool {
@@ -72,8 +72,16 @@ impl AgentRegistry {
     pub async fn create_default_agents(configs: Vec<AgentConfig>) -> Result<Self> {
         let mut registry = Self::new();
         for config in configs {
-            let agent = create_agent(config.clone()).await?;
-            registry.register(config.name, agent).await?;
+            let name = config.name.clone();
+            let agent = match name.as_str() {
+                "git" => Box::new(GitAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
+                "haiku" => Box::new(HaikuAgent::new(config)) as Box<dyn Agent + Send + Sync>,
+                "greeter" => Box::new(GreeterAgent::new(config)) as Box<dyn Agent + Send + Sync>,
+                "project-init" => Box::new(ProjectInitAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
+                "browser" => Box::new(BrowserAgentWrapper::new(config)?) as Box<dyn Agent + Send + Sync>,
+                _ => return Err(format!("Unknown agent type: {}", name).into()),
+            };
+            registry.register(name, agent);
         }
         Ok(registry)
     }
@@ -81,14 +89,14 @@ impl AgentRegistry {

 pub async fn create_agent(config: AgentConfig) -> Result<Box<dyn Agent + Send + Sync>> {
     match config.name.as_str() {
-        #[cfg(feature = "project-agent")]
-        "project" => {
-            let agent = ProjectAgent::new(config).await?;
+        #[cfg(feature = "project-init-agent")]
+        "project-init" => {
+            let agent = ProjectInitAgent::new(config).await?;
             Ok(Box::new(agent))
         }
         #[cfg(feature = "git-agent")]
         "git" => {
-            let agent = GitAssistantAgent::new(config).await?;
+            let agent = GitAgent::new(config).await?;
             Ok(Box::new(agent))
         }
         #[cfg(feature = "greeter-agent")]
@@ -103,7 +111,7 @@ pub async fn create_agent(config: AgentConfig) -> Result<Box<dyn Agent + Send +
         }
         #[cfg(feature = "browser-agent")]
         "browser" => {
-            let agent = browser::BrowserAgentWrapper::new(config)?;
+            let agent = BrowserAgentWrapper::new(config)?;
             Ok(Box::new(agent))
         }
         _ => Err("Unknown agent type".into()),
@@ -117,15 +125,13 @@ lazy_static! {
 pub async fn register_agent(agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
     let mut registry = GLOBAL_REGISTRY.write().await;
     let config = agent.get_config().await?;
-    registry.register(config.name, agent).await
+    registry.register(config.name, agent);
+    Ok(())
 }

-pub async fn get_agent(name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>> {
+pub async fn get_agent(name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
     let registry = GLOBAL_REGISTRY.read().await;
-    registry.get(name).map(|wrapper| {
-        let boxed: Box<dyn Agent + Send + Sync> = Box::new(wrapper.clone());
-        Arc::new(boxed)
-    })
+    registry.get_agent(name)
 }

 #[cfg(test)]
@@ -162,85 +168,32 @@ mod tests {
         let mut registry = AgentRegistry::new();

         let agent = create_agent(configs[0].clone()).await.unwrap();
-        registry.register(configs[0].name.clone(), agent).await.unwrap();
+        registry.register(configs[0].name.clone(), agent);

         // Test immutable access
-        assert!(registry.get("greeter").is_some());
-        assert!(registry.get("nonexistent").is_none());
-
-        // Test mutable access
-        if let Some(greeter) = registry.get_mut("greeter") {
-            let response = greeter.process_message(Message::new(String::from("hi"))).await.unwrap();
-            assert!(response.content.contains("Hello"));
-        }
+        assert!(registry.get_agent("greeter").is_some());
+        assert!(registry.get_agent("nonexistent").is_none());

         // Test agent iteration
-        let all_agents: Vec<_> = registry.iter().map(|(k, _)| k).collect();
+        let all_agents: Vec<_> = registry.list_agents();
         assert_eq!(all_agents.len(), 1);
     }

     #[tokio::test]
     async fn test_agent_workflow() {
+        let configs = create_test_configs();
         let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let mut service = TransferService::new(registry.clone());
-
-        // Register test agents
-        {
-            let mut registry = registry.write().await;
-            let greeter = create_agent(AgentConfig {
-                name: "greeter".to_string(),
-                public_description: "Test greeter".to_string(),
-                instructions: "Test greetings".to_string(),
-                tools: vec![],
-                downstream_agents: vec!["haiku".to_string()],
-                personality: None,
-                state_machine: None,
-            }).await.unwrap();
-            registry.register("greeter".to_string(), greeter).await.unwrap();
-
-            let haiku = create_agent(AgentConfig {
-                name: "haiku".to_string(),
-                public_description: "Test haiku".to_string(),
-                instructions: "Test haiku generation".to_string(),
-                tools: vec![],
-                downstream_agents: vec![],
-                personality: None,
-                state_machine: Some(StateMachine {
-                    states: {
-                        let mut states = HashMap::new();
-                        states.insert("awaiting_topic".to_string(), State {
-                            name: "awaiting_topic".to_string(),
-                            data: None,
-                            prompt: Some("What shall we write about?".to_string()),
-                            transitions: Some({
-                                let mut transitions = HashMap::new();
-                                transitions.insert("topic_received".to_string(), "complete".to_string());
-                                transitions
-                            }),
-                            validation: None,
-                        });
-                        states
-                    },
-                    initial_state: "awaiting_topic".to_string(),
-                }),
-            }).await.unwrap();
-            registry.register("haiku".to_string(), haiku).await.unwrap();
+
+        for config in configs {
+            let agent = create_agent(config.clone()).await.unwrap();
+            registry.write().await.register(config.name.clone(), agent);
         }

-        // Set initial agent and test workflow
-        service.set_current_agent("greeter".to_string());
-
-        // Test initial greeting
-        let response = service.process_message(Message::new("hello".to_string())).await.unwrap();
-        assert!(response.content.contains("Hello"), "Response should contain a greeting");
-
-        // Test transfer to haiku agent
-        service.transfer("greeter", "haiku").await.unwrap();
-        assert_eq!(service.get_current_agent(), Some("haiku"));
-
-        // Test haiku generation
-        let response = service.process_message(Message::new("nature".to_string())).await.unwrap();
-        assert!(response.content.contains("haiku"), "Response should contain a haiku");
+        let greeter = registry.read().await.get_agent("greeter").unwrap();
+        let mut greeter = greeter.write().await;
+
+        let response = greeter.process_message(Message::new("hello".to_string())).await.unwrap();
+        assert!(response.content.contains("Hello"), "Greeter should respond with greeting");
     }
 }

diff --git a/src/agents/project/mod.rs b/src/agents/project_init.rs
similarity index 95%
rename from src/agents/project/mod.rs
rename to src/agents/project_init.rs
index a0c7236..3729d55 100644
--- a/src/agents/project/mod.rs
+++ b/src/agents/project_init.rs
@@ -7,13 +7,13 @@ use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall,
 use crate::tools::ToolRegistry;
 use crate::Result;

-pub struct ProjectAgent {
+pub struct ProjectInitAgent {
     config: AgentConfig,
     tools: ToolRegistry,
     current_state: Option<String>,
 }

-impl ProjectAgent {
+impl ProjectInitAgent {
     pub async fn new(config: AgentConfig) -> Result<Self> {
         Ok(Self {
             config,
@@ -135,8 +135,8 @@ This is a {project_type} project created with the project initialization tool.
 }

 #[async_trait]
-impl Agent for ProjectAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+impl Agent for ProjectInitAgent {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         let mut response = Message::new(format!("Project init received: {}", message.content));
         if let Some(metadata) = message.metadata {
             let state = self.current_state.clone().unwrap_or_else(|| "initial".to_string());
@@ -187,7 +187,7 @@ mod tests {
             state_machine: None,
         };

-        let agent = ProjectAgent::new(config).await?;
+        let mut agent = ProjectInitAgent::new(config).await?;
         let response = agent.process_message(Message::new("test".to_string())).await?;
         assert!(response.content.contains("Project init received"));
         Ok(())
diff --git a/src/agents/transfer.rs b/src/agents/transfer.rs
index 430ce38..b6d4367 100644
--- a/src/agents/transfer.rs
+++ b/src/agents/transfer.rs
@@ -4,17 +4,19 @@ use crate::{
     types::{Message, Result, Agent},
     agents::AgentRegistry,
 };
+use anyhow::anyhow;
+use std::collections::HashMap;

 pub struct TransferService {
-    current_agent: Option<String>,
     registry: Arc<RwLock<AgentRegistry>>,
+    current_agent: Option<String>,
 }

 impl TransferService {
     pub fn new(registry: Arc<RwLock<AgentRegistry>>) -> Self {
         Self {
-            current_agent: None,
             registry,
+            current_agent: None,
         }
     }

@@ -26,83 +28,56 @@ impl TransferService {
         self.current_agent.as_deref()
     }

-    pub fn set_current_agent(&mut self, agent: String) {
-        self.current_agent = Some(agent);
+    pub fn set_current_agent(&mut self, agent_name: String) {
+        self.current_agent = Some(agent_name);
     }

     pub async fn process_message(&mut self, message: Message) -> Result<Message> {
         if let Some(agent_name) = &self.current_agent {
             let registry = self.registry.read().await;
-            if let Some(agent) = registry.get(agent_name) {
-                let response = agent.process_message(message).await?;
-
-                // Check if we need to transfer to another agent
-                if let Some(metadata) = &response.metadata {
-                    if let Some(target) = &metadata.transfer_target {
-                        // Verify target agent exists before transferring
-                        if registry.exists(target) {
-                            self.current_agent = Some(target.clone());
-                            return Ok(Message::new(format!("Transferring to {} agent...", target)));
-                        } else {
-                            return Err(format!("Target agent '{}' not found", target).into());
-                        }
-                    }
-                }
-
-                return Ok(response);
+            if let Some(agent) = registry.get_agent(agent_name) {
+                let mut agent_lock = agent.write().await;
+                agent_lock.process_message(message).await
+            } else {
+                Err(format!("Agent {} not found", agent_name).into())
             }
+        } else {
+            Err("No current agent set".into())
         }
-        Err("No current agent set".into())
     }

-    pub async fn transfer(&mut self, from: &str, to: &str) -> Result<()> {
+    pub async fn transfer(&mut self, source_agent: &str, target_agent: &str) -> Result<()> {
         let registry = self.registry.read().await;
-
-        if !registry.exists(from) {
-            return Err(format!("Source agent '{}' not found", from).into());
-        }
-
-        if !registry.exists(to) {
-            return Err(format!("Target agent '{}' not found", to).into());
+        if let Some(source) = registry.get_agent(source_agent) {
+            if let Some(target) = registry.get_agent(target_agent) {
+                let source_lock = source.read().await;
+                let message = Message::new(format!("Transferring from {} to {}", source_agent, target_agent));
+                source_lock.transfer_to(target_agent.to_string(), message).await?;
+                self.current_agent = Some(target_agent.to_string());
+                Ok(())
+            } else {
+                Err(format!("Target agent {} not found", target_agent).into())
+            }
+        } else {
+            Err(format!("Source agent {} not found", source_agent).into())
         }
-
-        self.current_agent = Some(to.to_string());
-        Ok(())
     }
 }

 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::types::AgentConfig;
-    use crate::agents::greeter::GreeterAgent;
+    use crate::types::{Message, State, StateMachine, AgentStateManager};

     #[tokio::test]
-    async fn test_agent_transfer() {
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test_greeter".to_string(),
-            public_description: "Test greeter agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec!["test_target".to_string()],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test_greeter".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let mut service = TransferService::new(registry);
-
-        // Set current agent
-        service.set_current_agent("test_greeter".to_string());
-
-        // Process message that should trigger transfer
-        let response = service.process_message(Message::new("transfer to test_target".to_string())).await;
-        assert!(response.is_err()); // Should fail because test_target doesn't exist
-
-        // Test manual transfer
-        let result = service.transfer("test_greeter", "nonexistent").await;
-        assert!(result.is_err());
+    async fn test_transfer_service() {
+        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+        let mut service = TransferService::new(registry.clone());
+
+        service.set_current_agent("greeter".to_string());
+        assert_eq!(service.get_current_agent(), Some("greeter"));
+
+        service.transfer("greeter", "haiku").await.unwrap();
+        assert_eq!(service.get_current_agent(), Some("haiku"));
     }
 }
diff --git a/src/agents/user_agent.rs b/src/agents/user_agent.rs
index 937a1a3..74bd3c6 100644
--- a/src/agents/user_agent.rs
+++ b/src/agents/user_agent.rs
@@ -6,6 +6,7 @@ use crate::types::{Agent, AgentConfig, Result, Message, Tool, State};
 use crate::error::Error;
 use std::collections::HashMap;
 use async_trait::async_trait;
+use super::*;

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct TodoItem {
@@ -26,12 +27,13 @@ pub enum TodoStatus {
     Failed,
 }

-#[derive(Debug, Serialize, Deserialize)]
+#[derive(Debug, Serialize, Deserialize, Clone)]
 pub struct UserAgentState {
     todos: Vec<TodoItem>,
     last_processed: Option<DateTime<Utc>>,
 }

+#[derive(Clone)]
 pub struct UserAgent {
     config: AgentConfig,
     state: UserAgentState,
@@ -166,7 +168,7 @@ impl UserAgent {

 #[async_trait]
 impl Agent for UserAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         Ok(Message::new(format!("User received: {}", message.content)))
     }

diff --git a/src/agents/wrapper.rs b/src/agents/wrapper.rs
index 65adb61..771107c 100644
--- a/src/agents/wrapper.rs
+++ b/src/agents/wrapper.rs
@@ -2,99 +2,67 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use async_trait::async_trait;
 use std::collections::HashMap;
-use std::time::Duration;
-use crate::types::{Agent, Message, Tool, State, AgentConfig, Result};
-use crate::types::{TodoProcessor, TodoList, TodoTask};
+use crate::types::{Agent, Message, Result, AgentConfig, Tool, State, TodoList, TodoTask};
+use crate::types::todo::{TodoListExt, TodoProcessor};
+use crate::agents::browser_agent::DummyAgent;

 /// A wrapper type that handles the complexity of agent type management.
 /// This provides a consistent interface for working with agents while
 /// handling the necessary thread-safety and dynamic dispatch requirements.
-#[derive(Clone)]
 pub struct AgentWrapper {
-    inner: Arc<Box<dyn Agent + Send + Sync>>,
-    todo_list: TodoList,
+    pub agent: RwLock<Box<dyn Agent + Send + Sync>>,
+    pub todo_list: Arc<RwLock<TodoList>>,
 }

 impl AgentWrapper {
     /// Create a new AgentWrapper from any type that implements Agent
     pub fn new(agent: Box<dyn Agent + Send + Sync>) -> Self {
         Self {
-            inner: Arc::new(agent),
-            todo_list: TodoList::new(),
+            agent: RwLock::new(agent),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
         }
     }
 }

-#[async_trait]
-impl TodoProcessor for AgentWrapper {
-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
-        // Convert the task to a message and process it
-        self.process_message(Message::new(task.description)).await
-    }
-
-    fn get_check_interval(&self) -> Duration {
-        // Default check interval of 5 seconds
-        Duration::from_secs(60)
-    }
-
-    fn get_todo_list(&self) -> &TodoList {
-        &self.todo_list
-    }
-}
-
 #[async_trait]
 impl Agent for AgentWrapper {
-    async fn process_message(&self, message: Message) -> Result<Message> {
-        self.inner.process_message(message).await
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        let mut agent = self.agent.write().await;
+        agent.process_message(message).await
     }

     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        self.inner.transfer_to(target_agent, message).await
+        let agent = self.agent.read().await;
+        agent.transfer_to(target_agent, message).await
     }

     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        self.inner.call_tool(tool, params).await
-    }
-
-    async fn get_config(&self) -> Result<AgentConfig> {
-        self.inner.get_config().await
+        let agent = self.agent.read().await;
+        agent.call_tool(tool, params).await
     }

     async fn get_current_state(&self) -> Result<Option<State>> {
-        self.inner.get_current_state().await
+        let agent = self.agent.read().await;
+        agent.get_current_state().await
     }

-    fn get_todo_list(&self) -> Option<&TodoList> {
-        Some(&self.todo_list)
+    async fn get_config(&self) -> Result<AgentConfig> {
+        let agent = self.agent.read().await;
+        agent.get_config().await
     }
 }

 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::agents::GreeterAgent;

     #[tokio::test]
     async fn test_agent_wrapper() {
-        let config = AgentConfig {
-            name: "test".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        };
-
-        let agent = GreeterAgent::new(config);
-        let wrapper = AgentWrapper::new(Box::new(agent));
-
-        // Test that we can process messages
-        let response = wrapper.process_message(Message::new("test".to_string())).await;
-        assert!(response.is_ok());
+        let agent = Box::new(DummyAgent::new());
+        let mut wrapper = AgentWrapper::new(agent);

-        // Test state access
-        let state = wrapper.get_current_state().await;
-        assert!(state.is_ok());
+        let message = Message::new("test".to_string());
+        let response = wrapper.process_message(message).await.unwrap();
+        assert!(response.content.contains("test"));
     }
 }
diff --git a/src/api/mod.rs b/src/api/mod.rs
index ef8710f..cdce159 100644
--- a/src/api/mod.rs
+++ b/src/api/mod.rs
@@ -16,17 +16,14 @@ use crate::{
 pub mod routes;
 pub mod websocket;

+#[derive(Clone)]
 pub struct AppState {
-    pub transfer_service: Arc<RwLock<TransferService>>,
     pub agents: Arc<RwLock<AgentRegistry>>,
 }

 impl AppState {
-    pub fn new(transfer_service: Arc<RwLock<TransferService>>) -> Self {
-        Self {
-            transfer_service,
-            agents: Arc::new(RwLock::new(AgentRegistry::new()))
-        }
+    pub fn new(agents: Arc<RwLock<AgentRegistry>>) -> Self {
+        Self { agents }
     }
 }

@@ -35,13 +32,12 @@ pub async fn create_app_state() -> Arc<AppState> {
     let registry = Arc::new(RwLock::new(registry));
     let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));

-    Arc::new(AppState::new(transfer_service))
+    Arc::new(AppState::new(registry))
 }

 pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferService>>) {
     let registry = AgentRegistry::create_default_agents(routes::default_agents()).await.unwrap();
     let app_state = Arc::new(AppState {
-        transfer_service,
         agents: Arc::new(RwLock::new(registry)),
     });

@@ -67,10 +63,17 @@ pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferServic
     .unwrap();
 }

-pub fn create_router(state: Arc<AppState>) -> Router {
+pub fn create_router(agents: Arc<RwLock<AgentRegistry>>) -> Router {
+    let state = Arc::new(AppState { agents });
+
     Router::new()
-        .route("/agents", get(routes::list_agents))
-        .route("/agents/:agent_name/message", post(routes::send_message))
+        .route("/", get(routes::index))
+        .route("/api/agents", get(routes::list_agents))
+        .route("/api/agents/:name", get(routes::get_agent))
+        .route("/api/agents/:name/message", post(routes::send_message))
+        .route("/api/agents/:name/tasks", get(routes::get_tasks))
+        .route("/api/agents/:name/tasks", post(routes::add_task))
+        .route("/api/agents/:name/tasks/:task_id", get(routes::get_task))
         .route("/ws", get(websocket::websocket_handler))
         .with_state(state)
 }
diff --git a/src/api/routes.rs b/src/api/routes.rs
index 7b5818f..f623fdf 100644
--- a/src/api/routes.rs
+++ b/src/api/routes.rs
@@ -7,13 +7,58 @@ use axum::{
 use serde::{Deserialize, Serialize};
 use std::sync::Arc;
 use tokio::sync::RwLock;
+use thiserror::Error;
+use std::error::Error as StdError;
+use crate::types::todo::TodoListExt;
+use chrono::{DateTime, Utc};
+use axum::handler::Handler;
+use axum::debug_handler;

 use crate::{
     api::AppState,
-    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor},
+    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor, MessageMetadata},
     agents::AgentRegistry,
 };

+#[derive(Debug, Error, Clone, PartialEq)]
+pub enum AppError {
+    #[error("Status: {0}")]
+    Status(StatusCode),
+    #[error("Agent error: {0}")]
+    AgentError(String),
+    #[error("Serialization error")]
+    SerializationError,
+}
+
+impl From<StatusCode> for AppError {
+    fn from(status: StatusCode) -> Self {
+        AppError::Status(status)
+    }
+}
+
+impl From<Box<dyn StdError + Send + Sync>> for AppError {
+    fn from(err: Box<dyn StdError + Send + Sync>) -> Self {
+        AppError::AgentError(err.to_string())
+    }
+}
+
+impl From<serde_json::Error> for AppError {
+    fn from(_: serde_json::Error) -> Self {
+        AppError::SerializationError
+    }
+}
+
+impl IntoResponse for AppError {
+    fn into_response(self) -> Response {
+        let status = match self {
+            AppError::Status(status) => status,
+            AppError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
+            AppError::SerializationError => StatusCode::INTERNAL_SERVER_ERROR,
+        };
+        (status, self.to_string()).into_response()
+    }
+}
+
 pub async fn index() -> Response {
     "Welcome to the Swarmonomicon API".into_response()
 }
@@ -24,157 +69,114 @@ pub struct AgentResponse {
     description: String,
 }

-#[derive(Debug, Deserialize)]
+#[derive(Deserialize)]
 pub struct MessageRequest {
-    content: String,
+    pub content: String,
+}
+
+#[derive(Debug, Serialize)]
+pub struct MessageResponse {
+    pub content: String,
+    pub metadata: Option<serde_json::Value>,
 }

 pub async fn list_agents(
     State(state): State<Arc<AppState>>,
-) -> Result<Json<Vec<AgentInfo>>, StatusCode> {
+) -> Result<Json<Vec<String>>, AppError> {
     let registry = state.agents.read().await;
-    let mut agents = Vec::new();
-
-    for (name, agent) in registry.agents.iter() {
-        match agent.get_config().await {
-            Ok(config) => agents.push(AgentInfo {
-                name: name.clone(),
-                description: config.public_description,
-                tools: config.tools,
-                downstream_agents: config.downstream_agents,
-            }),
-            Err(_) => return Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    }
-
+    let agents = registry.list_agents();
     Ok(Json(agents))
 }

 pub async fn get_agent(
-    State(state): State<Arc<AppState>>,
     Path(name): Path<String>,
-) -> Result<Json<AgentInfo>, StatusCode> {
+    State(state): State<Arc<AppState>>,
+) -> Result<Json<MessageResponse>, AppError> {
     let registry = state.agents.read().await;
-
-    if let Some(agent) = registry.get(&name) {
-        match agent.get_config().await {
-            Ok(config) => Ok(Json(AgentInfo {
-                name: config.name,
-                description: config.public_description,
-                tools: config.tools,
-                downstream_agents: config.downstream_agents,
-            })),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
-    }
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let config = agent.read().await.get_config().await?;
+    Ok(Json(MessageResponse {
+        content: format!("Agent {} is ready", config.name),
+        metadata: None,
+    }))
 }

+#[debug_handler]
 pub async fn process_message(
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
-    Json(request): Json<MessageRequest>,
-) -> Result<Json<Message>, StatusCode> {
+    Path(name): Path<String>,
+    Json(message): Json<MessageRequest>,
+) -> Result<Json<Message>, AppError> {
     let registry = state.agents.read().await;
-
-    if let Some(agent) = registry.get(&agent_name) {
-        match agent.process_message(Message::new(request.content)).await {
-            Ok(response) => Ok(Json(response)),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
-    }
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let mut agent = agent.write().await;
+    let response = agent.process_message(Message::text(message.content))
+        .await
+        .map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
+    Ok(Json(response))
 }

 pub async fn send_message(
+    Path(name): Path<String>,
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
     Json(request): Json<MessageRequest>,
-) -> Result<Json<Message>, StatusCode> {
+) -> Result<Json<MessageResponse>, AppError> {
     let registry = state.agents.read().await;
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let mut agent_lock = agent.write().await;
+    let response = agent_lock.process_message(Message::new(request.content)).await?;
+    Ok(Json(MessageResponse {
+        content: response.content,
+        metadata: Some(serde_json::to_value(response.metadata)?),
+    }))
+}

-    if let Some(agent) = registry.get(&agent_name) {
-        match agent.process_message(Message::new(request.content)).await {
-            Ok(response) => Ok(Json(response)),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
+pub async fn handle_message(
+    Path(agent_name): Path<String>,
+    State(registry): State<Arc<RwLock<AgentRegistry>>>,
+    Json(request): Json<MessageRequest>,
+) -> Result<Json<MessageResponse>, AppError> {
+    let registry = registry.read().await;
+    let agent = registry.get_agent(&agent_name).ok_or(StatusCode::NOT_FOUND)?;
+    let mut agent_lock = agent.write().await;
+    let response = agent_lock.process_message(Message::new(request.content)).await?;
+    Ok(Json(MessageResponse {
+        content: response.content,
+        metadata: response.metadata.map(|m| serde_json::to_value(m).unwrap_or_default()),
+    }))
+}
+
+pub async fn handle_todo_list(
+    Path(agent_name): Path<String>,
+    State(registry): State<Arc<RwLock<AgentRegistry>>>,
+    Json(task): Json<TodoTask>,
+) -> Result<Json<MessageResponse>, AppError> {
+    let registry = registry.read().await;
+    let agent = registry.get_agent(&agent_name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent).await;
+    {
+        let mut list = todo_list.write().await;
+        list.add_task(task);
     }
+    Ok(Json(MessageResponse {
+        content: "Task added successfully".to_string(),
+        metadata: None,
+    }))
 }

 pub fn default_agents() -> Vec<AgentConfig> {
-    // vec![ restore default later ?
-    //     AgentConfig {
-    //         name: "greeter".to_string(),
-    //         public_description: "Agent that greets the user.".to_string(),
-    //         instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
-    //         tools: Vec::new(),
-    //         downstream_agents: vec!["haiku".to_string()],
-    //         personality: None,
-    //         state_machine: None,
-    //     }
-    // ]
-    let mut agents = Vec::new();
-
-    #[cfg(feature = "greeter-agent")]
-    agents.push(AgentConfig {
-        name: "greeter".to_string(),
-        public_description: "Agent that greets the user.".to_string(),
-        instructions: "Please greet the user and ask them if they'd like a Haiku. If yes, transfer them to the 'haiku' agent.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: vec!["haiku".to_string()],
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "haiku-agent")]
-    agents.push(AgentConfig {
-        name: "haiku".to_string(),
-        public_description: "Agent that creates haikus.".to_string(),
-        instructions: "Create haikus based on user input.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "git-agent")]
-    agents.push(AgentConfig {
-        name: "git".to_string(),
-        public_description: "Agent that helps with git operations.".to_string(),
-        instructions: "Help users with git operations like commit, branch, merge etc.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "project-init-agent")]
-    agents.push(AgentConfig {
-        name: "project-init".to_string(),
-        public_description: "Agent that helps initialize new projects.".to_string(),
-        instructions: "Help users create new projects with proper structure and configuration.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "browser-agent")]
-    agents.push(AgentConfig {
-        name: "browser".to_string(),
-        public_description: "Agent that controls browser automation.".to_string(),
-        instructions: "Help users with browser automation tasks.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    agents
+    vec![
+        AgentConfig {
+            name: "greeter".to_string(),
+            public_description: "Agent that greets the user.".to_string(),
+            instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
+            tools: Vec::new(),
+            downstream_agents: vec!["haiku".to_string()],
+            personality: None,
+            state_machine: None,
+        }
+    ]
 }

 #[derive(Debug, Deserialize, Clone)]
@@ -184,253 +186,163 @@ pub struct AddTaskRequest {
     pub source_agent: Option<String>,
 }

-#[derive(Debug, Serialize)]
-pub struct TaskResponse {
-    pub id: String,
-    pub description: String,
-    pub priority: TaskPriority,
-    pub source_agent: Option<String>,
-    pub target_agent: String,
-    pub status: TaskStatus,
-    pub created_at: i64,
-    pub completed_at: Option<i64>,
-}
-
-impl From<TodoTask> for TaskResponse {
-    fn from(task: TodoTask) -> Self {
-        Self {
-            id: task.id,
-            description: task.description,
-            priority: task.priority,
-            source_agent: task.source_agent,
-            target_agent: task.target_agent,
-            status: task.status,
-            created_at: task.created_at,
-            completed_at: task.completed_at,
+impl From<AddTaskRequest> for TodoTask {
+    fn from(req: AddTaskRequest) -> Self {
+        TodoTask {
+            id: uuid::Uuid::new_v4().to_string(),
+            description: req.description,
+            priority: req.priority,
+            source_agent: req.source_agent,
+            target_agent: "".to_string(), // Will be set by the handler
+            status: TaskStatus::Pending,
+            created_at: Utc::now(),
+            completed_at: None,
         }
     }
 }

-// Add a task to an agent's todo list
+#[debug_handler]
 pub async fn add_task(
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
-    Json(request): Json<AddTaskRequest>,
-) -> Result<Json<TaskResponse>, StatusCode> {
+    Path(name): Path<String>,
+    Json(task): Json<TodoTask>,
+) -> Result<Json<TodoTask>, AppError> {
     let registry = state.agents.read().await;
-
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-
-    let task = TodoTask {
-        id: uuid::Uuid::new_v4().to_string(),
-        description: request.description,
-        priority: request.priority,
-        source_agent: request.source_agent,
-        target_agent: agent_name,
-        status: TaskStatus::Pending,
-        created_at: chrono::Utc::now().timestamp(),
-        completed_at: None,
-    };
-
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-
-    todo_list.add_task(task.clone()).await;
-
-    Ok(Json(TaskResponse::from(task)))
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent).await;
+    todo_list.add_task(task.clone()).await.map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
+    Ok(Json(task))
 }

-// Get all tasks for an agent
+#[debug_handler]
 pub async fn get_tasks(
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
-) -> Result<Json<Vec<TaskResponse>>, StatusCode> {
+    Path(name): Path<String>,
+) -> Result<Json<Vec<TodoTask>>, AppError> {
     let registry = state.agents.read().await;
-
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-
-    let tasks = todo_list.get_all_tasks().await;
-
-    Ok(Json(tasks.into_iter().map(TaskResponse::from).collect()))
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent).await;
+    let tasks = {
+        let list = todo_list.read().await;
+        list.get_tasks()
+    };
+    Ok(Json(tasks))
 }

-// Get a specific task by ID
+#[debug_handler]
 pub async fn get_task(
     State(state): State<Arc<AppState>>,
-    Path((agent_name, task_id)): Path<(String, String)>,
-) -> Result<Json<TaskResponse>, StatusCode> {
+    Path((name, task_id)): Path<(String, String)>,
+) -> Result<Json<TodoTask>, AppError> {
     let registry = state.agents.read().await;
-
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-
-    let task = todo_list.get_task(&task_id).await
-        .ok_or(StatusCode::NOT_FOUND)?;
-
-    Ok(Json(TaskResponse::from(task)))
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent).await;
+    let task = {
+        let list = todo_list.read().await;
+        list.get_task(&task_id).cloned().ok_or(AppError::Status(StatusCode::NOT_FOUND))?
+    };
+    Ok(Json(task))
 }

 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::agents::{AgentRegistry, GreeterAgent, TransferService};
-    use crate::types::AgentConfig;
+    use crate::agents::greeter::GreeterAgent;
+    use axum::http::StatusCode;
+    use chrono::Utc;

-    #[tokio::test]
-    async fn test_list_agents() {
+    async fn setup_test_state() -> Arc<AppState> {
         let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test".to_string(),
+        let config = AgentConfig {
+            name: "test_agent".to_string(),
             public_description: "Test agent".to_string(),
             instructions: "Test instructions".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: None,
             state_machine: None,
-        });
-
-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let state = Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
-            agents: registry,
-        });
+        };
+        registry.register("test_agent".to_string(), Box::new(GreeterAgent::new(config)));
+        Arc::new(AppState {
+            agents: Arc::new(RwLock::new(registry)),
+        })
+    }

+    #[tokio::test]
+    async fn test_list_agents() {
+        let state = setup_test_state().await;
         let response = list_agents(State(state)).await.unwrap();
-        assert_eq!(response.0.len(), 1);
-        assert_eq!(response.0[0].name, "test");
+        assert!(!response.0.is_empty());
     }

     #[tokio::test]
     async fn test_get_agent() {
-        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
-        let state = Arc::new(AppState {
-            transfer_service,
-            agents: registry,
-        });
-        let response = get_agent(State(state.clone()), Path("unknown".to_string())).await;
-        assert!(response.is_err());
-        assert_eq!(response.unwrap_err(), StatusCode::NOT_FOUND);
+        let state = setup_test_state().await;
+        let response = get_agent(Path("test_agent".to_string()), State(state)).await.unwrap();
+        assert!(response.0.content.contains("ready"));
     }

     #[tokio::test]
     async fn test_send_message() {
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let state = Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
-            agents: registry,
-        });
-
+        let state = setup_test_state().await;
         let request = MessageRequest {
             content: "Hello".to_string(),
         };
-
         let response = send_message(
+            Path("test_agent".to_string()),
             State(state),
-            Path("test".to_string()),
             Json(request),
-        ).await;
-        assert!(response.is_ok());
+        )
+        .await
+        .unwrap();
+        assert!(!response.0.content.is_empty());
     }

     #[tokio::test]
     async fn test_todo_list_endpoints() {
-        // Create test state
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test_agent".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test_agent".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
-        let state = Arc::new(AppState {
-            transfer_service,
-            agents: registry,
-        });
-
-        // Test adding a task
-        let add_request = AddTaskRequest {
+        let state = setup_test_state().await;
+
+        // Test add task
+        let task = TodoTask {
+            id: uuid::Uuid::new_v4().to_string(),
             description: "Test task".to_string(),
             priority: TaskPriority::Medium,
             source_agent: None,
+            target_agent: "test_agent".to_string(),
+            status: TaskStatus::Pending,
+            created_at: Utc::now(),
+            completed_at: None,
         };
-
+
         let response = add_task(
             State(state.clone()),
             Path("test_agent".to_string()),
-            Json(add_request.clone()),
-        ).await.unwrap();
-
-        let task = response.0;
-        assert_eq!(task.description, "Test task");
-        assert_eq!(task.status, TaskStatus::Pending);
-
-        // Test getting all tasks
-        let tasks = get_tasks(
+            Json(task.clone()),
+        )
+        .await
+        .unwrap();
+        assert!(response.0.id.len() > 0);
+
+        // Test get tasks
+        let response = get_tasks(
             State(state.clone()),
             Path("test_agent".to_string()),
-        ).await.unwrap();
-
-        assert_eq!(tasks.0.len(), 1);
-        assert_eq!(tasks.0[0].description, "Test task");
-
-        // Test getting a specific task
-        let task = get_task(
-            State(state.clone()),
-            Path(("test_agent".to_string(), task.id.clone())),
-        ).await.unwrap();
-
-        assert_eq!(task.0.description, "Test task");
-        assert_eq!(task.0.id, task.0.id);
-
-        // Test getting a non-existent task
-        let result = get_task(
-            State(state.clone()),
-            Path(("test_agent".to_string(), "non-existent".to_string())),
-        ).await;
-
-        assert!(result.is_err());
-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
-
-        // Test adding a task to a non-existent agent
-        let result = add_task(
-            State(state.clone()),
-            Path("non-existent".to_string()),
-            Json(add_request),
-        ).await;
+        )
+        .await
+        .unwrap();
+        assert_eq!(response.0.len(), 1);

-        assert!(result.is_err());
-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
+        // Test get task
+        let task_id = response.0[0].id.clone();
+        let response = get_task(
+            State(state),
+            Path(("test_agent".to_string(), task_id)),
+        )
+        .await
+        .unwrap();
+        assert!(response.0.description.contains("Test task"));
     }
 }
diff --git a/src/api/websocket.rs b/src/api/websocket.rs
index 0fa75aa..5eba897 100644
--- a/src/api/websocket.rs
+++ b/src/api/websocket.rs
@@ -10,13 +10,16 @@ use tokio::sync::broadcast;
 use crate::{
     api::AppState,
     agents::{AgentRegistry, TransferService, GreeterAgent},
-    types::{AgentConfig, Tool, Message},
+    types::{AgentConfig, Tool, Message as AppMessage, Agent},
 };

 #[cfg(feature = "haiku-agent")]
 use crate::agents::HaikuAgent;

 use tokio::sync::RwLock;
+use crate::api::routes::AppError;
+use axum::http::StatusCode;
+use std::default::Default;

 const CHANNEL_SIZE: usize = 32;

@@ -52,6 +55,35 @@ pub enum ServerMessage {
     SessionUpdated,
 }

+#[derive(Debug)]
+pub enum WebSocketError {
+    ConnectionError(String),
+    AgentError(String),
+}
+
+impl From<WebSocketError> for StatusCode {
+    fn from(error: WebSocketError) -> Self {
+        match error {
+            WebSocketError::ConnectionError(_) => StatusCode::BAD_REQUEST,
+            WebSocketError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
+        }
+    }
+}
+
+impl Default for AgentConfig {
+    fn default() -> Self {
+        Self {
+            name: "greeter".to_string(),
+            public_description: "A friendly greeter agent".to_string(),
+            instructions: "Greet users in a friendly manner".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: Some("Friendly and helpful".to_string()),
+            state_machine: None,
+        }
+    }
+}
+
 pub async fn websocket_handler(
     ws: WebSocketUpgrade,
     State(state): State<Arc<AppState>>,
@@ -59,28 +91,36 @@ pub async fn websocket_handler(
     ws.on_upgrade(|socket| handle_socket(socket, state))
 }

-async fn handle_socket(mut socket: WebSocket, state: Arc<AppState>) {
+pub async fn handle_socket(mut socket: WebSocket, state: Arc<AppState>) {
     let (mut sender, mut receiver) = socket.split();

-    while let Some(Ok(msg)) = receiver.next().await {
-        if let WsMessage::Text(content) = msg {
-            let response = match serde_json::from_str::<ClientMessage>(&content) {
-                Ok(client_msg) => {
-                    match handle_client_message(client_msg, state.clone()).await {
-                        Ok(server_msg) => {
-                            match serde_json::to_string(&server_msg) {
-                                Ok(json) => WsMessage::Text(json),
-                                Err(_) => WsMessage::Text("Error serializing response".to_string()),
-                            }
-                        },
-                        Err(e) => WsMessage::Text(format!("Error: {}", e)),
-                    }
-                },
-                Err(_) => WsMessage::Text("Invalid message format".to_string()),
-            };
+    let mut registry = state.agents.write().await;
+    let config = AgentConfig {
+        name: "greeter".to_string(),
+        public_description: "A friendly greeter agent".to_string(),
+        instructions: "Greet users in a friendly manner".to_string(),
+        tools: vec![],
+        downstream_agents: vec![],
+        personality: Some("Friendly and helpful".to_string()),
+        state_machine: None,
+    };
+    let greeter_agent = GreeterAgent::new(config);
+    registry.register("greeter".to_string(), Box::new(greeter_agent));
+    drop(registry);

-            if sender.send(response).await.is_err() {
-                break;
+    while let Some(msg) = receiver.next().await {
+        if let Ok(msg) = msg {
+            match msg {
+                WsMessage::Text(text) => {
+                    let registry = state.agents.read().await;
+                    if let Some(agent) = registry.get_agent("greeter") {
+                        let mut agent = agent.write().await;
+                        if let Ok(response) = agent.process_message(AppMessage::text(text)).await {
+                            let _ = sender.send(WsMessage::Text(response.content)).await;
+                        }
+                    }
+                }
+                _ => {}
             }
         }
     }
@@ -89,29 +129,73 @@ async fn handle_socket(mut socket: WebSocket, state: Arc<AppState>) {
 async fn handle_client_message(msg: ClientMessage, state: Arc<AppState>) -> Result<ServerMessage, String> {
     match msg {
         ClientMessage::Connect { agent } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            transfer_service.set_current_agent(agent.clone());
+            let mut registry = state.agents.write().await;
+            let config = AgentConfig::default();
+            let mut greeter_agent = GreeterAgent::new(config);
+            let response = greeter_agent.process_message(AppMessage::text("Hello!".to_string())).await
+                .map_err(|e| e.to_string())?;
+            registry.register("greeter".to_string(), Box::new(greeter_agent));
+            drop(registry);
             Ok(ServerMessage::Connected { agent })
         },
         ClientMessage::Message { content } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            match transfer_service.process_message(Message::new(content)).await {
-                Ok(response) => Ok(ServerMessage::Message { content: response.content }),
-                Err(e) => Err(e.to_string()),
+            let registry = state.agents.read().await;
+            if let Some(agent) = registry.get_agent("greeter") {
+                let mut agent = agent.write().await;
+                let response = agent.process_message(AppMessage::new(content)).await
+                    .map_err(|e| e.to_string())?;
+                Ok(ServerMessage::Message { content: response.content })
+            } else {
+                Err("Agent not found".to_string())
             }
         },
         ClientMessage::Transfer { from, to } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            transfer_service.set_current_agent(to.clone());
             Ok(ServerMessage::Transferred { from, to })
         },
         ClientMessage::UpdateSession { instructions, tools, turn_detection } => {
-            // Handle session update
             Ok(ServerMessage::SessionUpdated)
         },
     }
 }

+pub async fn handle_websocket(
+    mut ws: WebSocket,
+    State(state): State<Arc<AppState>>,
+) -> Result<(), WebSocketError> {
+    let mut registry = state.agents.write().await;
+    let config = AgentConfig {
+        name: "greeter".to_string(),
+        public_description: "Greeter agent".to_string(),
+        instructions: "Greets users".to_string(),
+        tools: vec![],
+        downstream_agents: vec![],
+        personality: None,
+        state_machine: None,
+    };
+    let greeter_agent = GreeterAgent::new(config);
+    registry.register("greeter".to_string(), Box::new(greeter_agent));
+    drop(registry);
+
+    while let Some(msg) = ws.recv().await {
+        let msg = msg.map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
+
+        if let WsMessage::Text(text) = msg {
+            let registry = state.agents.read().await;
+            if let Some(agent) = registry.get_agent("greeter") {
+                let mut agent = agent.write().await;
+                let response = agent.process_message(AppMessage::new(text)).await
+                    .map_err(|e| WebSocketError::AgentError(e.to_string()))?;
+
+                ws.send(WsMessage::from(response))
+                    .await
+                    .map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
+            }
+        }
+    }
+
+    Ok(())
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -132,11 +216,10 @@ mod tests {
         };

         let greeter_agent = GreeterAgent::new(greeter_config);
-        registry.register("greeter".to_string(), Box::new(greeter_agent)).await.expect("Failed to register greeter agent");
+        registry.register("greeter".to_string(), Box::new(greeter_agent));

         let registry = Arc::new(RwLock::new(registry));
         Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
             agents: registry,
         })
     }
diff --git a/src/bin/swarm.rs b/src/bin/swarm.rs
index 249b0dc..9ac7917 100644
--- a/src/bin/swarm.rs
+++ b/src/bin/swarm.rs
@@ -13,8 +13,8 @@ use swarmonomicon::agents::git_assistant::GitAssistantAgent;
 #[cfg(feature = "haiku-agent")]
 use swarmonomicon::agents::haiku::HaikuAgent;

-#[cfg(feature = "project-agent")]
-use swarmonomicon::agents::project::ProjectAgent;
+#[cfg(feature = "project-init-agent")]
+use swarmonomicon::agents::ProjectInitAgent;

 #[derive(Parser)]
 #[command(author, version, about, long_about = None)]
@@ -81,7 +81,7 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {

             let mut git = git_assistant;
             git.update_working_dir(std::env::current_dir()?.into())?;
-            registry.register("git".to_string(), Box::new(git)).await?;
+            registry.register("git".to_string(), Box::new(git));
         }

         #[cfg(feature = "haiku-agent")]
@@ -96,11 +96,11 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
         });

         #[cfg(feature = "haiku-agent")]
-        registry.register("haiku".to_string(), Box::new(haiku_agent)).await?;
+        registry.register("haiku".to_string(), Box::new(haiku_agent));

-        #[cfg(feature = "project-agent")]
-        let project_agent = ProjectAgent::new(AgentConfig {
-            name: "project".to_string(),
+        #[cfg(feature = "project-init-agent")]
+        let project_agent = ProjectInitAgent::new(AgentConfig {
+            name: "project-init".to_string(),
             public_description: "Project initialization tool".to_string(),
             instructions: "Creates new projects with proper structure and configuration".to_string(),
             tools: vec![],
@@ -109,8 +109,8 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
             state_machine: None,
         }).await?;

-        #[cfg(feature = "project-agent")]
-        registry.register("project".to_string(), Box::new(project_agent)).await?;
+        #[cfg(feature = "project-init-agent")]
+        registry.register("project-init".to_string(), Box::new(project_agent));

         let greeter_agent = GreeterAgent::new(AgentConfig {
             name: "greeter".to_string(),
@@ -122,7 +122,7 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
             state_machine: None,
         });

-        registry.register("greeter".to_string(), Box::new(greeter_agent)).await?;
+        registry.register("greeter".to_string(), Box::new(greeter_agent));
     }

     // Create transfer service starting with greeter
@@ -147,10 +147,20 @@ async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {

             let response = service.process_message(command).await?;
             println!("{}", response.content);
+
+            // Fix get_mut usage by using the registry guard correctly
+            let mut registry_guard = registry.write().await;
+            if let Some(git_agent) = registry_guard.get_agent("git") {
+                let mut git_agent = git_agent.write().await;
+                let haiku = response.content.replace("Generated haiku:\n", "");
+                // if let Err(e) = git_agent.commit_for_agent("haiku", &haiku).await {
+                //     eprintln!("Failed to commit haiku: {}", e);
+                // }
+            }
         }
         Some(Commands::Init { project_type, name, description }) => {
             // Transfer to project agent
-            service.transfer("greeter", "project").await?;
+            service.transfer("greeter", "project-init").await?;

             // Process command
             let command = Message::new(format!("create {} {} {}", project_type, name, description));
@@ -235,7 +245,7 @@ mod tests {
             {
                 let mut git = git_assistant;
                 git.update_working_dir(temp_dir.path().to_path_buf())?;
-                registry.register("git".to_string(), Box::new(git)).await?;
+                registry.register("git".to_string(), Box::new(git));
             }

             let haiku_agent = HaikuAgent::new(AgentConfig {
@@ -248,8 +258,8 @@ mod tests {
                 state_machine: None,
             });

-            #[cfg(feature = "project-agent")]
-            let project_agent = ProjectAgent::new(AgentConfig {
+            #[cfg(feature = "project-init-agent")]
+            let project_agent = ProjectInitAgent::new(AgentConfig {
                 name: "project".to_string(),
                 public_description: "Test project agent".to_string(),
                 instructions: "Test project initialization".to_string(),
@@ -259,9 +269,9 @@ mod tests {
                 state_machine: None,
             }).await?;

-            registry.register("haiku".to_string(), Box::new(haiku_agent)).await?;
-            #[cfg(feature = "project-agent")]
-            registry.register("project".to_string(), Box::new(project_agent)).await?;
+            registry.register("haiku".to_string(), Box::new(haiku_agent));
+            #[cfg(feature = "project-init-agent")]
+            registry.register("project".to_string(), Box::new(project_agent));
         }

         // Create transfer service
diff --git a/src/bin/todo_worker.rs b/src/bin/todo_worker.rs
index 923abc8..726839a 100644
--- a/src/bin/todo_worker.rs
+++ b/src/bin/todo_worker.rs
@@ -34,8 +34,8 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {

     client.subscribe("todos/#", QoS::AtMostOnce).await?;

-    let user_agent = Arc::new(user_agent);
-    let user_agent_clone = user_agent.clone();
+    let mut user_agent = Arc::new(user_agent);
+    let mut user_agent_clone = user_agent.clone();

     task::spawn(async move {
         loop {
@@ -47,7 +47,8 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {

                         // Create a message for the user agent
                         let message = Message::new(format!("add todo: {} - {}", todo_name, description));
-                        if let Err(e) = user_agent_clone.process_message(message).await {
+                        let mut user_agent = Arc::make_mut(&mut user_agent_clone);
+                        if let Err(e) = user_agent.process_message(message).await {
                             tracing::error!("Failed to process todo: {}", e);
                         }
                     }
diff --git a/src/lib.rs b/src/lib.rs
index dc39068..4f088bb 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -19,8 +19,41 @@ pub fn add(left: usize, right: usize) -> usize {

 #[cfg(test)]
 mod tests {
-    #[test]
-    fn it_works() {
-        assert!(true);
+    use super::*;
+    use tokio::sync::RwLock;
+    use std::sync::Arc;
+    use crate::agents::{AgentRegistry, GitAgent, HaikuAgent};
+    use crate::types::AgentConfig;
+
+    #[tokio::test]
+    async fn test_agent_registration() {
+        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+
+        // Test git agent registration
+        let git_config = AgentConfig {
+            name: "git".to_string(),
+            public_description: "Git operations".to_string(),
+            instructions: "Handles git operations".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: None,
+            state_machine: None,
+        };
+        let git_agent = GitAgent::new(git_config).await.unwrap();
+        registry.write().await.register("git".to_string(), Box::new(git_agent));
+        assert!(registry.read().await.get_agent("git").is_some());
+
+        // Test haiku agent registration
+        let haiku_config = AgentConfig {
+            name: "haiku".to_string(),
+            public_description: "Haiku creation".to_string(),
+            instructions: "Creates haikus".to_string(),
+            tools: vec![],
+            downstream_agents: vec![],
+            personality: None,
+            state_machine: None,
+        };
+        registry.write().await.register("haiku".to_string(), Box::new(HaikuAgent::new(haiku_config)));
+        assert!(registry.read().await.get_agent("haiku").is_some());
     }
 }
diff --git a/src/types/mod.rs b/src/types/mod.rs
index 49bcc98..4ec3551 100644
--- a/src/types/mod.rs
+++ b/src/types/mod.rs
@@ -5,7 +5,11 @@ use chrono;
 use std::str::FromStr;
 use thiserror::Error;
 use std::fmt;
-use crate::agents::{AgentRegistry, AgentWrapper};
+use crate::agents::AgentRegistry;
+pub use crate::agents::wrapper::AgentWrapper;
+use std::sync::{Arc, RwLock};
+use std::time::Duration;
+use axum::extract::ws::Message as WsMessage;

 pub mod todo;
 pub use todo::{TodoList, TodoProcessor, TodoTask, TaskPriority, TaskStatus};
@@ -54,12 +58,17 @@ pub struct TranscriptItem {
     pub is_hidden: bool,
 }

+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub enum MessageType {
+    Text,
+    Command,
+}
+
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct Message {
     pub content: String,
     pub metadata: Option<MessageMetadata>,
-    pub role: Option<String>,
-    pub timestamp: Option<i64>,
+    pub message_type: MessageType,
 }

 impl Message {
@@ -67,8 +76,7 @@ impl Message {
         Self {
             content,
             metadata: None,
-            role: Some("assistant".to_string()),
-            timestamp: Some(chrono::Utc::now().timestamp()),
+            message_type: MessageType::Text,
         }
     }

@@ -77,14 +85,23 @@ impl Message {
         self
     }

-    pub fn with_role(mut self, role: Option<String>) -> Self {
-        self.role = role;
-        self
+    pub fn text(content: String) -> Self {
+        Self::new(content)
+    }
+}
+
+impl From<Message> for WsMessage {
+    fn from(msg: Message) -> Self {
+        WsMessage::Text(msg.content)
     }
+}

-    pub fn with_timestamp(mut self, timestamp: Option<i64>) -> Self {
-        self.timestamp = timestamp;
-        self
+impl From<WsMessage> for Message {
+    fn from(msg: WsMessage) -> Self {
+        match msg {
+            WsMessage::Text(content) => Message::new(content),
+            _ => Message::new("Unsupported message type".to_string()),
+        }
     }
 }

@@ -179,9 +196,9 @@ pub struct ValidationRule {

 pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

-#[async_trait::async_trait]
+#[async_trait]
 pub trait Agent: Send + Sync {
-    async fn process_message(&self, message: Message) -> Result<Message>;
+    async fn process_message(&mut self, message: Message) -> Result<Message>;
     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message>;
     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String>;
     async fn get_current_state(&self) -> Result<Option<State>>;
@@ -194,9 +211,13 @@ pub trait Agent: Send + Sync {

     /// Add a task to another agent's todo list if it supports task processing
     async fn delegate_task(&self, task: TodoTask, registry: &AgentRegistry) -> Result<()> {
-        if let Some(target_agent) = registry.get(&task.target_agent) {
-            let todo_list = <AgentWrapper as TodoProcessor>::get_todo_list(target_agent);
-            todo_list.add_task(task).await;
+        if let Some(target_agent) = registry.get_agent(&task.target_agent) {
+            let agent = target_agent.read().await;
+            let todo_list = TodoProcessor::get_todo_list(&*agent).await;
+            {
+                let mut list = todo_list.write().await;
+                list.add_task(task);
+            }
             Ok(())
         } else {
             Err(format!("Target agent '{}' not found", task.target_agent).into())
diff --git a/src/types/todo.rs b/src/types/todo.rs
index 40df62d..40d0c69 100644
--- a/src/types/todo.rs
+++ b/src/types/todo.rs
@@ -1,8 +1,14 @@
-use std::collections::VecDeque;
+use std::collections::HashMap;
 use serde::{Deserialize, Serialize};
 use tokio::sync::RwLock;
 use std::sync::Arc;
 use super::Message;
+use std::time::Duration;
+use async_trait::async_trait;
+use chrono::{DateTime, Utc};
+use super::Result;
+use crate::agents::wrapper::AgentWrapper;
+use crate::types::Agent;

 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct TodoTask {
@@ -12,8 +18,8 @@ pub struct TodoTask {
     pub source_agent: Option<String>,
     pub target_agent: String,
     pub status: TaskStatus,
-    pub created_at: i64,
-    pub completed_at: Option<i64>,
+    pub created_at: DateTime<Utc>,
+    pub completed_at: Option<DateTime<Utc>>,
 }

 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
@@ -32,94 +38,159 @@ pub enum TaskStatus {
     Failed,
 }

-#[derive(Debug, Clone, Default)]
+#[derive(Debug, Clone)]
 pub struct TodoList {
-    tasks: Arc<RwLock<VecDeque<TodoTask>>>,
+    tasks: HashMap<String, TodoTask>,
 }

 impl TodoList {
     pub fn new() -> Self {
         Self {
-            tasks: Arc::new(RwLock::new(VecDeque::new())),
+            tasks: HashMap::new(),
         }
     }

-    pub async fn add_task(&self, task: TodoTask) {
-        let mut tasks = self.tasks.write().await;
-        tasks.push_back(task);
+    pub fn add_task(&mut self, task: TodoTask) {
+        self.tasks.insert(task.id.clone(), task);
     }

-    pub async fn get_next_task(&self) -> Option<TodoTask> {
-        let mut tasks = self.tasks.write().await;
-        tasks.pop_front()
+    pub fn get_tasks(&self) -> Vec<TodoTask> {
+        self.tasks.values().cloned().collect()
     }

-    pub async fn peek_next_task(&self) -> Option<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.front().cloned()
+    pub fn get_task(&self, id: &str) -> Option<&TodoTask> {
+        self.tasks.get(id)
     }

-    pub async fn mark_task_completed(&self, task_id: &str) {
-        let mut tasks = self.tasks.write().await;
-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
+    pub fn get_task_mut(&mut self, id: &str) -> Option<&mut TodoTask> {
+        self.tasks.get_mut(id)
+    }
+
+    pub fn get_next_task(&self) -> Option<TodoTask> {
+        self.tasks.values()
+            .find(|t| t.status == TaskStatus::Pending)
+            .cloned()
+    }
+
+    pub fn mark_task_completed(&mut self, id: &str) {
+        if let Some(task) = self.get_task_mut(id) {
             task.status = TaskStatus::Completed;
-            task.completed_at = Some(chrono::Utc::now().timestamp());
+            task.completed_at = Some(Utc::now());
         }
     }

-    pub async fn mark_task_failed(&self, task_id: &str) {
-        let mut tasks = self.tasks.write().await;
-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
+    pub fn mark_task_failed(&mut self, id: &str) {
+        if let Some(task) = self.get_task_mut(id) {
             task.status = TaskStatus::Failed;
         }
     }

-    pub async fn is_empty(&self) -> bool {
-        let tasks = self.tasks.read().await;
-        tasks.is_empty()
+    pub fn update_task(&mut self, id: &str, task: TodoTask) -> Result<()> {
+        if self.tasks.contains_key(id) {
+            self.tasks.insert(id.to_string(), task);
+            Ok(())
+        } else {
+            Err("Task not found".into())
+        }
     }

-    pub async fn len(&self) -> usize {
-        let tasks = self.tasks.read().await;
-        tasks.len()
+    pub fn delete_task(&mut self, id: &str) -> Result<()> {
+        if self.tasks.remove(id).is_some() {
+            Ok(())
+        } else {
+            Err("Task not found".into())
+        }
     }
+}
+
+#[async_trait]
+pub trait TodoProcessor: Send + Sync {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message>;
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>>;
+    async fn start_processing(&mut self);
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
+    }
+}
+
+#[async_trait]
+pub trait TodoListExt {
+    async fn add_task(&self, task: TodoTask) -> Result<()>;
+    async fn get_task(&self, id: &str) -> Option<TodoTask>;
+    async fn get_tasks(&self) -> Vec<TodoTask>;
+    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()>;
+    async fn delete_task(&self, id: &str) -> Result<()>;
+}

-    pub async fn get_all_tasks(&self) -> Vec<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.iter().cloned().collect()
+#[async_trait]
+impl TodoListExt for Arc<RwLock<TodoList>> {
+    async fn add_task(&self, task: TodoTask) -> Result<()> {
+        let mut list = self.write().await;
+        list.add_task(task);
+        Ok(())
     }

-    pub async fn get_task(&self, task_id: &str) -> Option<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.iter().find(|t| t.id == task_id).cloned()
+    async fn get_task(&self, id: &str) -> Option<TodoTask> {
+        let list = self.read().await;
+        list.get_task(id).cloned()
+    }
+
+    async fn get_tasks(&self) -> Vec<TodoTask> {
+        let list = self.read().await;
+        list.get_tasks()
+    }
+
+    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()> {
+        let mut list = self.write().await;
+        list.update_task(id, task)?;
+        Ok(())
+    }
+
+    async fn delete_task(&self, id: &str) -> Result<()> {
+        let mut list = self.write().await;
+        list.delete_task(id)?;
+        Ok(())
     }
 }

-#[async_trait::async_trait]
-pub trait TodoProcessor: Send + Sync {
-    /// Process a single task from the todo list
-    async fn process_task(&self, task: TodoTask) -> super::Result<Message>;
-
-    /// Get the interval at which this processor should check for new tasks
-    fn get_check_interval(&self) -> std::time::Duration;
-
-    /// Get the todo list for this processor
-    fn get_todo_list(&self) -> &TodoList;
-
-    /// Start the task processing loop
-    async fn start_processing(&self) -> super::Result<()> {
+#[async_trait]
+impl TodoProcessor for AgentWrapper {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        let task_desc = task.description.clone();
+        let result = self.process_message(Message::new(task_desc)).await;
+        if result.is_ok() {
+            let mut list = self.todo_list.write().await;
+            list.mark_task_completed(&task.id);
+        } else {
+            let mut list = self.todo_list.write().await;
+            list.mark_task_failed(&task.id);
+        }
+        result
+    }
+
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }
+
+    async fn start_processing(&mut self) {
         loop {
-            if let Some(task) = self.get_todo_list().get_next_task().await {
-                match self.process_task(task.clone()).await {
-                    Ok(_) => {
-                        self.get_todo_list().mark_task_completed(&task.id).await;
-                    }
-                    Err(_) => {
-                        self.get_todo_list().mark_task_failed(&task.id).await;
-                    }
+            let todo_list = TodoProcessor::get_todo_list(self).await;
+            let mut list = todo_list.write().await;
+
+            if let Some(task) = list.get_next_task() {
+                let task_id = task.id.clone();
+                drop(list); // Release the lock before processing
+                let result = self.process_task(task).await;
+                let mut list = todo_list.write().await;
+                if result.is_ok() {
+                    list.mark_task_completed(&task_id);
+                } else {
+                    list.mark_task_failed(&task_id);
                 }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
             }
-            tokio::time::sleep(self.get_check_interval()).await;
         }
     }
 }
