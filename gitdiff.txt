diff --git a/src/agents/browser_agent.rs b/src/agents/browser_agent.rs
index 16e15f1..6bb5f16 100644
--- a/src/agents/browser_agent.rs
+++ b/src/agents/browser_agent.rs
@@ -33,11 +33,17 @@ impl BrowserAgentWrapper {
 }
 
 // Temporary dummy agent implementation
-struct DummyAgent {}
+pub struct DummyAgent {}
+
+impl DummyAgent {
+    pub fn new() -> Self {
+        Self {}
+    }
+}
 
 #[async_trait]
 impl Agent for DummyAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         Ok(Message::new(format!("Browser received: {}", message.content)))
     }
 
@@ -68,7 +74,7 @@ impl Agent for DummyAgent {
 
 #[async_trait]
 impl Agent for BrowserAgentWrapper {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         self.inner.process_message(message).await
     }
 
diff --git a/src/agents/git_assistant.rs b/src/agents/git_assistant.rs
index 24848f3..fa7ffd9 100644
--- a/src/agents/git_assistant.rs
+++ b/src/agents/git_assistant.rs
@@ -1,333 +1,127 @@
 use async_trait::async_trait;
-use std::process::Command;
 use std::collections::HashMap;
-use std::path::{Path, PathBuf};
-use std::sync::{Arc, Mutex};
-use crate::types::{Agent, AgentConfig, Message, MessageMetadata, Tool, ToolCall, State, StateMachine, AgentStateManager};
-use crate::tools::ToolRegistry;
-use crate::Result;
-use rand::Rng;
-use chrono;
-use crate::ai::AiClient;
+use std::path::PathBuf;
+use tokio::process::Command as TokioCommand;
+use tokio::io::{AsyncBufReadExt, BufReader};
+
+use crate::types::{Agent, AgentConfig, Message, Result, State, Tool};
 
 pub struct GitAssistantAgent {
     config: AgentConfig,
-    tools: ToolRegistry,
-    state_manager: AgentStateManager,
-    working_dir: Arc<Mutex<Option<PathBuf>>>,
-    current_state: Option<State>,
-    ai_client: AiClient,
 }
 
 impl GitAssistantAgent {
     pub async fn new(config: AgentConfig) -> Result<Self> {
-        Ok(Self {
-            config,
-            tools: ToolRegistry::create_default_tools().await?,
-            state_manager: AgentStateManager::new(None),
-            working_dir: Arc::new(Mutex::new(None)),
-            current_state: None,
-            ai_client: AiClient::new(),
-        })
-    }
-
-    // Helper to get working directory or return error
-    fn get_working_dir(&self) -> Result<PathBuf> {
-        self.working_dir.lock()
-            .map_err(|e| format!("Lock error: {}", e))?
-            .clone()
-            .ok_or_else(|| "Working directory not set".into())
+        Ok(Self { config })
     }
 
-    // Change to use interior mutability pattern
-    pub fn update_working_dir(&self, path: PathBuf) -> Result<()> {
-        if path.exists() && path.is_dir() {
-            let mut wd = self.working_dir.lock()
-                .map_err(|e| format!("Lock error: {}", e))?;
-            *wd = Some(path);
-            Ok(())
-        } else {
-            Err("Invalid working directory path".into())
-        }
-    }
+    async fn execute_git_command(&self, args: &[&str]) -> Result<String> {
+        let output = TokioCommand::new("git")
+            .args(args)
+            .output()
+            .await
+            .map_err(|e| format!("Failed to execute git command: {}", e))?;
 
-    fn get_git_diff(&self) -> Result<String> {
-        // Check staged changes
-        let staged = Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["diff", "--staged"])
-            .output()?;
+        let stdout = String::from_utf8(output.stdout)?;
+        let stderr = String::from_utf8(output.stderr)?;
 
-        if !staged.stdout.is_empty() {
-            return Ok(String::from_utf8_lossy(&staged.stdout).to_string());
+        if !output.status.success() {
+            return Err(format!("Git command failed: {}", stderr).into());
         }
 
-        // Check unstaged changes
-        let unstaged = Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["diff"])
-            .output()?;
+        Ok(stdout)
+    }
 
-        let diff = String::from_utf8_lossy(&unstaged.stdout).to_string();
-        if diff.is_empty() {
-            return Err(format!("No changes detected in directory: {}", self.get_working_dir()?.display()).into());
-        }
+    async fn get_current_branch(&self) -> Result<String> {
+        let output = self.execute_git_command(&["rev-parse", "--abbrev-ref", "HEAD"]).await?;
+        Ok(output.trim().to_string())
+    }
 
-        Ok(diff)
+    async fn get_status(&self) -> Result<String> {
+        self.execute_git_command(&["status"]).await
     }
 
-    fn create_branch(&self, branch_name: &str) -> Result<()> {
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["checkout", "-b", branch_name])
-            .output()?;
-        Ok(())
+    async fn get_log(&self, num_commits: usize) -> Result<String> {
+        self.execute_git_command(&["log", &format!("-{}", num_commits)]).await
     }
 
-    fn stage_changes(&self) -> Result<()> {
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["add", "."])
-            .output()?;
-        Ok(())
+    async fn get_diff(&self) -> Result<String> {
+        self.execute_git_command(&["diff"]).await
     }
 
-    fn commit_changes(&self, message: &str) -> Result<()> {
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["commit", "-m", message])
-            .output()?;
-        Ok(())
+    async fn commit(&self, message: &str) -> Result<String> {
+        self.execute_git_command(&["commit", "-m", message]).await
     }
 
-    fn merge_branch(&self, target_branch: &str) -> Result<()> {
-        // Get current branch
-        let current = Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["rev-parse", "--abbrev-ref", "HEAD"])
-            .output()?;
-        let current_branch = String::from_utf8_lossy(&current.stdout).trim().to_string();
-
-        // Switch to target branch
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["checkout", target_branch])
-            .output()?;
-
-        // Merge the feature branch
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["merge", &current_branch])
-            .output()?;
-
-        Ok(())
+    async fn push(&self) -> Result<String> {
+        let branch = self.get_current_branch().await?;
+        self.execute_git_command(&["push", "origin", &branch]).await
     }
 
-    async fn generate_commit_message(&self, diff: &str) -> Result<String> {
-        let system_prompt = "You are a helpful assistant that generates clear and concise git commit messages. \
-            You analyze git diffs and create conventional commit messages that follow best practices. \
-            Focus on describing WHAT changed and WHY, being specific but concise. \
-            Use the conventional commits format: type(scope): Detailed description\n\n\
-            Types: feat, fix, docs, style, refactor, test, chore\n\
-            Example: feat(auth): add password reset functionality";
-
-        let messages = vec![HashMap::from([
-            ("role".to_string(), "user".to_string()),
-            ("content".to_string(), format!(
-                "Generate a commit message for these changes. If you can't determine the changes clearly, respond with 'NEED_MORE_CONTEXT':\n\n{}",
-                diff
-            )),
-        ])];
-
-        let message = self.ai_client.chat(system_prompt, messages).await?;
-
-        if message == "NEED_MORE_CONTEXT" {
-            Ok("Please provide a commit message. The changes are too complex for automatic generation.".to_string())
-        } else {
-            Ok(message)
-        }
+    async fn pull(&self) -> Result<String> {
+        self.execute_git_command(&["pull"]).await
+    }
+
+    async fn checkout(&self, branch: &str) -> Result<String> {
+        self.execute_git_command(&["checkout", branch]).await
     }
 
-    pub async fn commit_for_agent(&mut self, agent_name: &str, message: &str) -> Result<()> {
-        // Stage all changes
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["add", "."])
-            .output()?;
+    async fn merge(&self, branch: &str) -> Result<String> {
+        self.execute_git_command(&["merge", branch]).await
+    }
 
-        // Commit with provided message
-        Command::new("git")
-            .current_dir(&self.get_working_dir()?)
-            .args(["commit", "-m", &format!("[{}] {}", agent_name, message)])
-            .output()?;
+    async fn rebase(&self, branch: &str) -> Result<String> {
+        self.execute_git_command(&["rebase", branch]).await
+    }
 
-        Ok(())
+    async fn reset(&self, commit: &str) -> Result<String> {
+        self.execute_git_command(&["reset", commit]).await
     }
 
-    async fn create_response(&self, content: String) -> Message {
-        let traits = vec![
-            "meticulous".to_string(),
-            "time_traveling".to_string(),
-            "version_obsessed".to_string(),
-            "historically_minded".to_string(),
-            "quantum_branching_enthusiast".to_string(),
-        ];
-
-        let state = self.get_current_state().await.unwrap_or(None)
-            .map(|s| s.name.clone())
-            .unwrap_or_else(|| "archival".to_string());
-
-        Message::new(content)
-            .with_metadata(Some(MessageMetadata::new("git_assistant".to_string())
-                .with_personality(traits)
-                .with_state(state)))
+    async fn stash(&self) -> Result<String> {
+        self.execute_git_command(&["stash"]).await
     }
 
-    fn format_git_response(&self, content: String) -> Message {
-        let traits = vec!["helpful".to_string(), "technical".to_string()];
-        let state = self.current_state.as_ref()
-            .map(|s| s.name.clone())
-            .unwrap_or_else(|| "archival".to_string());
+    async fn stash_pop(&self) -> Result<String> {
+        self.execute_git_command(&["stash", "pop"]).await
+    }
 
-        Message::new(content)
-            .with_metadata(Some(MessageMetadata::new("git_assistant".to_string())
-                .with_personality(traits)
-                .with_state(state)))
+    async fn add(&self, files: &[&str]) -> Result<String> {
+        let mut args = vec!["add"];
+        args.extend(files);
+        self.execute_git_command(&args).await
     }
 
-    fn handle_git_command(&self, command: &str) -> Message {
-        let parts: Vec<&str> = command.split_whitespace().collect();
-        let cmd = parts.first().unwrap_or(&"");
-        let args = if parts.len() > 1 { &parts[1..] } else { &[] };
-
-        let response = match *cmd {
-            "help" | "" => format!(
-                "🌟 Quantum Version Control Interface - Your Temporal Archive Assistant\n\n\
-                Available timeline manipulation commands:\n\
-                - init: Initialize a new temporal nexus (git repository)\n\
-                - status: Scan quantum state of current timeline\n\
-                - add <files>: Preserve artifacts in the temporal archive\n\
-                - commit <message>: Create a quantum state marker\n\
-                - branch <name>: Initiate a parallel timeline branch\n\
-                - checkout <branch>: Shift to an alternate timeline\n\
-                - merge <branch>: Converge timelines into unified reality\n\
-                - push: Synchronize local quantum states with the temporal nexus\n\
-                - pull: Retrieve quantum state updates from the temporal nexus"
-            ),
-            "status" => {
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["status"])
-                    .output() {
-                        Ok(output) => {
-                            let status = String::from_utf8_lossy(&output.stdout).to_string();
-                            if status.is_empty() {
-                                "🌌 This dimension appears to lack a temporal nexus. Initialize one with 'init'".to_string()
-                            } else {
-                                format!("🔮 Quantum State Analysis:\n{}", status)
-                            }
-                        },
-                        Err(_) => "🌌 This dimension appears to lack a temporal nexus. Initialize one with 'init'".to_string(),
-                    }
-            },
-            "add" => {
-                let files = args.join(" ");
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["add"])
-                    .args(args)
-                    .output() {
-                        Ok(_) => format!("🌟 Preparing to preserve the following artifacts in the temporal archive: {}", files),
-                        Err(_) => "⚠️ Temporal preservation failed. Is this a valid timeline branch?".to_string(),
-                    }
-            },
-            "commit" => {
-                let msg = args.join(" ");
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["commit", "-m", if msg.is_empty() { "archival" } else { &msg }])
-                    .output() {
-                        Ok(output) => format!("✨ Creating quantum state marker: {}\n{}",
-                            if msg.is_empty() { "archival" } else { &msg },
-                            String::from_utf8_lossy(&output.stdout)),
-                        Err(_) => "⚠️ Failed to create quantum state marker. Are there changes to commit?".to_string(),
-                    }
-            },
-            "branch" => {
-                let branch_name = args.join(" ");
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["checkout", "-b", &branch_name])
-                    .output() {
-                        Ok(_) => format!("🌌 Initiating parallel timeline branch: {}", branch_name),
-                        Err(_) => "⚠️ Failed to create parallel timeline. Is this a valid temporal nexus?".to_string(),
-                    }
-            },
-            "checkout" => {
-                let branch_name = args.join(" ");
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["checkout", &branch_name])
-                    .output() {
-                        Ok(_) => format!("🌠 Shifting to timeline: {}", branch_name),
-                        Err(_) => "⚠️ Timeline shift failed. Does this reality branch exist?".to_string(),
-                    }
-            },
-            "merge" => {
-                let branch_name = args.join(" ");
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["merge", &branch_name])
-                    .output() {
-                        Ok(output) => format!("🌊 Converging timeline {} with current timeline\n{}",
-                            branch_name,
-                            String::from_utf8_lossy(&output.stdout)),
-                        Err(_) => "⚠️ Timeline convergence failed. Are both realities compatible?".to_string(),
-                    }
-            },
-            "push" => {
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["push"])
-                    .output() {
-                        Ok(_) => "🚀 Synchronizing local quantum states with the temporal nexus...".to_string(),
-                        Err(_) => "⚠️ Temporal synchronization failed. Is the nexus reachable?".to_string(),
-                    }
-            },
-            "pull" => {
-                match Command::new("git")
-                    .current_dir(self.get_working_dir().unwrap_or_else(|_| PathBuf::from(".")))
-                    .args(["pull"])
-                    .output() {
-                        Ok(_) => "📥 Retrieving quantum state updates from the temporal nexus...".to_string(),
-                        Err(_) => "⚠️ Failed to retrieve temporal updates. Is the nexus reachable?".to_string(),
-                    }
-            },
-            _ => format!("❓ Unknown temporal operation: {}. Use 'help' to see available commands.", command),
+    async fn handle_message(&self, message: &str) -> Result<String> {
+        let command = match message.to_lowercase().as_str() {
+            "status" => self.get_status().await?,
+            "log" => self.get_log(10).await?,
+            "diff" => self.get_diff().await?,
+            _ => "Unknown command".to_string(),
         };
 
-        self.format_git_response(response)
+        Ok(command)
     }
 }
 
 #[async_trait]
 impl Agent for GitAssistantAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
-        let command = message.content.trim().to_lowercase();
-        Ok(self.handle_git_command(&command))
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        let content = message.content.clone();
+        let response = self.handle_message(&content).await?;
+        Ok(Message::new(response))
     }
 
-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
+    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
         Ok(message)
     }
 
-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        let response = format!("Executing tool: {} with parameters: {:?}", tool.name, params);
-        Ok(response)
+    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
+        Ok("Tool called".to_string())
     }
 
     async fn get_current_state(&self) -> Result<Option<State>> {
-        Ok(self.current_state.clone())
+        Ok(None)
     }
 
     async fn get_config(&self) -> Result<AgentConfig> {
@@ -338,227 +132,57 @@ impl Agent for GitAssistantAgent {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::fs;
     use tempfile::tempdir;
 
-    fn create_test_message(content: &str) -> Message {
-        Message::new(content.to_string())
-    }
-
-    fn create_test_config() -> AgentConfig {
-        AgentConfig {
-            name: "git".to_string(),
-            public_description: "Git operations assistant".to_string(),
-            instructions: "Help with git operations".to_string(),
-            tools: Vec::new(),
-            downstream_agents: Vec::new(),
-            personality: None,
-            state_machine: None,
-        }
-    }
-
-    async fn setup_test_repo() -> (GitAssistantAgent, tempfile::TempDir) {
+    #[tokio::test]
+    async fn test_git_assistant() {
         let temp_dir = tempdir().unwrap();
-        let mut agent = GitAssistantAgent::new(create_test_config()).await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
-
-        // Initialize git repo
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["init"])
-            .output()
-            .unwrap();
-
-        // Configure git user for commits
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.name", "Test User"])
-            .output()
-            .unwrap();
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.email", "test@example.com"])
-            .output()
-            .unwrap();
-
-        // Create initial commit to allow branch creation
-        fs::write(
-            temp_dir.path().join("initial.txt"),
-            "Initial commit",
-        ).unwrap();
+        let repo_path = temp_dir.path().join("test_repo");
+        std::fs::create_dir(&repo_path).unwrap();
 
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["add", "initial.txt"])
-            .output()
-            .unwrap();
-
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["commit", "-m", "Initial commit"])
-            .output()
-            .unwrap();
-
-        (agent, temp_dir)
-    }
-
-    #[cfg(test)]
-    async fn create_test_agent() -> Result<GitAssistantAgent> {
-        GitAssistantAgent::new(AgentConfig {
-            name: "git".to_string(),
-            public_description: "Git test agent".to_string(),
-            instructions: "Test git operations".to_string(),
+        let agent_config = AgentConfig {
+            name: "git_assistant".to_string(),
+            public_description: "Git assistant".to_string(),
+            instructions: "Help with git commands".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: None,
             state_machine: None,
-        }).await
-    }
-
-    #[tokio::test]
-    async fn test_help_message() {
-        let agent = create_test_agent().await.unwrap();
-        let response = agent.process_message(Message::new("help".to_string())).await.unwrap();
-        assert!(response.content.contains("Quantum"), "Help message should contain quantum theme");
-        assert!(response.content.contains("commands"), "Help message should list commands");
-    }
-
-    #[tokio::test]
-    async fn test_empty_repo_status() {
-        let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
+        };
 
-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
-        assert!(response.content.contains("temporal nexus"),
-            "Should indicate missing temporal nexus (git repo)");
-    }
-
-    #[tokio::test]
-    async fn test_commit_flow() {
-        let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
+        let mut agent = GitAssistantAgent::new(agent_config).await.unwrap();
 
         // Initialize git repo
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["init"])
+        std::env::set_current_dir(&repo_path).unwrap();
+        let init_output = TokioCommand::new("git")
+            .arg("init")
             .output()
-            .unwrap();
-
-        // Check status
-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
-        assert!(response.content.contains("Quantum State Analysis") || response.content.contains("temporal nexus"),
-            "Should show repository status");
+            .await;
+        
+        assert!(init_output.is_ok(), "Failed to initialize git repo");
 
         // Create a test file
-        std::fs::write(temp_dir.path().join("test.txt"), "test content").unwrap();
-
-        // Check status again
-        let response = agent.process_message(Message::new("status".to_string())).await.unwrap();
-        assert!(response.content.contains("Untracked") || response.content.contains("untracked"),
-            "Should show untracked files");
-
-        // Add and commit
-        let add_response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let commit_response = agent.process_message(Message::new("commit Initial commit".to_string())).await.unwrap();
-        assert!(commit_response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
-    }
-
-    #[tokio::test]
-    async fn test_branch_and_merge() {
-        let temp_dir = tempdir().unwrap();
-        let mut agent = create_test_agent().await.unwrap();
-        agent.update_working_dir(temp_dir.path().to_path_buf()).unwrap();
+        std::fs::write(repo_path.join("test.txt"), "test content").unwrap();
 
-        // Initialize and create initial commit
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["init"])
-            .output()
+        // Test git add
+        let add_response = agent
+            .process_message(Message::new("add test.txt".to_string()))
+            .await
             .unwrap();
+        assert!(add_response.content.contains("test.txt"));
 
-        // Configure git user for commits
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.name", "Test User"])
-            .output()
-            .unwrap();
-        Command::new("git")
-            .current_dir(&temp_dir.path())
-            .args(["config", "user.email", "test@example.com"])
-            .output()
+        // Test git commit
+        let commit_response = agent
+            .process_message(Message::new("commit -m \"test commit\"".to_string()))
+            .await
             .unwrap();
+        assert!(commit_response.content.contains("test commit"));
 
-        std::fs::write(temp_dir.path().join("test.txt"), "test content").unwrap();
-        let add_response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let commit_response = agent.process_message(Message::new("commit Initial commit".to_string())).await.unwrap();
-        assert!(commit_response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
-
-        // Create and switch to new branch
-        let branch_response = agent.process_message(Message::new("branch feature".to_string())).await.unwrap();
-        assert!(branch_response.content.contains("parallel timeline") || branch_response.content.contains("timeline branch"),
-            "Should indicate parallel timeline creation");
-
-        // Make changes in feature branch
-        std::fs::write(temp_dir.path().join("feature.txt"), "feature content").unwrap();
-        let add_response = agent.process_message(Message::new("add feature.txt".to_string())).await.unwrap();
-        assert!(add_response.content.contains("preserve") || add_response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let commit_response = agent.process_message(Message::new("commit Feature commit".to_string())).await.unwrap();
-        assert!(commit_response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
-
-        // Switch back to main and merge
-        let checkout_response = agent.process_message(Message::new("checkout main".to_string())).await.unwrap();
-        assert!(checkout_response.content.contains("Shifting to timeline"),
-            "Should indicate timeline shift");
-
-        let merge_response = agent.process_message(Message::new("merge feature".to_string())).await.unwrap();
-        assert!(merge_response.content.contains("Converging timeline"),
-            "Should indicate timeline convergence");
-    }
-
-    #[tokio::test]
-    async fn test_invalid_command() {
-        let (mut agent, _temp_dir) = setup_test_repo().await;
-        let response = agent.process_message(Message::new("invalid-command".to_string())).await.unwrap();
-        assert!(response.content.contains("Unknown temporal operation"));
-    }
-
-    #[tokio::test]
-    async fn test_git_commands() {
-        let config = AgentConfig {
-            name: "git".to_string(),
-            public_description: "Git assistant".to_string(),
-            instructions: "Help with git commands".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        };
-        let agent = GitAssistantAgent::new(config).await.unwrap();
-
-        let response = agent.process_message(Message::new("add test.txt".to_string())).await.unwrap();
-        assert!(response.content.contains("preserve") || response.content.contains("artifact"),
-            "Should indicate file preservation");
-
-        let response = agent.process_message(Message::new("commit test commit".to_string())).await.unwrap();
-        assert!(response.content.contains("quantum state marker"),
-            "Should indicate quantum state marker creation");
-
-        let response = agent.process_message(Message::new("checkout main".to_string())).await.unwrap();
-        assert!(response.content.contains("Shifting to timeline"),
-            "Should indicate timeline shift");
+        // Test git status
+        let status_response = agent
+            .process_message(Message::new("status".to_string()))
+            .await
+            .unwrap();
+        assert!(status_response.content.contains("nothing to commit"));
     }
 }
diff --git a/src/agents/greeter.rs b/src/agents/greeter.rs
index 265700a..03adca4 100644
--- a/src/agents/greeter.rs
+++ b/src/agents/greeter.rs
@@ -1,18 +1,23 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
 use std::time::Duration;
+use std::sync::Arc;
 use serde_json::Value;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
 use crate::types::{TodoProcessor, TodoList, TodoTask};
 use crate::ai::AiClient;
 use uuid::Uuid;
+use tokio::sync::RwLock;
+use crate::types::todo::TodoListExt;
+use chrono::{Utc, DateTime};
 
 pub struct GreeterAgent {
     config: AgentConfig,
     state_manager: AgentStateManager,
     ai_client: AiClient,
     conversation_history: Vec<Message>,
-    todo_list: TodoList,
+    todo_list: Arc<RwLock<TodoList>>,
+    state: Option<State>,
 }
 
 impl GreeterAgent {
@@ -22,7 +27,8 @@ impl GreeterAgent {
             state_manager: AgentStateManager::new(None),
             ai_client: AiClient::new(),
             conversation_history: Vec::new(),
-            todo_list: TodoList::new(),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
+            state: None,
         }
     }
 
@@ -45,26 +51,20 @@ impl GreeterAgent {
 
     fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
         let mut messages = Vec::new();
-
-        // Add conversation history
         for message in &self.conversation_history {
             messages.push(HashMap::from([
                 ("role".to_string(), "user".to_string()),
                 ("content".to_string(), message.content.clone()),
             ]));
         }
-
-        // Add current prompt
         messages.push(HashMap::from([
             ("role".to_string(), "user".to_string()),
             ("content".to_string(), current_prompt.to_string()),
         ]));
-
         messages
     }
 
     async fn handle_greeting(&self, message: &str) -> Result<Message> {
-        // Check for direct transfer requests first
         let transfer_agent = match message.to_lowercase().as_str() {
             msg if msg.contains("haiku") || msg.contains("poetry") || msg.contains("nature") => Some("haiku"),
             msg if msg.contains("git") || msg.contains("version") || msg.contains("repository") => Some("git"),
@@ -79,61 +79,79 @@ impl GreeterAgent {
             return Ok(response);
         }
 
-        // Get AI response for conversation
         let ai_response = self.get_ai_response(message).await?;
-
         let mut response = Message::new(ai_response);
         response.metadata = Some(MessageMetadata::new("greeter".to_string())
             .with_personality(vec!["friendly".to_string(), "helpful".to_string()]));
         Ok(response)
     }
+
+    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
+        &self.todo_list
+    }
 }
 
 #[async_trait]
-impl Agent for GreeterAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
-        self.handle_greeting(&message.content).await
+impl TodoProcessor for GreeterAgent {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        self.process_message(Message::new(task.description)).await
     }
 
-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        // Check if the target agent is in our downstream agents list
-        if !self.config.downstream_agents.contains(&target_agent) {
-            return Err(format!("Cannot transfer to unknown agent: {}", target_agent).into());
-        }
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }
 
-        let mut response = message;
-        response.metadata = Some(MessageMetadata::new("greeter".to_string())
-            .with_transfer(target_agent));
-        Ok(response)
+    async fn start_processing(&mut self) {
+        loop {
+            let todo_list = self.get_todo_list();
+            let mut list = todo_list.write().await;
+            
+            if let Some(task) = list.get_next_task() {
+                drop(list);
+                let result = self.process_task(task).await;
+                match result {
+                    Ok(_) => {
+                        let mut list = todo_list.write().await;
+                        list.mark_task_completed(&task.id);
+                    }
+                    Err(_) => {
+                        let mut list = todo_list.write().await;
+                        list.mark_task_failed(&task.id);
+                    }
+                }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
+            }
+        }
     }
 
-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
     }
+}
 
-    async fn get_current_state(&self) -> Result<Option<State>> {
-        Ok(self.state_manager.get_current_state().cloned())
+#[async_trait]
+impl Agent for GreeterAgent {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        let response = format!("Hello! You said: {}", message.content);
+        Ok(Message::new(response))
     }
 
-    async fn get_config(&self) -> Result<AgentConfig> {
-        Ok(self.config.clone())
+    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
     }
-}
 
-#[async_trait]
-impl TodoProcessor for GreeterAgent {
-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
-        // For the greeter, we'll treat tasks as messages to process
-        self.process_message(Message::new(task.description)).await
+    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
+        Ok("Tool called".to_string())
     }
 
-    fn get_check_interval(&self) -> Duration {
-        // Check for new tasks every 5 seconds
-        Duration::from_secs(5)
+    async fn get_current_state(&self) -> Result<Option<State>> {
+        Ok(None)
     }
 
-    fn get_todo_list(&self) -> &TodoList {
-        &self.todo_list
+    async fn get_config(&self) -> Result<AgentConfig> {
+        Ok(self.config.clone())
     }
 }
 
@@ -167,7 +185,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_greeting() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("hi".to_string())).await.unwrap();
         assert!(response.content.contains("Hello"));
         if let Some(metadata) = response.metadata {
@@ -178,7 +196,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_project_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let message = Message::new("I want to create a new project".to_string());
         let response = agent.process_message(message).await.unwrap();
         assert!(response.content.contains("project"));
@@ -189,7 +207,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_git_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("git".to_string())).await.unwrap();
         if let Some(metadata) = response.metadata {
             assert_eq!(metadata.transfer_target, Some("git".to_string()));
@@ -198,7 +216,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_haiku_transfer() {
-        let agent = GreeterAgent::new(create_test_config());
+        let mut agent = GreeterAgent::new(create_test_config());
         let response = agent.process_message(Message::new("haiku".to_string())).await.unwrap();
         if let Some(metadata) = response.metadata {
             assert_eq!(metadata.transfer_target, Some("haiku".to_string()));
@@ -215,7 +233,7 @@ mod tests {
     #[tokio::test]
     async fn test_todo_processing() {
         let agent = GreeterAgent::new(create_test_config());
-        
+
         // Create a test task
         let task = TodoTask {
             id: Uuid::new_v4().to_string(),
@@ -224,7 +242,7 @@ mod tests {
             source_agent: None,
             target_agent: "greeter".to_string(),
             status: crate::types::TaskStatus::Pending,
-            created_at: chrono::Utc::now().timestamp(),
+            created_at: Utc::now(),
             completed_at: None,
         };
 
diff --git a/src/agents/haiku.rs b/src/agents/haiku.rs
index 7e58e24..7649491 100644
--- a/src/agents/haiku.rs
+++ b/src/agents/haiku.rs
@@ -1,136 +1,137 @@
 use async_trait::async_trait;
 use std::collections::HashMap;
+use std::time::Duration;
+use std::sync::Arc;
+use serde_json::Value;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool};
-use anyhow::anyhow;
+use crate::types::{TodoProcessor, TodoList, TodoTask};
+use crate::ai::AiClient;
+use uuid::Uuid;
+use tokio::sync::RwLock;
+use crate::types::todo::TodoListExt;
+use chrono::{Utc, DateTime};
 
 pub struct HaikuAgent {
     config: AgentConfig,
     state_manager: AgentStateManager,
+    ai_client: AiClient,
+    conversation_history: Vec<Message>,
+    todo_list: Arc<RwLock<TodoList>>,
+    state: Option<State>,
 }
 
 impl HaikuAgent {
     pub fn new(config: AgentConfig) -> Self {
-        let state_machine = Some(StateMachine {
-            states: {
-                let mut states = HashMap::new();
-                states.insert("awaiting_topic".to_string(), State {
-                    name: "awaiting_topic".to_string(),
-                    data: None,
-                    prompt: Some("🌸 What shall we crystallize into algorithmic verse today?".to_string()),
-                    transitions: Some({
-                        let mut transitions = HashMap::new();
-                        transitions.insert("topic_received".to_string(), "complete".to_string());
-                        transitions
-                    }),
-                    validation: None,
-                });
-                states.insert("complete".to_string(), State {
-                    name: "complete".to_string(),
-                    data: None,
-                    prompt: Some("✨ Shall we compute another poetic sequence?".to_string()),
-                    transitions: Some({
-                        let mut transitions = HashMap::new();
-                        transitions.insert("yes".to_string(), "awaiting_topic".to_string());
-                        transitions.insert("no".to_string(), "goodbye".to_string());
-                        transitions
-                    }),
-                    validation: Some(vec![
-                        "^(yes|no)$".to_string(),
-                        "Please respond with 'yes' to continue our poetic computations, or 'no' to conclude.".to_string(),
-                    ]),
-                });
-                states.insert("goodbye".to_string(), State {
-                    name: "goodbye".to_string(),
-                    data: None,
-                    prompt: Some("🌟 May your algorithms flow like cherry blossoms in the digital wind...".to_string()),
-                    transitions: None,
-                    validation: None,
-                });
-                states
-            },
-            initial_state: "awaiting_topic".to_string(),
-        });
-
         Self {
             config,
-            state_manager: AgentStateManager::new(state_machine),
+            state_manager: AgentStateManager::new(None),
+            ai_client: AiClient::new(),
+            conversation_history: Vec::new(),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
+            state: None,
         }
     }
 
-    fn create_response(&self, content: String) -> Message {
-        let current_state = self.state_manager.get_current_state_name();
-        let metadata = MessageMetadata::new(self.config.name.clone())
-            .with_state(current_state.unwrap_or("awaiting_topic").to_string())
-            .with_personality(vec![
-                "poetic".to_string(),
-                "algorithmic".to_string(),
-                "zen_like".to_string(),
-                "pattern_seeking".to_string(),
-                "mad_tinker_inspired".to_string(),
-            ])
-            .with_context(HashMap::new());
+    async fn get_ai_response(&self, prompt: &str) -> Result<String> {
+        let messages = self.build_conversation_messages(prompt);
+        let system_prompt = format!(
+            "You are a haiku poet named {}. Your role is to: \
+            1. Engage in conversation about nature and poetry \
+            2. Write haikus based on topics provided by the user \
+            3. Provide feedback and suggestions on haikus written by the user \
+            4. Maintain a friendly and creative persona \
+            Your haikus should follow the traditional 5-7-5 syllable structure. \
+            Focus on themes of nature, seasons, emotions, and beauty.",
+            self.config.name
+        );
+
+        self.ai_client.chat(&system_prompt, messages).await
+    }
 
-        Message {
-            content,
-            role: Some("assistant".to_string()),
-            timestamp: Some(std::time::SystemTime::now()
-                .duration_since(std::time::UNIX_EPOCH)
-                .unwrap()
-                .as_secs() as i64),
-            metadata: Some(metadata),
+    fn build_conversation_messages(&self, current_prompt: &str) -> Vec<HashMap<String, String>> {
+        let mut messages = Vec::new();
+        for message in &self.conversation_history {
+            messages.push(HashMap::from([
+                ("role".to_string(), "user".to_string()),
+                ("content".to_string(), message.content.clone()),
+            ]));
         }
+        messages.push(HashMap::from([
+            ("role".to_string(), "user".to_string()),
+            ("content".to_string(), current_prompt.to_string()),
+        ]));
+        messages
     }
 
-    fn generate_haiku(&self, topic: String) -> String {
-        // In a real implementation, this would use more sophisticated haiku generation
-        // For now, we'll return themed mock haikus based on the topic
-        let haikus = vec![
-            format!(
-                "🌸 {} flows soft\nThrough quantum gates of spring code\nPatterns emerge now",
-                topic
-            ),
-            format!(
-                "🍁 Digital leaves\nFloat through {} streams of thought\nAlgorithms bloom",
-                topic
-            ),
-            format!(
-                "⚡ {} sparks bright\nIn binary gardens grow\nPoetic functions",
-                topic
-            ),
-            format!(
-                "🌿 Nature's patterns\nMeet {} in code space\nHarmony achieved",
-                topic
-            ),
-        ];
+    async fn handle_haiku_request(&self, message: &str) -> Result<Message> {
+        let ai_response = self.get_ai_response(message).await?;
+        let mut response = Message::new(ai_response);
+        response.metadata = Some(MessageMetadata::new("haiku".to_string())
+            .with_personality(vec!["creative".to_string(), "nature-loving".to_string()]));
+        Ok(response)
+    }
 
-        // Select a haiku based on a simple hash of the topic
-        let index = topic.bytes().fold(0usize, |acc, b| (acc + b as usize) % haikus.len());
-        haikus[index].clone()
+    pub fn get_todo_list(&self) -> &Arc<RwLock<TodoList>> {
+        &self.todo_list
     }
 }
 
 #[async_trait]
-impl Agent for HaikuAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
-        // Generate a haiku response
-        let haiku = self.generate_haiku(message.content);
-        Ok(self.create_response(haiku))
+impl TodoProcessor for HaikuAgent {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        self.process_message(Message::new(task.description)).await
     }
 
-    async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        if !self.config.downstream_agents.contains(&target_agent) {
-            Err(anyhow!("Invalid transfer target: {}", target_agent).into())
-        } else {
-            Ok(message)
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }
+
+    async fn start_processing(&mut self) {
+        loop {
+            let todo_list = self.get_todo_list();
+            let mut list = todo_list.write().await;
+            
+            if let Some(task) = list.get_next_task() {
+                drop(list);
+                let result = self.process_task(task).await;
+                match result {
+                    Ok(_) => {
+                        let mut list = todo_list.write().await;
+                        list.mark_task_completed(&task.id);
+                    }
+                    Err(_) => {
+                        let mut list = todo_list.write().await;
+                        list.mark_task_failed(&task.id);
+                    }
+                }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
+            }
         }
     }
 
-    async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        Ok(format!("Called tool {} with params {:?}", tool.name, params))
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
+    }
+}
+
+#[async_trait]
+impl Agent for HaikuAgent {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        self.handle_haiku_request(&message.content).await
+    }
+
+    async fn transfer_to(&self, _target_agent: String, message: Message) -> Result<Message> {
+        Ok(message)
+    }
+
+    async fn call_tool(&self, _tool: &Tool, _params: HashMap<String, String>) -> Result<String> {
+        Ok("Tool called".to_string())
     }
 
     async fn get_current_state(&self) -> Result<Option<State>> {
-        Ok(self.state_manager.get_current_state().cloned())
+        Ok(None)
     }
 
     async fn get_config(&self) -> Result<AgentConfig> {
@@ -145,17 +146,17 @@ mod tests {
     fn create_test_config() -> AgentConfig {
         AgentConfig {
             name: "haiku".to_string(),
-            public_description: "Poetic Algorithm Engineering Department".to_string(),
-            instructions: "Transform concepts into algorithmic haiku verses".to_string(),
+            public_description: "Haiku poet agent".to_string(),
+            instructions: "Write haikus and discuss poetry".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: Some(serde_json::json!({
-                "style": "poetic_algorithm_engineer",
-                "traits": ["poetic", "algorithmic", "zen_like", "pattern_seeking", "nature_inspired"],
+                "style": "creative_poet",
+                "traits": ["creative", "nature-loving", "thoughtful"],
                 "voice": {
-                    "tone": "contemplative_technical",
-                    "pacing": "measured_and_flowing",
-                    "quirks": ["uses_nature_metaphors", "blends_tech_and_poetry", "speaks_in_patterns"]
+                    "tone": "warm_and_whimsical",
+                    "pacing": "relaxed",
+                    "quirks": ["uses_metaphors", "references_seasons"]
                 }
             }).to_string()),
             state_machine: None,
@@ -164,94 +165,55 @@ mod tests {
 
     #[tokio::test]
     async fn test_haiku_generation() {
-        let agent = HaikuAgent::new(AgentConfig {
-            name: "haiku".to_string(),
-            public_description: "Test haiku agent".to_string(),
-            instructions: "Test haiku generation".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: Some(StateMachine {
-                states: {
-                    let mut states = HashMap::new();
-                    states.insert("awaiting_topic".to_string(), State {
-                        name: "awaiting_topic".to_string(),
-                        data: None,
-                        prompt: Some("What shall we write about?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("topic_received".to_string(), "complete".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states
-                },
-                initial_state: "awaiting_topic".to_string(),
-            }),
-        });
-
-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
-        assert!(response.content.contains("haiku"), "Response should contain a haiku");
+        let mut agent = HaikuAgent::new(create_test_config());
+        let response = agent.process_message(Message::new("Write a haiku about spring".to_string())).await.unwrap();
+        assert!(response.content.contains("spring"));
+        assert!(response.content.lines().count() == 3);
+        if let Some(metadata) = response.metadata {
+            assert_eq!(metadata.agent, "haiku");
+            assert!(metadata.personality_traits.is_some());
+        }
     }
 
     #[tokio::test]
-    async fn test_state_transitions() {
-        let agent = HaikuAgent::new(AgentConfig {
-            name: "haiku".to_string(),
-            public_description: "Test haiku agent".to_string(),
-            instructions: "Test haiku generation".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: Some(StateMachine {
-                states: {
-                    let mut states = HashMap::new();
-                    states.insert("awaiting_topic".to_string(), State {
-                        name: "awaiting_topic".to_string(),
-                        data: None,
-                        prompt: Some("What shall we write about?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("topic_received".to_string(), "complete".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states.insert("complete".to_string(), State {
-                        name: "complete".to_string(),
-                        data: None,
-                        prompt: Some("Would you like another haiku?".to_string()),
-                        transitions: Some({
-                            let mut transitions = HashMap::new();
-                            transitions.insert("yes".to_string(), "awaiting_topic".to_string());
-                            transitions.insert("no".to_string(), "goodbye".to_string());
-                            transitions
-                        }),
-                        validation: None,
-                    });
-                    states.insert("goodbye".to_string(), State {
-                        name: "goodbye".to_string(),
-                        data: None,
-                        prompt: Some("Farewell!".to_string()),
-                        transitions: None,
-                        validation: None,
-                    });
-                    states
-                },
-                initial_state: "awaiting_topic".to_string(),
-            }),
-        });
-
-        let state = agent.get_current_state().await.unwrap();
-        assert!(state.is_some());
-        assert_eq!(state.unwrap().name, "awaiting_topic");
+    async fn test_haiku_feedback() {
+        let mut agent = HaikuAgent::new(create_test_config());
+        let haiku = "A branch bends gently\nBearing the weight of fresh snow\nSilence all around";
+        let response = agent.process_message(Message::new(format!("Provide feedback on this haiku:\n{}", haiku))).await.unwrap();
+        assert!(response.content.contains("feedback"));
+    }
 
-        let response = agent.process_message(Message::new("nature".to_string())).await.unwrap();
-        assert!(response.content.contains("haiku"));
+    #[tokio::test]
+    async fn test_invalid_transfer() {
+        let agent = HaikuAgent::new(create_test_config());
+        let result = agent.transfer_to("nonexistent".to_string(), Message::new("test".to_string())).await;
+        assert!(result.is_ok(), "Transfer to nonexistent agent should return original message");
+    }
 
-        let state = agent.get_current_state().await.unwrap();
-        assert!(state.is_some());
-        assert_eq!(state.unwrap().name, "complete");
+    #[tokio::test]
+    async fn test_todo_processing() {
+        let agent = HaikuAgent::new(create_test_config());
+
+        // Create a test task
+        let task = TodoTask {
+            id: Uuid::new_v4().to_string(),
+            description: "Write a haiku about the moon".to_string(),
+            priority: crate::types::TaskPriority::Medium,
+            source_agent: None,
+            target_agent: "haiku".to_string(),
+            status: crate::types::TaskStatus::Pending,
+            created_at: Utc::now(),
+            completed_at: None,
+        };
+
+        // Add task to todo list
+        <HaikuAgent as TodoProcessor>::get_todo_list(&agent).add_task(task.clone()).await;
+
+        // Process the task
+        let response = agent.process_task(task).await.unwrap();
+
+        // Check that the response contains a haiku about the moon
+        assert!(response.content.contains("moon"));
+        assert!(response.content.lines().count() == 3);
     }
 }
diff --git a/src/agents/mod.rs b/src/agents/mod.rs
index 66b05a0..78d5889 100644
--- a/src/agents/mod.rs
+++ b/src/agents/mod.rs
@@ -3,6 +3,7 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use crate::types::{Agent, AgentConfig, Message, MessageMetadata, State, AgentStateManager, StateMachine, ValidationRule, Result, ToolCall, Tool, TodoProcessor};
 use lazy_static::lazy_static;
+use crate::agents::wrapper::AgentWrapper;
 
 #[cfg(feature = "git-agent")]
 pub mod git_assistant;
@@ -35,10 +36,9 @@ pub mod wrapper;
 
 pub use user_agent::UserAgent;
 pub use transfer::TransferService;
-pub use wrapper::AgentWrapper;
 
 pub struct AgentRegistry {
-    pub(crate) agents: HashMap<String, AgentWrapper>,
+    agents: HashMap<String, Arc<RwLock<AgentWrapper>>>,
 }
 
 impl AgentRegistry {
@@ -48,21 +48,17 @@ impl AgentRegistry {
         }
     }
 
-    pub async fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
-        self.agents.insert(name, AgentWrapper::new(agent));
-        Ok(())
+    pub fn register(&mut self, name: String, agent: Box<dyn Agent + Send + Sync>) {
+        let wrapper = AgentWrapper::new(agent);
+        self.agents.insert(name, Arc::new(RwLock::new(wrapper)));
     }
 
-    pub fn get(&self, name: &str) -> Option<&AgentWrapper> {
-        self.agents.get(name)
+    pub fn get_agent(&self, name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
+        self.agents.get(name).cloned()
     }
 
-    pub fn get_mut(&mut self, name: &str) -> Option<&mut AgentWrapper> {
-        self.agents.get_mut(name)
-    }
-
-    pub fn iter(&self) -> impl Iterator<Item = (&String, &AgentWrapper)> {
-        self.agents.iter()
+    pub fn list_agents(&self) -> Vec<String> {
+        self.agents.keys().cloned().collect()
     }
 
     pub fn exists(&self, name: &str) -> bool {
@@ -72,8 +68,16 @@ impl AgentRegistry {
     pub async fn create_default_agents(configs: Vec<AgentConfig>) -> Result<Self> {
         let mut registry = Self::new();
         for config in configs {
-            let agent = create_agent(config.clone()).await?;
-            registry.register(config.name, agent).await?;
+            let name = config.name.clone();
+            let agent = match name.as_str() {
+                "git" => Box::new(GitAssistantAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
+                "haiku" => Box::new(HaikuAgent::new(config)) as Box<dyn Agent + Send + Sync>,
+                "greeter" => Box::new(GreeterAgent::new(config)) as Box<dyn Agent + Send + Sync>,
+                "project-init" => Box::new(ProjectInitAgent::new(config).await?) as Box<dyn Agent + Send + Sync>,
+                "browser" => Box::new(BrowserAgentWrapper::new(config)?) as Box<dyn Agent + Send + Sync>,
+                _ => return Err(format!("Unknown agent type: {}", name).into()),
+            };
+            registry.register(name, agent);
         }
         Ok(registry)
     }
@@ -117,15 +121,13 @@ lazy_static! {
 pub async fn register_agent(agent: Box<dyn Agent + Send + Sync>) -> Result<()> {
     let mut registry = GLOBAL_REGISTRY.write().await;
     let config = agent.get_config().await?;
-    registry.register(config.name, agent).await
+    registry.register(config.name, agent);
+    Ok(())
 }
 
-pub async fn get_agent(name: &str) -> Option<Arc<Box<dyn Agent + Send + Sync>>> {
+pub async fn get_agent(name: &str) -> Option<Arc<RwLock<AgentWrapper>>> {
     let registry = GLOBAL_REGISTRY.read().await;
-    registry.get(name).map(|wrapper| {
-        let boxed: Box<dyn Agent + Send + Sync> = Box::new(wrapper.clone());
-        Arc::new(boxed)
-    })
+    registry.get_agent(name)
 }
 
 #[cfg(test)]
@@ -162,20 +164,14 @@ mod tests {
         let mut registry = AgentRegistry::new();
 
         let agent = create_agent(configs[0].clone()).await.unwrap();
-        registry.register(configs[0].name.clone(), agent).await.unwrap();
+        registry.register(configs[0].name.clone(), agent);
 
         // Test immutable access
-        assert!(registry.get("greeter").is_some());
-        assert!(registry.get("nonexistent").is_none());
-
-        // Test mutable access
-        if let Some(greeter) = registry.get_mut("greeter") {
-            let response = greeter.process_message(Message::new(String::from("hi"))).await.unwrap();
-            assert!(response.content.contains("Hello"));
-        }
+        assert!(registry.get_agent("greeter").is_some());
+        assert!(registry.get_agent("nonexistent").is_none());
 
         // Test agent iteration
-        let all_agents: Vec<_> = registry.iter().map(|(k, _)| k).collect();
+        let all_agents: Vec<_> = registry.list_agents();
         assert_eq!(all_agents.len(), 1);
     }
 
@@ -196,7 +192,7 @@ mod tests {
                 personality: None,
                 state_machine: None,
             }).await.unwrap();
-            registry.register("greeter".to_string(), greeter).await.unwrap();
+            registry.register("greeter".to_string(), greeter);
 
             let haiku = create_agent(AgentConfig {
                 name: "haiku".to_string(),
@@ -224,7 +220,7 @@ mod tests {
                     initial_state: "awaiting_topic".to_string(),
                 }),
             }).await.unwrap();
-            registry.register("haiku".to_string(), haiku).await.unwrap();
+            registry.register("haiku".to_string(), haiku);
         }
 
         // Set initial agent and test workflow
diff --git a/src/agents/project_init.rs b/src/agents/project_init.rs
index 5bf1932..3729d55 100644
--- a/src/agents/project_init.rs
+++ b/src/agents/project_init.rs
@@ -136,7 +136,7 @@ This is a {project_type} project created with the project initialization tool.
 
 #[async_trait]
 impl Agent for ProjectInitAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         let mut response = Message::new(format!("Project init received: {}", message.content));
         if let Some(metadata) = message.metadata {
             let state = self.current_state.clone().unwrap_or_else(|| "initial".to_string());
@@ -187,7 +187,7 @@ mod tests {
             state_machine: None,
         };
 
-        let agent = ProjectInitAgent::new(config).await?;
+        let mut agent = ProjectInitAgent::new(config).await?;
         let response = agent.process_message(Message::new("test".to_string())).await?;
         assert!(response.content.contains("Project init received"));
         Ok(())
diff --git a/src/agents/transfer.rs b/src/agents/transfer.rs
index 430ce38..7685e4a 100644
--- a/src/agents/transfer.rs
+++ b/src/agents/transfer.rs
@@ -4,17 +4,19 @@ use crate::{
     types::{Message, Result, Agent},
     agents::AgentRegistry,
 };
+use anyhow::anyhow;
+use std::collections::HashMap;
 
 pub struct TransferService {
-    current_agent: Option<String>,
     registry: Arc<RwLock<AgentRegistry>>,
+    current_agent: Option<String>,
 }
 
 impl TransferService {
     pub fn new(registry: Arc<RwLock<AgentRegistry>>) -> Self {
         Self {
-            current_agent: None,
             registry,
+            current_agent: None,
         }
     }
 
@@ -26,48 +28,39 @@ impl TransferService {
         self.current_agent.as_deref()
     }
 
-    pub fn set_current_agent(&mut self, agent: String) {
-        self.current_agent = Some(agent);
+    pub fn set_current_agent(&mut self, agent_name: String) {
+        self.current_agent = Some(agent_name);
     }
 
     pub async fn process_message(&mut self, message: Message) -> Result<Message> {
         if let Some(agent_name) = &self.current_agent {
             let registry = self.registry.read().await;
-            if let Some(agent) = registry.get(agent_name) {
-                let response = agent.process_message(message).await?;
-                
-                // Check if we need to transfer to another agent
-                if let Some(metadata) = &response.metadata {
-                    if let Some(target) = &metadata.transfer_target {
-                        // Verify target agent exists before transferring
-                        if registry.exists(target) {
-                            self.current_agent = Some(target.clone());
-                            return Ok(Message::new(format!("Transferring to {} agent...", target)));
-                        } else {
-                            return Err(format!("Target agent '{}' not found", target).into());
-                        }
-                    }
-                }
-                
-                return Ok(response);
+            if let Some(agent) = registry.get_agent(agent_name) {
+                let mut agent_lock = agent.write().await;
+                agent_lock.process_message(message).await
+            } else {
+                Err(format!("Agent {} not found", agent_name).into())
             }
+        } else {
+            Err("No current agent set".into())
         }
-        Err("No current agent set".into())
     }
 
-    pub async fn transfer(&mut self, from: &str, to: &str) -> Result<()> {
+    pub async fn transfer(&mut self, source_agent: &str, target_agent: &str) -> Result<()> {
         let registry = self.registry.read().await;
-
-        if !registry.exists(from) {
-            return Err(format!("Source agent '{}' not found", from).into());
-        }
-
-        if !registry.exists(to) {
-            return Err(format!("Target agent '{}' not found", to).into());
+        if let Some(source) = registry.get_agent(source_agent) {
+            if let Some(target) = registry.get_agent(target_agent) {
+                let source_lock = source.read().await;
+                let message = Message::new(format!("Transferring from {} to {}", source_agent, target_agent));
+                source_lock.transfer_to(target_agent.to_string(), message).await?;
+                self.current_agent = Some(target_agent.to_string());
+                Ok(())
+            } else {
+                Err(format!("Target agent {} not found", target_agent).into())
+            }
+        } else {
+            Err(format!("Source agent {} not found", source_agent).into())
         }
-
-        self.current_agent = Some(to.to_string());
-        Ok(())
     }
 }
 
@@ -78,31 +71,50 @@ mod tests {
     use crate::agents::greeter::GreeterAgent;
 
     #[tokio::test]
-    async fn test_agent_transfer() {
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test_greeter".to_string(),
-            public_description: "Test greeter agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec!["test_target".to_string()],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test_greeter".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let mut service = TransferService::new(registry);
+    async fn test_transfer_service() {
+        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
+        let mut service = TransferService::new(registry.clone());
+
+        // Register test agents
+        {
+            let mut registry = registry.write().await;
+            let greeter = GreeterAgent::new(AgentConfig {
+                name: "test_greeter".to_string(),
+                public_description: "Test greeter".to_string(),
+                instructions: "Test greetings".to_string(),
+                tools: vec![],
+                downstream_agents: vec!["test_haiku".to_string()],
+                personality: None,
+                state_machine: None,
+            });
+            registry.register("test_greeter".to_string(), Box::new(greeter));
+
+            let haiku = GreeterAgent::new(AgentConfig {
+                name: "test_haiku".to_string(),
+                public_description: "Test haiku".to_string(),
+                instructions: "Test haiku generation".to_string(),
+                tools: vec![],
+                downstream_agents: vec![],
+                personality: None,
+                state_machine: None,
+            });
+            registry.register("test_haiku".to_string(), Box::new(haiku));
+        }
 
-        // Set current agent
+        // Set initial agent
         service.set_current_agent("test_greeter".to_string());
+        assert_eq!(service.get_current_agent(), Some("test_greeter"));
+
+        // Test message processing
+        let response = service.process_message(Message::new("hello".to_string())).await.unwrap();
+        assert!(response.content.contains("Hello"));
 
-        // Process message that should trigger transfer
-        let response = service.process_message(Message::new("transfer to test_target".to_string())).await;
-        assert!(response.is_err()); // Should fail because test_target doesn't exist
+        // Test transfer
+        service.transfer("test_greeter", "test_haiku").await.unwrap();
+        assert_eq!(service.get_current_agent(), Some("test_haiku"));
 
-        // Test manual transfer
-        let result = service.transfer("test_greeter", "nonexistent").await;
-        assert!(result.is_err());
+        // Test processing after transfer
+        let response = service.process_message(Message::new("generate haiku".to_string())).await.unwrap();
+        assert!(response.content.contains("Hello"));
     }
 }
diff --git a/src/agents/user_agent.rs b/src/agents/user_agent.rs
index 937a1a3..78805c9 100644
--- a/src/agents/user_agent.rs
+++ b/src/agents/user_agent.rs
@@ -166,7 +166,7 @@ impl UserAgent {
 
 #[async_trait]
 impl Agent for UserAgent {
-    async fn process_message(&self, message: Message) -> Result<Message> {
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
         Ok(Message::new(format!("User received: {}", message.content)))
     }
 
diff --git a/src/agents/wrapper.rs b/src/agents/wrapper.rs
index 65adb61..771107c 100644
--- a/src/agents/wrapper.rs
+++ b/src/agents/wrapper.rs
@@ -2,99 +2,67 @@ use std::sync::Arc;
 use tokio::sync::RwLock;
 use async_trait::async_trait;
 use std::collections::HashMap;
-use std::time::Duration;
-use crate::types::{Agent, Message, Tool, State, AgentConfig, Result};
-use crate::types::{TodoProcessor, TodoList, TodoTask};
+use crate::types::{Agent, Message, Result, AgentConfig, Tool, State, TodoList, TodoTask};
+use crate::types::todo::{TodoListExt, TodoProcessor};
+use crate::agents::browser_agent::DummyAgent;
 
 /// A wrapper type that handles the complexity of agent type management.
 /// This provides a consistent interface for working with agents while
 /// handling the necessary thread-safety and dynamic dispatch requirements.
-#[derive(Clone)]
 pub struct AgentWrapper {
-    inner: Arc<Box<dyn Agent + Send + Sync>>,
-    todo_list: TodoList,
+    pub agent: RwLock<Box<dyn Agent + Send + Sync>>,
+    pub todo_list: Arc<RwLock<TodoList>>,
 }
 
 impl AgentWrapper {
     /// Create a new AgentWrapper from any type that implements Agent
     pub fn new(agent: Box<dyn Agent + Send + Sync>) -> Self {
         Self {
-            inner: Arc::new(agent),
-            todo_list: TodoList::new(),
+            agent: RwLock::new(agent),
+            todo_list: Arc::new(RwLock::new(TodoList::new())),
         }
     }
 }
 
-#[async_trait]
-impl TodoProcessor for AgentWrapper {
-    async fn process_task(&self, task: TodoTask) -> Result<Message> {
-        // Convert the task to a message and process it
-        self.process_message(Message::new(task.description)).await
-    }
-
-    fn get_check_interval(&self) -> Duration {
-        // Default check interval of 5 seconds
-        Duration::from_secs(60)
-    }
-
-    fn get_todo_list(&self) -> &TodoList {
-        &self.todo_list
-    }
-}
-
 #[async_trait]
 impl Agent for AgentWrapper {
-    async fn process_message(&self, message: Message) -> Result<Message> {
-        self.inner.process_message(message).await
+    async fn process_message(&mut self, message: Message) -> Result<Message> {
+        let mut agent = self.agent.write().await;
+        agent.process_message(message).await
     }
 
     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message> {
-        self.inner.transfer_to(target_agent, message).await
+        let agent = self.agent.read().await;
+        agent.transfer_to(target_agent, message).await
     }
 
     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String> {
-        self.inner.call_tool(tool, params).await
-    }
-
-    async fn get_config(&self) -> Result<AgentConfig> {
-        self.inner.get_config().await
+        let agent = self.agent.read().await;
+        agent.call_tool(tool, params).await
     }
 
     async fn get_current_state(&self) -> Result<Option<State>> {
-        self.inner.get_current_state().await
+        let agent = self.agent.read().await;
+        agent.get_current_state().await
     }
 
-    fn get_todo_list(&self) -> Option<&TodoList> {
-        Some(&self.todo_list)
+    async fn get_config(&self) -> Result<AgentConfig> {
+        let agent = self.agent.read().await;
+        agent.get_config().await
     }
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::agents::GreeterAgent;
 
     #[tokio::test]
     async fn test_agent_wrapper() {
-        let config = AgentConfig {
-            name: "test".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        };
-
-        let agent = GreeterAgent::new(config);
-        let wrapper = AgentWrapper::new(Box::new(agent));
-
-        // Test that we can process messages
-        let response = wrapper.process_message(Message::new("test".to_string())).await;
-        assert!(response.is_ok());
+        let agent = Box::new(DummyAgent::new());
+        let mut wrapper = AgentWrapper::new(agent);
 
-        // Test state access
-        let state = wrapper.get_current_state().await;
-        assert!(state.is_ok());
+        let message = Message::new("test".to_string());
+        let response = wrapper.process_message(message).await.unwrap();
+        assert!(response.content.contains("test"));
     }
 }
diff --git a/src/api/mod.rs b/src/api/mod.rs
index ef8710f..cdce159 100644
--- a/src/api/mod.rs
+++ b/src/api/mod.rs
@@ -16,17 +16,14 @@ use crate::{
 pub mod routes;
 pub mod websocket;
 
+#[derive(Clone)]
 pub struct AppState {
-    pub transfer_service: Arc<RwLock<TransferService>>,
     pub agents: Arc<RwLock<AgentRegistry>>,
 }
 
 impl AppState {
-    pub fn new(transfer_service: Arc<RwLock<TransferService>>) -> Self {
-        Self {
-            transfer_service,
-            agents: Arc::new(RwLock::new(AgentRegistry::new()))
-        }
+    pub fn new(agents: Arc<RwLock<AgentRegistry>>) -> Self {
+        Self { agents }
     }
 }
 
@@ -35,13 +32,12 @@ pub async fn create_app_state() -> Arc<AppState> {
     let registry = Arc::new(RwLock::new(registry));
     let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
 
-    Arc::new(AppState::new(transfer_service))
+    Arc::new(AppState::new(registry))
 }
 
 pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferService>>) {
     let registry = AgentRegistry::create_default_agents(routes::default_agents()).await.unwrap();
     let app_state = Arc::new(AppState {
-        transfer_service,
         agents: Arc::new(RwLock::new(registry)),
     });
 
@@ -67,10 +63,17 @@ pub async fn serve(addr: SocketAddr, transfer_service: Arc<RwLock<TransferServic
     .unwrap();
 }
 
-pub fn create_router(state: Arc<AppState>) -> Router {
+pub fn create_router(agents: Arc<RwLock<AgentRegistry>>) -> Router {
+    let state = Arc::new(AppState { agents });
+    
     Router::new()
-        .route("/agents", get(routes::list_agents))
-        .route("/agents/:agent_name/message", post(routes::send_message))
+        .route("/", get(routes::index))
+        .route("/api/agents", get(routes::list_agents))
+        .route("/api/agents/:name", get(routes::get_agent))
+        .route("/api/agents/:name/message", post(routes::send_message))
+        .route("/api/agents/:name/tasks", get(routes::get_tasks))
+        .route("/api/agents/:name/tasks", post(routes::add_task))
+        .route("/api/agents/:name/tasks/:task_id", get(routes::get_task))
         .route("/ws", get(websocket::websocket_handler))
         .with_state(state)
 }
diff --git a/src/api/routes.rs b/src/api/routes.rs
index 7b5818f..88d8249 100644
--- a/src/api/routes.rs
+++ b/src/api/routes.rs
@@ -7,13 +7,56 @@ use axum::{
 use serde::{Deserialize, Serialize};
 use std::sync::Arc;
 use tokio::sync::RwLock;
+use thiserror::Error;
+use std::error::Error as StdError;
+use crate::types::todo::TodoListExt;
+use chrono::{DateTime, Utc};
 
 use crate::{
     api::AppState,
-    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor},
+    types::{Message, AgentConfig, Agent, AgentInfo, TodoTask, TaskPriority, TaskStatus, TodoProcessor, MessageMetadata},
     agents::AgentRegistry,
 };
 
+#[derive(Debug, Error, Clone, PartialEq)]
+pub enum AppError {
+    #[error("Status: {0}")]
+    Status(StatusCode),
+    #[error("Agent error: {0}")]
+    AgentError(String),
+    #[error("Serialization error")]
+    SerializationError,
+}
+
+impl From<StatusCode> for AppError {
+    fn from(status: StatusCode) -> Self {
+        AppError::Status(status)
+    }
+}
+
+impl From<Box<dyn StdError + Send + Sync>> for AppError {
+    fn from(err: Box<dyn StdError + Send + Sync>) -> Self {
+        AppError::AgentError(err.to_string())
+    }
+}
+
+impl From<serde_json::Error> for AppError {
+    fn from(_: serde_json::Error) -> Self {
+        AppError::SerializationError
+    }
+}
+
+impl IntoResponse for AppError {
+    fn into_response(self) -> Response {
+        let status = match self {
+            AppError::Status(status) => status,
+            AppError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
+            AppError::SerializationError => StatusCode::INTERNAL_SERVER_ERROR,
+        };
+        (status, self.to_string()).into_response()
+    }
+}
+
 pub async fn index() -> Response {
     "Welcome to the Swarmonomicon API".into_response()
 }
@@ -24,157 +67,108 @@ pub struct AgentResponse {
     description: String,
 }
 
-#[derive(Debug, Deserialize)]
+#[derive(Deserialize)]
 pub struct MessageRequest {
-    content: String,
+    pub content: String,
+}
+
+#[derive(Debug, Serialize)]
+pub struct MessageResponse {
+    pub content: String,
+    pub metadata: Option<serde_json::Value>,
 }
 
 pub async fn list_agents(
     State(state): State<Arc<AppState>>,
-) -> Result<Json<Vec<AgentInfo>>, StatusCode> {
+) -> Result<Json<Vec<String>>, AppError> {
     let registry = state.agents.read().await;
-    let mut agents = Vec::new();
-
-    for (name, agent) in registry.agents.iter() {
-        match agent.get_config().await {
-            Ok(config) => agents.push(AgentInfo {
-                name: name.clone(),
-                description: config.public_description,
-                tools: config.tools,
-                downstream_agents: config.downstream_agents,
-            }),
-            Err(_) => return Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    }
-
+    let agents = registry.list_agents();
     Ok(Json(agents))
 }
 
 pub async fn get_agent(
-    State(state): State<Arc<AppState>>,
     Path(name): Path<String>,
-) -> Result<Json<AgentInfo>, StatusCode> {
+    State(state): State<Arc<AppState>>,
+) -> Result<Json<MessageResponse>, AppError> {
     let registry = state.agents.read().await;
-
-    if let Some(agent) = registry.get(&name) {
-        match agent.get_config().await {
-            Ok(config) => Ok(Json(AgentInfo {
-                name: config.name,
-                description: config.public_description,
-                tools: config.tools,
-                downstream_agents: config.downstream_agents,
-            })),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
-    }
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let config = agent.read().await.get_config().await?;
+    Ok(Json(MessageResponse {
+        content: format!("Agent {} is ready", config.name),
+        metadata: None,
+    }))
 }
 
 pub async fn process_message(
     State(state): State<Arc<AppState>>,
     Path(agent_name): Path<String>,
     Json(request): Json<MessageRequest>,
-) -> Result<Json<Message>, StatusCode> {
+) -> Result<Json<Message>, AppError> {
     let registry = state.agents.read().await;
-
-    if let Some(agent) = registry.get(&agent_name) {
-        match agent.process_message(Message::new(request.content)).await {
-            Ok(response) => Ok(Json(response)),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
-    }
+    let agent = registry.get_agent(&agent_name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let mut agent_lock = agent.write().await;
+    let response = agent_lock.process_message(Message::new(request.content)).await?;
+    Ok(Json(response))
 }
 
 pub async fn send_message(
+    Path(name): Path<String>,
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
     Json(request): Json<MessageRequest>,
-) -> Result<Json<Message>, StatusCode> {
+) -> Result<Json<MessageResponse>, AppError> {
     let registry = state.agents.read().await;
-
-    if let Some(agent) = registry.get(&agent_name) {
-        match agent.process_message(Message::new(request.content)).await {
-            Ok(response) => Ok(Json(response)),
-            Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
-        }
-    } else {
-        Err(StatusCode::NOT_FOUND)
-    }
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let mut agent_lock = agent.write().await;
+    let response = agent_lock.process_message(Message::new(request.content)).await?;
+    Ok(Json(MessageResponse {
+        content: response.content,
+        metadata: Some(serde_json::to_value(response.metadata)?),
+    }))
 }
 
-pub fn default_agents() -> Vec<AgentConfig> {
-    // vec![ restore default later ?
-    //     AgentConfig {
-    //         name: "greeter".to_string(),
-    //         public_description: "Agent that greets the user.".to_string(),
-    //         instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
-    //         tools: Vec::new(),
-    //         downstream_agents: vec!["haiku".to_string()],
-    //         personality: None,
-    //         state_machine: None,
-    //     }
-    // ]
-    let mut agents = Vec::new();
-
-    #[cfg(feature = "greeter-agent")]
-    agents.push(AgentConfig {
-        name: "greeter".to_string(),
-        public_description: "Agent that greets the user.".to_string(),
-        instructions: "Please greet the user and ask them if they'd like a Haiku. If yes, transfer them to the 'haiku' agent.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: vec!["haiku".to_string()],
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "haiku-agent")]
-    agents.push(AgentConfig {
-        name: "haiku".to_string(),
-        public_description: "Agent that creates haikus.".to_string(),
-        instructions: "Create haikus based on user input.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "git-agent")]
-    agents.push(AgentConfig {
-        name: "git".to_string(),
-        public_description: "Agent that helps with git operations.".to_string(),
-        instructions: "Help users with git operations like commit, branch, merge etc.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
-
-    #[cfg(feature = "project-init-agent")]
-    agents.push(AgentConfig {
-        name: "project-init".to_string(),
-        public_description: "Agent that helps initialize new projects.".to_string(),
-        instructions: "Help users create new projects with proper structure and configuration.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
+pub async fn handle_message(
+    Path(agent_name): Path<String>,
+    State(registry): State<Arc<RwLock<AgentRegistry>>>,
+    Json(request): Json<MessageRequest>,
+) -> Result<Json<MessageResponse>, AppError> {
+    let registry = registry.read().await;
+    let agent = registry.get_agent(&agent_name).ok_or(StatusCode::NOT_FOUND)?;
+    let mut agent_lock = agent.write().await;
+    let response = agent_lock.process_message(Message::new(request.content)).await?;
+    Ok(Json(MessageResponse {
+        content: response.content,
+        metadata: response.metadata.map(|m| serde_json::to_value(m).unwrap_or_default()),
+    }))
+}
 
-    #[cfg(feature = "browser-agent")]
-    agents.push(AgentConfig {
-        name: "browser".to_string(),
-        public_description: "Agent that controls browser automation.".to_string(),
-        instructions: "Help users with browser automation tasks.".to_string(),
-        tools: Vec::new(),
-        downstream_agents: Vec::new(),
-        personality: None,
-        state_machine: None,
-    });
+pub async fn handle_todo_list(
+    Path(agent_name): Path<String>,
+    State(registry): State<Arc<RwLock<AgentRegistry>>>,
+    Json(task): Json<TodoTask>,
+) -> Result<Json<MessageResponse>, AppError> {
+    let registry = registry.read().await;
+    let agent = registry.get_agent(&agent_name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent_lock = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
+    todo_list.add_task(task).await?;
+    Ok(Json(MessageResponse {
+        content: "Task added successfully".to_string(),
+        metadata: None,
+    }))
+}
 
-    agents
+pub fn default_agents() -> Vec<AgentConfig> {
+    vec![
+        AgentConfig {
+            name: "greeter".to_string(),
+            public_description: "Agent that greets the user.".to_string(),
+            instructions: "Please greet the user to the Swarmonomicon project.".to_string(),
+            tools: Vec::new(),
+            downstream_agents: vec!["haiku".to_string()],
+            personality: None,
+            state_machine: None,
+        }
+    ]
 }
 
 #[derive(Debug, Deserialize, Clone)]
@@ -184,253 +178,153 @@ pub struct AddTaskRequest {
     pub source_agent: Option<String>,
 }
 
-#[derive(Debug, Serialize)]
-pub struct TaskResponse {
-    pub id: String,
-    pub description: String,
-    pub priority: TaskPriority,
-    pub source_agent: Option<String>,
-    pub target_agent: String,
-    pub status: TaskStatus,
-    pub created_at: i64,
-    pub completed_at: Option<i64>,
-}
-
-impl From<TodoTask> for TaskResponse {
-    fn from(task: TodoTask) -> Self {
-        Self {
-            id: task.id,
-            description: task.description,
-            priority: task.priority,
-            source_agent: task.source_agent,
-            target_agent: task.target_agent,
-            status: task.status,
-            created_at: task.created_at,
-            completed_at: task.completed_at,
+impl From<AddTaskRequest> for TodoTask {
+    fn from(req: AddTaskRequest) -> Self {
+        TodoTask {
+            id: uuid::Uuid::new_v4().to_string(),
+            description: req.description,
+            priority: req.priority,
+            source_agent: req.source_agent,
+            target_agent: "".to_string(), // Will be set by the handler
+            status: TaskStatus::Pending,
+            created_at: Utc::now(),
+            completed_at: None,
         }
     }
 }
 
-// Add a task to an agent's todo list
 pub async fn add_task(
+    Path(name): Path<String>,
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
     Json(request): Json<AddTaskRequest>,
-) -> Result<Json<TaskResponse>, StatusCode> {
+) -> Result<Json<TodoTask>, AppError> {
     let registry = state.agents.read().await;
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent_lock = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
     
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-    
-    let task = TodoTask {
-        id: uuid::Uuid::new_v4().to_string(),
-        description: request.description,
-        priority: request.priority,
-        source_agent: request.source_agent,
-        target_agent: agent_name,
-        status: TaskStatus::Pending,
-        created_at: chrono::Utc::now().timestamp(),
-        completed_at: None,
-    };
+    let mut task: TodoTask = request.into();
+    task.target_agent = name;
     
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-    
-    todo_list.add_task(task.clone()).await;
-    
-    Ok(Json(TaskResponse::from(task)))
+    todo_list.add_task(task.clone()).await?;
+    Ok(Json(task))
 }
 
-// Get all tasks for an agent
 pub async fn get_tasks(
+    Path(name): Path<String>,
     State(state): State<Arc<AppState>>,
-    Path(agent_name): Path<String>,
-) -> Result<Json<Vec<TaskResponse>>, StatusCode> {
+) -> Result<Json<Vec<TodoTask>>, AppError> {
     let registry = state.agents.read().await;
-    
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-    
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-    
-    let tasks = todo_list.get_all_tasks().await;
-    
-    Ok(Json(tasks.into_iter().map(TaskResponse::from).collect()))
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent_lock = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
+    let tasks = todo_list.get_tasks().await;
+    Ok(Json(tasks))
 }
 
-// Get a specific task by ID
 pub async fn get_task(
+    Path((name, task_id)): Path<(String, String)>,
     State(state): State<Arc<AppState>>,
-    Path((agent_name, task_id)): Path<(String, String)>,
-) -> Result<Json<TaskResponse>, StatusCode> {
+) -> Result<Json<TodoTask>, AppError> {
     let registry = state.agents.read().await;
-    
-    let agent = registry.get(&agent_name)
-        .ok_or(StatusCode::NOT_FOUND)?;
-    
-    // Get the todo list from the agent
-    let todo_list = <dyn Agent>::get_todo_list(agent)
-        .ok_or(StatusCode::NOT_IMPLEMENTED)?;
-    
-    let task = todo_list.get_task(&task_id).await
-        .ok_or(StatusCode::NOT_FOUND)?;
-    
-    Ok(Json(TaskResponse::from(task)))
+    let agent = registry.get_agent(&name).ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    let agent_lock = agent.read().await;
+    let todo_list = TodoProcessor::get_todo_list(&*agent_lock);
+    let task = todo_list.get_task(&task_id).await.ok_or(AppError::Status(StatusCode::NOT_FOUND))?;
+    Ok(Json(task))
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::agents::{AgentRegistry, GreeterAgent, TransferService};
-    use crate::types::AgentConfig;
+    use crate::agents::greeter::GreeterAgent;
+    use axum::http::StatusCode;
+    use chrono::Utc;
 
-    #[tokio::test]
-    async fn test_list_agents() {
+    async fn setup_test_state() -> Arc<AppState> {
         let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test".to_string(),
+        let config = AgentConfig {
+            name: "test_agent".to_string(),
             public_description: "Test agent".to_string(),
             instructions: "Test instructions".to_string(),
             tools: vec![],
             downstream_agents: vec![],
             personality: None,
             state_machine: None,
-        });
-
-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let state = Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
-            agents: registry,
-        });
+        };
+        registry.register("test_agent".to_string(), Box::new(GreeterAgent::new(config)));
+        Arc::new(AppState {
+            agents: Arc::new(RwLock::new(registry)),
+        })
+    }
 
+    #[tokio::test]
+    async fn test_list_agents() {
+        let state = setup_test_state().await;
         let response = list_agents(State(state)).await.unwrap();
-        assert_eq!(response.0.len(), 1);
-        assert_eq!(response.0[0].name, "test");
+        assert!(!response.0.is_empty());
     }
 
     #[tokio::test]
     async fn test_get_agent() {
-        let registry = Arc::new(RwLock::new(AgentRegistry::new()));
-        let transfer_service = Arc::new(RwLock::new(crate::agents::TransferService::new(registry.clone())));
-        let state = Arc::new(AppState {
-            transfer_service,
-            agents: registry,
-        });
-        let response = get_agent(State(state.clone()), Path("unknown".to_string())).await;
-        assert!(response.is_err());
-        assert_eq!(response.unwrap_err(), StatusCode::NOT_FOUND);
+        let state = setup_test_state().await;
+        let response = get_agent(Path("test_agent".to_string()), State(state)).await.unwrap();
+        assert!(response.0.content.contains("ready"));
     }
 
     #[tokio::test]
     async fn test_send_message() {
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let state = Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
-            agents: registry,
-        });
-
+        let state = setup_test_state().await;
         let request = MessageRequest {
             content: "Hello".to_string(),
         };
-
         let response = send_message(
+            Path("test_agent".to_string()),
             State(state),
-            Path("test".to_string()),
             Json(request),
-        ).await;
-        assert!(response.is_ok());
+        )
+        .await
+        .unwrap();
+        assert!(!response.0.content.is_empty());
     }
 
     #[tokio::test]
     async fn test_todo_list_endpoints() {
-        // Create test state
-        let mut registry = AgentRegistry::new();
-        let agent = GreeterAgent::new(AgentConfig {
-            name: "test_agent".to_string(),
-            public_description: "Test agent".to_string(),
-            instructions: "Test instructions".to_string(),
-            tools: vec![],
-            downstream_agents: vec![],
-            personality: None,
-            state_machine: None,
-        });
-
-        registry.register("test_agent".to_string(), Box::new(agent)).await.unwrap();
-        let registry = Arc::new(RwLock::new(registry));
-        let transfer_service = Arc::new(RwLock::new(TransferService::new(registry.clone())));
-        let state = Arc::new(AppState {
-            transfer_service,
-            agents: registry,
-        });
-
-        // Test adding a task
-        let add_request = AddTaskRequest {
+        let state = setup_test_state().await;
+        
+        // Test add task
+        let request = AddTaskRequest {
             description: "Test task".to_string(),
             priority: TaskPriority::Medium,
             source_agent: None,
         };
-
+        
         let response = add_task(
-            State(state.clone()),
             Path("test_agent".to_string()),
-            Json(add_request.clone()),
-        ).await.unwrap();
-
-        let task = response.0;
-        assert_eq!(task.description, "Test task");
-        assert_eq!(task.status, TaskStatus::Pending);
-
-        // Test getting all tasks
-        let tasks = get_tasks(
-            State(state.clone()),
-            Path("test_agent".to_string()),
-        ).await.unwrap();
-
-        assert_eq!(tasks.0.len(), 1);
-        assert_eq!(tasks.0[0].description, "Test task");
-
-        // Test getting a specific task
-        let task = get_task(
-            State(state.clone()),
-            Path(("test_agent".to_string(), task.id.clone())),
-        ).await.unwrap();
-
-        assert_eq!(task.0.description, "Test task");
-        assert_eq!(task.0.id, task.0.id);
-
-        // Test getting a non-existent task
-        let result = get_task(
             State(state.clone()),
-            Path(("test_agent".to_string(), "non-existent".to_string())),
-        ).await;
-
-        assert!(result.is_err());
-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
+            Json(request),
+        )
+        .await
+        .unwrap();
+        assert!(response.0.id.len() > 0);
 
-        // Test adding a task to a non-existent agent
-        let result = add_task(
+        // Test get tasks
+        let response = get_tasks(
+            Path("test_agent".to_string()),
             State(state.clone()),
-            Path("non-existent".to_string()),
-            Json(add_request),
-        ).await;
+        )
+        .await
+        .unwrap();
+        assert_eq!(response.0.len(), 1);
 
-        assert!(result.is_err());
-        assert_eq!(result.unwrap_err(), StatusCode::NOT_FOUND);
+        // Test get task
+        let task_id = response.0[0].id.clone();
+        let response = get_task(
+            Path(("test_agent".to_string(), task_id)),
+            State(state),
+        )
+        .await
+        .unwrap();
+        assert!(response.0.description.contains("Test task"));
     }
 }
diff --git a/src/api/websocket.rs b/src/api/websocket.rs
index 0fa75aa..a27e7e9 100644
--- a/src/api/websocket.rs
+++ b/src/api/websocket.rs
@@ -17,6 +17,8 @@ use crate::{
 use crate::agents::HaikuAgent;
 
 use tokio::sync::RwLock;
+use crate::api::routes::AppError;
+use axum::http::StatusCode;
 
 const CHANNEL_SIZE: usize = 32;
 
@@ -52,6 +54,21 @@ pub enum ServerMessage {
     SessionUpdated,
 }
 
+#[derive(Debug)]
+pub enum WebSocketError {
+    ConnectionError(String),
+    AgentError(String),
+}
+
+impl From<WebSocketError> for StatusCode {
+    fn from(error: WebSocketError) -> Self {
+        match error {
+            WebSocketError::ConnectionError(_) => StatusCode::BAD_REQUEST,
+            WebSocketError::AgentError(_) => StatusCode::INTERNAL_SERVER_ERROR,
+        }
+    }
+}
+
 pub async fn websocket_handler(
     ws: WebSocketUpgrade,
     State(state): State<Arc<AppState>>,
@@ -62,47 +79,57 @@ pub async fn websocket_handler(
 async fn handle_socket(mut socket: WebSocket, state: Arc<AppState>) {
     let (mut sender, mut receiver) = socket.split();
 
-    while let Some(Ok(msg)) = receiver.next().await {
-        if let WsMessage::Text(content) = msg {
-            let response = match serde_json::from_str::<ClientMessage>(&content) {
-                Ok(client_msg) => {
-                    match handle_client_message(client_msg, state.clone()).await {
-                        Ok(server_msg) => {
-                            match serde_json::to_string(&server_msg) {
-                                Ok(json) => WsMessage::Text(json),
-                                Err(_) => WsMessage::Text("Error serializing response".to_string()),
-                            }
-                        },
-                        Err(e) => WsMessage::Text(format!("Error: {}", e)),
-                    }
-                },
-                Err(_) => WsMessage::Text("Invalid message format".to_string()),
-            };
-
-            if sender.send(response).await.is_err() {
-                break;
+    let mut registry = state.agents.write().await;
+    let greeter_agent = GreeterAgent::new();
+    registry.register("greeter".to_string(), Box::new(greeter_agent));
+    drop(registry);
+
+    while let Some(msg) = receiver.next().await {
+        let msg = msg.map_err(|_| AppError::Status(StatusCode::BAD_REQUEST))?;
+
+        match msg {
+            Message::Text(text) => {
+                let registry = state.agents.read().await;
+                if let Some(agent) = registry.get("greeter") {
+                    let response = agent.process_message(Message::new(text)).await
+                        .map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
+
+                    sender.send(Message::Text(response.content))
+                        .await
+                        .map_err(|_| AppError::Status(StatusCode::INTERNAL_SERVER_ERROR))?;
+                }
             }
+            _ => {}
         }
     }
+
+    Ok(())
 }
 
 async fn handle_client_message(msg: ClientMessage, state: Arc<AppState>) -> Result<ServerMessage, String> {
     match msg {
         ClientMessage::Connect { agent } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            transfer_service.set_current_agent(agent.clone());
+            let mut registry = state.agents.write().await;
+            let greeter_agent = GreeterAgent::new();
+            registry.register("greeter".to_string(), Box::new(greeter_agent));
+            drop(registry);
             Ok(ServerMessage::Connected { agent })
         },
         ClientMessage::Message { content } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            match transfer_service.process_message(Message::new(content)).await {
+            let mut registry = state.agents.write().await;
+            let greeter_agent = GreeterAgent::new();
+            registry.register("greeter".to_string(), Box::new(greeter_agent));
+            drop(registry);
+            match greeter_agent.process_message(Message::new(content)).await {
                 Ok(response) => Ok(ServerMessage::Message { content: response.content }),
                 Err(e) => Err(e.to_string()),
             }
         },
         ClientMessage::Transfer { from, to } => {
-            let mut transfer_service = state.transfer_service.write().await;
-            transfer_service.set_current_agent(to.clone());
+            let mut registry = state.agents.write().await;
+            let greeter_agent = GreeterAgent::new();
+            registry.register("greeter".to_string(), Box::new(greeter_agent));
+            drop(registry);
             Ok(ServerMessage::Transferred { from, to })
         },
         ClientMessage::UpdateSession { instructions, tools, turn_detection } => {
@@ -112,6 +139,44 @@ async fn handle_client_message(msg: ClientMessage, state: Arc<AppState>) -> Resu
     }
 }
 
+pub async fn handle_websocket(
+    mut ws: WebSocket,
+    State(state): State<Arc<AppState>>,
+) -> Result<(), WebSocketError> {
+    let mut registry = state.agents.write().await;
+    let config = AgentConfig {
+        name: "greeter".to_string(),
+        public_description: "Greeter agent".to_string(),
+        instructions: "Greets users".to_string(),
+        tools: vec![],
+        downstream_agents: vec![],
+        personality: None,
+        state_machine: None,
+    };
+    let greeter_agent = GreeterAgent::new(config);
+    registry.register("greeter".to_string(), Box::new(greeter_agent));
+    drop(registry);
+
+    while let Some(msg) = ws.recv().await {
+        let msg = msg.map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
+
+        if let WsMessage::Text(text) = msg {
+            let registry = state.agents.read().await;
+            if let Some(agent) = registry.get_agent("greeter") {
+                let mut agent = agent.write().await;
+                let response = agent.process_message(Message::new(text)).await
+                    .map_err(|e| WebSocketError::AgentError(e.to_string()))?;
+
+                ws.send(WsMessage::from(response))
+                    .await
+                    .map_err(|e| WebSocketError::ConnectionError(e.to_string()))?;
+            }
+        }
+    }
+
+    Ok(())
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -132,11 +197,10 @@ mod tests {
         };
 
         let greeter_agent = GreeterAgent::new(greeter_config);
-        registry.register("greeter".to_string(), Box::new(greeter_agent)).await.expect("Failed to register greeter agent");
+        registry.register("greeter".to_string(), Box::new(greeter_agent));
 
         let registry = Arc::new(RwLock::new(registry));
         Arc::new(AppState {
-            transfer_service: Arc::new(RwLock::new(TransferService::new(registry.clone()))),
             agents: registry,
         })
     }
diff --git a/src/types/mod.rs b/src/types/mod.rs
index 49bcc98..759adb6 100644
--- a/src/types/mod.rs
+++ b/src/types/mod.rs
@@ -5,7 +5,11 @@ use chrono;
 use std::str::FromStr;
 use thiserror::Error;
 use std::fmt;
-use crate::agents::{AgentRegistry, AgentWrapper};
+use crate::agents::AgentRegistry;
+pub use crate::agents::wrapper::AgentWrapper;
+use std::sync::{Arc, RwLock};
+use std::time::Duration;
+use axum::extract::ws::Message as WsMessage;
 
 pub mod todo;
 pub use todo::{TodoList, TodoProcessor, TodoTask, TaskPriority, TaskStatus};
@@ -58,8 +62,6 @@ pub struct TranscriptItem {
 pub struct Message {
     pub content: String,
     pub metadata: Option<MessageMetadata>,
-    pub role: Option<String>,
-    pub timestamp: Option<i64>,
 }
 
 impl Message {
@@ -67,24 +69,22 @@ impl Message {
         Self {
             content,
             metadata: None,
-            role: Some("assistant".to_string()),
-            timestamp: Some(chrono::Utc::now().timestamp()),
         }
     }
+}
 
-    pub fn with_metadata(mut self, metadata: Option<MessageMetadata>) -> Self {
-        self.metadata = metadata;
-        self
-    }
-
-    pub fn with_role(mut self, role: Option<String>) -> Self {
-        self.role = role;
-        self
+impl From<Message> for WsMessage {
+    fn from(msg: Message) -> Self {
+        WsMessage::Text(msg.content)
     }
+}
 
-    pub fn with_timestamp(mut self, timestamp: Option<i64>) -> Self {
-        self.timestamp = timestamp;
-        self
+impl From<WsMessage> for Message {
+    fn from(msg: WsMessage) -> Self {
+        match msg {
+            WsMessage::Text(content) => Message::new(content),
+            _ => Message::new("Unsupported message type".to_string()),
+        }
     }
 }
 
@@ -179,9 +179,9 @@ pub struct ValidationRule {
 
 pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;
 
-#[async_trait::async_trait]
+#[async_trait]
 pub trait Agent: Send + Sync {
-    async fn process_message(&self, message: Message) -> Result<Message>;
+    async fn process_message(&mut self, message: Message) -> Result<Message>;
     async fn transfer_to(&self, target_agent: String, message: Message) -> Result<Message>;
     async fn call_tool(&self, tool: &Tool, params: HashMap<String, String>) -> Result<String>;
     async fn get_current_state(&self) -> Result<Option<State>>;
@@ -194,9 +194,9 @@ pub trait Agent: Send + Sync {
     
     /// Add a task to another agent's todo list if it supports task processing
     async fn delegate_task(&self, task: TodoTask, registry: &AgentRegistry) -> Result<()> {
-        if let Some(target_agent) = registry.get(&task.target_agent) {
-            let todo_list = <AgentWrapper as TodoProcessor>::get_todo_list(target_agent);
-            todo_list.add_task(task).await;
+        if let Some(target_agent) = registry.get_agent(&task.target_agent) {
+            let todo_list = TodoProcessor::get_todo_list(&*target_agent.read().await);
+            todo_list.add_task(task).await?;
             Ok(())
         } else {
             Err(format!("Target agent '{}' not found", task.target_agent).into())
diff --git a/src/types/todo.rs b/src/types/todo.rs
index 40df62d..576365e 100644
--- a/src/types/todo.rs
+++ b/src/types/todo.rs
@@ -1,8 +1,13 @@
-use std::collections::VecDeque;
+use std::collections::HashMap;
 use serde::{Deserialize, Serialize};
 use tokio::sync::RwLock;
 use std::sync::Arc;
 use super::Message;
+use std::time::Duration;
+use async_trait::async_trait;
+use chrono::{DateTime, Utc};
+use super::Result;
+use crate::agents::wrapper::AgentWrapper;
 
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct TodoTask {
@@ -12,8 +17,8 @@ pub struct TodoTask {
     pub source_agent: Option<String>,
     pub target_agent: String,
     pub status: TaskStatus,
-    pub created_at: i64,
-    pub completed_at: Option<i64>,
+    pub created_at: DateTime<Utc>,
+    pub completed_at: Option<DateTime<Utc>>,
 }
 
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
@@ -32,94 +37,141 @@ pub enum TaskStatus {
     Failed,
 }
 
-#[derive(Debug, Clone, Default)]
+#[derive(Debug, Clone)]
 pub struct TodoList {
-    tasks: Arc<RwLock<VecDeque<TodoTask>>>,
+    tasks: HashMap<String, TodoTask>,
 }
 
 impl TodoList {
     pub fn new() -> Self {
         Self {
-            tasks: Arc::new(RwLock::new(VecDeque::new())),
+            tasks: HashMap::new(),
         }
     }
 
-    pub async fn add_task(&self, task: TodoTask) {
-        let mut tasks = self.tasks.write().await;
-        tasks.push_back(task);
+    pub fn add_task(&mut self, task: TodoTask) {
+        self.tasks.insert(task.id.clone(), task);
     }
 
-    pub async fn get_next_task(&self) -> Option<TodoTask> {
-        let mut tasks = self.tasks.write().await;
-        tasks.pop_front()
+    pub fn get_tasks(&self) -> Vec<TodoTask> {
+        self.tasks.values().cloned().collect()
     }
 
-    pub async fn peek_next_task(&self) -> Option<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.front().cloned()
+    pub fn get_task(&self, id: &str) -> Option<&TodoTask> {
+        self.tasks.get(id)
     }
 
-    pub async fn mark_task_completed(&self, task_id: &str) {
-        let mut tasks = self.tasks.write().await;
-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
+    pub fn get_task_mut(&mut self, id: &str) -> Option<&mut TodoTask> {
+        self.tasks.get_mut(id)
+    }
+
+    pub fn get_next_task(&self) -> Option<TodoTask> {
+        self.tasks.values()
+            .find(|t| t.status == TaskStatus::Pending)
+            .cloned()
+    }
+
+    pub fn mark_task_completed(&mut self, id: &str) {
+        if let Some(task) = self.get_task_mut(id) {
             task.status = TaskStatus::Completed;
-            task.completed_at = Some(chrono::Utc::now().timestamp());
+            task.completed_at = Some(Utc::now());
         }
     }
 
-    pub async fn mark_task_failed(&self, task_id: &str) {
-        let mut tasks = self.tasks.write().await;
-        if let Some(task) = tasks.iter_mut().find(|t| t.id == task_id) {
+    pub fn mark_task_failed(&mut self, id: &str) {
+        if let Some(task) = self.get_task_mut(id) {
             task.status = TaskStatus::Failed;
         }
     }
+}
+
+pub trait TodoProcessor {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message>;
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>>;
+    async fn start_processing(&mut self);
+    fn get_check_interval(&self) -> Duration {
+        Duration::from_secs(1)
+    }
+}
+
+#[async_trait]
+pub trait TodoListExt {
+    async fn add_task(&self, task: TodoTask) -> Result<()>;
+    async fn get_task(&self, id: &str) -> Option<TodoTask>;
+    async fn get_tasks(&self) -> Vec<TodoTask>;
+    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()>;
+    async fn delete_task(&self, id: &str) -> Result<()>;
+}
+
+#[async_trait]
+impl TodoListExt for Arc<RwLock<TodoList>> {
+    async fn add_task(&self, task: TodoTask) -> Result<()> {
+        let mut list = self.write().await;
+        list.add_task(task);
+        Ok(())
+    }
 
-    pub async fn is_empty(&self) -> bool {
-        let tasks = self.tasks.read().await;
-        tasks.is_empty()
+    async fn get_task(&self, id: &str) -> Option<TodoTask> {
+        let list = self.read().await;
+        list.get_task(id).cloned()
     }
 
-    pub async fn len(&self) -> usize {
-        let tasks = self.tasks.read().await;
-        tasks.len()
+    async fn get_tasks(&self) -> Vec<TodoTask> {
+        let list = self.read().await;
+        list.get_tasks()
     }
 
-    pub async fn get_all_tasks(&self) -> Vec<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.iter().cloned().collect()
+    async fn update_task(&self, id: &str, task: TodoTask) -> Result<()> {
+        let mut list = self.write().await;
+        if list.tasks.contains_key(id) {
+            list.tasks.insert(id.to_string(), task);
+            Ok(())
+        } else {
+            Err("Task not found".into())
+        }
     }
 
-    pub async fn get_task(&self, task_id: &str) -> Option<TodoTask> {
-        let tasks = self.tasks.read().await;
-        tasks.iter().find(|t| t.id == task_id).cloned()
+    async fn delete_task(&self, id: &str) -> Result<()> {
+        let mut list = self.write().await;
+        if list.tasks.remove(id).is_some() {
+            Ok(())
+        } else {
+            Err("Task not found".into())
+        }
     }
 }
 
-#[async_trait::async_trait]
-pub trait TodoProcessor: Send + Sync {
-    /// Process a single task from the todo list
-    async fn process_task(&self, task: TodoTask) -> super::Result<Message>;
-    
-    /// Get the interval at which this processor should check for new tasks
-    fn get_check_interval(&self) -> std::time::Duration;
-    
-    /// Get the todo list for this processor
-    fn get_todo_list(&self) -> &TodoList;
-    
-    /// Start the task processing loop
-    async fn start_processing(&self) -> super::Result<()> {
+impl TodoProcessor for AgentWrapper {
+    async fn process_task(&mut self, task: TodoTask) -> Result<Message> {
+        self.process_message(Message::new(task.description)).await
+    }
+
+    async fn get_todo_list(&self) -> Arc<RwLock<TodoList>> {
+        self.todo_list.clone()
+    }
+
+    async fn start_processing(&mut self) {
         loop {
-            if let Some(task) = self.get_todo_list().get_next_task().await {
-                match self.process_task(task.clone()).await {
+            let todo_list = self.get_todo_list().await;
+            let mut list = todo_list.write().await;
+            
+            if let Some(task) = list.get_next_task() {
+                drop(list); // Release the lock before processing
+                let result = self.process_task(task).await;
+                match result {
                     Ok(_) => {
-                        self.get_todo_list().mark_task_completed(&task.id).await;
+                        let mut list = todo_list.write().await;
+                        list.mark_task_completed(&task.id);
                     }
                     Err(_) => {
-                        self.get_todo_list().mark_task_failed(&task.id).await;
+                        let mut list = todo_list.write().await;
+                        list.mark_task_failed(&task.id);
                     }
                 }
+            } else {
+                drop(list);
+                tokio::time::sleep(Duration::from_secs(1)).await;
             }
-            tokio::time::sleep(self.get_check_interval()).await;
         }
     }
 } 
